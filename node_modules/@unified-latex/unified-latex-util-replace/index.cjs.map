{"version":3,"file":"index.cjs","sources":["../libs/replace-node.ts","../libs/utils/significant-node.ts","../libs/utils/join-without-excess-whitespace.ts","../libs/utils/wrap-significant-content.ts","../libs/utils/replace-streaming-command-in-array.ts","../libs/replace-streaming-command.ts","../libs/replace-node-during-visit.ts","../libs/unified-latex-streaming-command.ts"],"sourcesContent":["import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { visit, VisitInfo } from \"@unified-latex/unified-latex-util-visit\";\n\n/**\n * Recursively replace nodes in `ast`. The `visitor` function is called on each node. If\n * `visitor` returns a node or an array of nodes, those nodes replace the node passed to `visitor`.\n * If `null` is returned, the node is deleted. If `undefined` is returned, no replacement happens.\n */\nexport function replaceNode(\n    ast: Ast.Ast,\n    visitor: (\n        node: Ast.Node | Ast.Argument,\n        info: VisitInfo\n    ) =>\n        | Ast.Node\n        | Ast.Argument\n        | (Ast.Node | Ast.Argument)[]\n        | null\n        | undefined\n        | void\n) {\n    visit(ast, {\n        leave: (node, info) => {\n            let replacement = visitor(node, info);\n            // Returning `undefined` or the same node means we shouldn't replace that node\n            if (typeof replacement === \"undefined\" || replacement === node) {\n                return;\n            }\n\n            if (!info.containingArray || info.index == null) {\n                throw new Error(\n                    \"Trying to replace node, but cannot find containing array\"\n                );\n            }\n\n            if (\n                replacement === null ||\n                (Array.isArray(replacement) && replacement.length === 0)\n            ) {\n                // A null return means that we delete the current node\n                info.containingArray.splice(info.index, 1);\n                return info.index;\n            }\n\n            if (!Array.isArray(replacement)) {\n                replacement = [replacement];\n            }\n\n            info.containingArray.splice(info.index, 1, ...replacement);\n            // We don't want to *reprocess* the nodes we just inserted into the array,\n            // lest we get stuck in a recursive loop if the replacement contains the original.\n            // Thus we jump to the index after our replacements.\n            return info.index + replacement.length;\n        },\n    });\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Returns the first non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function firstSignificantNode(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): Ast.Node | null {\n    const index = firstSignificantNodeIndex(nodes, parbreaksAreInsignificant);\n    if (index == null) {\n        return null;\n    }\n    return nodes[index];\n}\n\n/**\n * Returns the last non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function lastSignificantNode(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): Ast.Node | null {\n    const index = lastSignificantNodeIndex(nodes, parbreaksAreInsignificant);\n    if (index == null) {\n        return null;\n    }\n    return nodes[index];\n}\n\n/**\n * Returns the index of the last non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function lastSignificantNodeIndex(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): number | undefined {\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        const node = nodes[i];\n        if (\n            match.whitespace(node) ||\n            match.comment(node) ||\n            (parbreaksAreInsignificant && match.parbreak(node))\n        ) {\n            continue;\n        }\n        return i;\n    }\n    return undefined;\n}\n\n/**\n * Returns the index of the first non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function firstSignificantNodeIndex(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): number | undefined {\n    for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (\n            match.whitespace(node) ||\n            match.comment(node) ||\n            (parbreaksAreInsignificant && match.parbreak(node))\n        ) {\n            continue;\n        }\n        return i;\n    }\n    return undefined;\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trimStart } from \"@unified-latex/unified-latex-util-trim\";\n\n/**\n * Is the node space-like? I.e., is it whitespace or\n * a comment with leading whitespace?\n */\nfunction isSpaceLike(node: Ast.Node): boolean {\n    return (\n        match.whitespace(node) ||\n        (match.comment(node) && Boolean(node.leadingWhitespace))\n    );\n}\n\n/**\n * Similar to `head.push(...tail)` except that whitespace at the start\n * of `tail` and the end of `head` is collapsed.\n */\nexport function joinWithoutExcessWhitespace(\n    head: Ast.Node[],\n    tail: Ast.Node[]\n): void {\n    if (tail.length === 0) {\n        return;\n    }\n    if (head.length === 0) {\n        head.push(...tail);\n        return;\n    }\n    const headEnd = head[head.length - 1];\n    const tailStart = tail[0];\n    // Whitespace we can just trim off from either end\n    if (match.whitespace(headEnd) && match.whitespace(tailStart)) {\n        head.push(...tail.slice(1));\n        return;\n    }\n    // If there's no whitespace at one of the ends, no need to worry\n    // unless `tailStart` is a comment, in which case it should \"eat\"\n    // the whitespace\n    if (!isSpaceLike(headEnd) || !isSpaceLike(tailStart)) {\n        if (match.whitespace(headEnd) && match.comment(tailStart)) {\n            const comment: Ast.Comment = {\n                type: \"comment\",\n                content: tailStart.content,\n                sameline: true,\n                leadingWhitespace: true,\n            };\n            tail = tail.slice(1);\n            trimStart(tail);\n            head.pop();\n            head.push(comment, ...tail);\n            return;\n        }\n        head.push(...tail);\n        return;\n    }\n\n    // If we're here, we have a comment with leading whitespace on one side\n    // and whitespace/comments on the other.\n    if (match.comment(headEnd) && match.comment(tailStart)) {\n        if (tailStart.leadingWhitespace || tailStart.sameline) {\n            head.push(\n                { type: \"comment\", content: tailStart.content },\n                ...tail.slice(1)\n            );\n            return;\n        }\n        head.push(...tail);\n        return;\n    }\n\n    // Exactly one side is a comment, so we should trim the whitespace and keep the comment,\n    // but make sure the comment has leading whitespace!\n    let comment = match.comment(headEnd) ? headEnd : tailStart;\n    if (!match.comment(comment)) {\n        throw new Error(\n            `Expected a comment but found ${JSON.stringify(comment)}`\n        );\n    }\n\n    if (!comment.leadingWhitespace || !comment.sameline) {\n        comment = {\n            type: \"comment\",\n            content: comment.content,\n            leadingWhitespace: true,\n            sameline: true,\n        };\n    }\n\n    head.pop();\n    head.push(comment, ...tail.slice(1));\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Wraps `content` in the specified wrapper. This command is roughly equivalent to\n * `wrapper(content)` except that leading and trailing whitespace and comments are extracted\n * from `content` and moved to the front or back of the return array. For example,\n * `[\" \", \"foo\", \"bar\", \"% xxx\"]` -> `[\" \", wrapped([\"foo\", \"bar\"]), \"% xxx\"]`.\n *\n */\nexport function wrapSignificantContent(\n    content: Ast.Node[],\n    wrapper: (content: Ast.Node[]) => Ast.Node[] | Ast.Node\n): Ast.Node[] {\n    let hoistUntil = 0;\n    let hoistAfter = content.length;\n    for (let i = 0; i < content.length; i++) {\n        if (match.whitespace(content[i]) || match.comment(content[i])) {\n            hoistUntil = i + 1;\n            continue;\n        }\n        break;\n    }\n    for (let j = content.length - 1; j >= 0; j--) {\n        if (match.whitespace(content[j]) || match.comment(content[j])) {\n            hoistAfter = j;\n            continue;\n        }\n        break;\n    }\n\n    if (hoistUntil === 0 && hoistAfter === content.length) {\n        return ensureArray(wrapper(content));\n    }\n\n    const frontMatter = content.slice(0, hoistUntil);\n    const middle = content.slice(hoistUntil, hoistAfter);\n    const backMatter = content.slice(hoistAfter, content.length);\n\n    return frontMatter.concat(wrapper(middle), backMatter);\n}\n\nfunction ensureArray(x: Ast.Node | Ast.Node[]) {\n    if (!Array.isArray(x)) {\n        return [x];\n    }\n    return x;\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { trimEnd, trimStart } from \"@unified-latex/unified-latex-util-trim\";\nimport { joinWithoutExcessWhitespace } from \"./join-without-excess-whitespace\";\nimport { wrapSignificantContent } from \"./wrap-significant-content\";\n\n/**\n * Replace commands identified by `isStreamingCommand` with the return value of `replacer`.\n * E.g., the array `[head, streamingCommand, ...tail]` will become `[head, replacer(tail, streamingCommand)]`.\n * This function does not split based on parbreaks/etc.. It is right-associative and returns\n * the streaming commands that were encountered.\n */\nexport function replaceStreamingCommandInArray(\n    nodes: Ast.Node[],\n    isStreamingCommand: (node: any) => node is Ast.Macro,\n    replacer: (\n        content: Ast.Node[],\n        streamingCommand: Ast.Macro\n    ) => Ast.Node | Ast.Node[]\n): { foundStreamingCommands: Ast.Node[] } {\n    // Streaming commands that come at the end don't do anything,\n    // so we should remove them\n    while (nodes.length > 0 && isStreamingCommand(nodes[nodes.length - 1])) {\n        nodes.pop();\n        trimEnd(nodes);\n    }\n\n    const foundStreamingCommands: Ast.Node[] = [];\n\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        const node = nodes[i];\n        if (isStreamingCommand(node)) {\n            const wrapper = (content: Ast.Node[]) => replacer(content, node);\n            let tail = nodes.slice(i + 1);\n            // Streaming commands are followed by whitespace, which becomes unneeded when the commands are replaced.\n            trimStart(tail);\n            tail = wrapSignificantContent(tail, wrapper);\n            foundStreamingCommands.push(node);\n\n            // Trim off what we're about to replace!\n            nodes.splice(i);\n\n            joinWithoutExcessWhitespace(nodes, tail);\n        }\n    }\n\n    return { foundStreamingCommands };\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport {\n    splitOnCondition,\n    unsplitOnMacro,\n} from \"@unified-latex/unified-latex-util-split\";\nimport {\n    trim,\n    trimEnd,\n    trimStart,\n} from \"@unified-latex/unified-latex-util-trim\";\nimport { firstSignificantNode } from \"./utils/significant-node\";\nimport { replaceStreamingCommandInArray } from \"./utils/replace-streaming-command-in-array\";\nimport { wrapSignificantContent } from \"./utils/wrap-significant-content\";\n\ntype Replacer = (nodes: Ast.Node[]) => Ast.Node[];\n\n/**\n * Process streaming commands in a group. If needed, \"escape\" the group.\n * For example, `{\\bfseries xx}` -> `\\textbf{xx}`, but `{foo \\bfseries xx}` -> `{foo \\textbf{xx}}`.\n */\nexport function replaceStreamingCommandInGroup(\n    group: Ast.Group,\n    isStreamingCommand: (node: any) => node is Ast.Macro,\n    replacer: (\n        content: Ast.Node[],\n        streamingCommand: Ast.Macro\n    ) => Ast.Node | Ast.Node[],\n    options?: {\n        macrosThatBreakPars?: string[];\n        environmentsThatDontBreakPars?: string[];\n    }\n): Ast.Node[] {\n    const content = group.content;\n    // If the group started with a streaming command, we want to pop\n    // out of the group. E.g. `{\\bfseries foo}` -> `\\textbf{foo}` and not `{\\textbf{foo}}`\n    let popFromGroup = isStreamingCommand(firstSignificantNode(content));\n\n    let innerProcessed = replaceStreamingCommand(\n        content,\n        isStreamingCommand,\n        replacer,\n        options\n    );\n\n    // If the group consisted of just streaming commands (for some reason...)\n    // it should be eliminated\n    if (innerProcessed.length === 0) {\n        return [];\n    }\n\n    if (popFromGroup) {\n        return innerProcessed;\n    } else {\n        return [{ type: \"group\", content: innerProcessed }];\n    }\n}\n\n/**\n * Given a group or a node array, look for streaming commands (e.g., `\\bfseries`) and replace them\n * with the specified macro. The \"arguments\" of the streaming command are passed to `replacer` and the return\n * value of `replacer` is inserted into the stream.\n *\n * By default, this command will split at parbreaks (since commands like `\\textbf{...} do not accept parbreaks in their\n * contents) and call `replacer` multiple times, once per paragraph.\n *\n * Commands are also split at environments and at any macros listed in `macrosThatBreakPars`.\n */\nexport function replaceStreamingCommand(\n    ast: Ast.Group | Ast.Node[],\n    isStreamingCommand: (node: any) => node is Ast.Macro,\n    replacer: (\n        content: Ast.Node[],\n        streamingCommand: Ast.Macro\n    ) => Ast.Node | Ast.Node[],\n    options?: {\n        macrosThatBreakPars?: string[];\n        environmentsThatDontBreakPars?: string[];\n    }\n): Ast.Node[] {\n    if (typeof isStreamingCommand !== \"function\") {\n        throw new Error(\n            `'isStreamingCommand' must be a function, not '${typeof isStreamingCommand}'`\n        );\n    }\n\n    const {\n        macrosThatBreakPars = [\n            \"part\",\n            \"chapter\",\n            \"section\",\n            \"subsection\",\n            \"subsubsection\",\n            \"vspace\",\n            \"smallskip\",\n            \"medskip\",\n            \"bigskip\",\n            \"hfill\",\n        ],\n        environmentsThatDontBreakPars = [],\n    } = options || {};\n\n    let processedContent: Ast.Node[] = [];\n    if (match.group(ast)) {\n        processedContent = replaceStreamingCommandInGroup(\n            ast,\n            isStreamingCommand,\n            replacer\n        );\n    }\n\n    if (Array.isArray(ast)) {\n        // Streaming commands that come at the end of a sequence of nodes don't do anything.\n        // They also will consume whitespace, so we should remove them and the whitespace.\n        const nodes = ast;\n        let scanIndex = nodes.length;\n        let sliceIndex = scanIndex;\n        while (\n            scanIndex > 0 &&\n            (isStreamingCommand(nodes[scanIndex - 1]) ||\n                match.whitespace(nodes[scanIndex - 1]))\n        ) {\n            scanIndex--;\n            if (isStreamingCommand(nodes[scanIndex])) {\n                sliceIndex = scanIndex;\n            }\n        }\n        if (sliceIndex !== nodes.length) {\n            nodes.splice(sliceIndex);\n        }\n\n        const macroThatBreaks = match.createMacroMatcher(macrosThatBreakPars);\n        const envThatDoesntBreak = match.createEnvironmentMatcher(\n            environmentsThatDontBreakPars\n        );\n        // A \"par\" is anything that a streaming command shouldn't wrap and breaks the stream.\n        // This includes regular pars, but also environments and special macros like \\section\n        const isPar = (node: Ast.Node) =>\n            match.parbreak(node) ||\n            match.macro(node, \"par\") ||\n            macroThatBreaks(node) ||\n            (match.environment(node) && !envThatDoesntBreak(node)) ||\n            node.type === \"displaymath\";\n\n        // We split on both a parbreak and a literal `\\par`. But we will\n        // normalize everything to be parbreaks\n        const splitByPar = splitOnCondition(nodes, isPar);\n        splitByPar.separators = splitByPar.separators.map((sep) =>\n            match.macro(sep, \"par\") ? { type: \"parbreak\" } : sep\n        );\n\n        const replacers: Replacer[] = [];\n        let segments = splitByPar.segments.map((segment) => {\n            if (segment.length === 0) {\n                return segment;\n            }\n            function applyAccumulatedReplacers(nodes: Ast.Node[]): Ast.Node[] {\n                if (replacers.length === 0) {\n                    return nodes;\n                }\n                return wrapSignificantContent(\n                    nodes,\n                    composeReplacers(replacers)\n                );\n            }\n\n            const { foundStreamingCommands } = replaceStreamingCommandInArray(\n                segment,\n                isStreamingCommand,\n                replacer\n            );\n\n            // All streaming commands in `segment` have now been replaced. However,\n            // there might be commands from the previous paragraphs that should wrap\n            // the current segment!\n            const ret = applyAccumulatedReplacers(segment);\n\n            // Any streaming commands from this segment will carry over to the next,\n            // so keep track of them.\n            foundStreamingCommands.forEach((macro) => {\n                replacers.push((nodes: Ast.Node[]) => {\n                    const ret = replacer(nodes, macro as Ast.Macro);\n                    if (!Array.isArray(ret)) {\n                        return [ret];\n                    }\n                    return ret;\n                });\n            });\n\n            return ret;\n        });\n\n        // Leading/trailing whitespace was hoisted in front/back of each replacer.\n        // Since we're separated by parbreaks, we can safely trim all that whitespace.\n        if (segments.length > 1) {\n            segments.forEach((segment, i) => {\n                if (i === 0) {\n                    trimEnd(segment);\n                } else if (i === segments.length - 1) {\n                    trimStart(segment);\n                } else {\n                    trim(segment);\n                }\n            });\n        }\n\n        processedContent = unsplitOnMacro({\n            segments: segments,\n            macros: splitByPar.separators,\n        });\n    }\n\n    return processedContent;\n}\n\n/**\n * Given a sequence of replacer functions `[f, g, h]` return\n * `h \\circ g \\circ f`\n *\n * @param {((nodes: Ast.Node[]) => Ast.Node)[]} replacers\n * @returns {(nodes: Ast.Node[]) => Ast.Node}\n */\nfunction composeReplacers(replacers: Replacer[]): Replacer {\n    if (replacers.length === 0) {\n        throw new Error(\"Cannot compose zero replacement functions\");\n    }\n    return (nodes: Ast.Node[]) => {\n        let ret = nodes;\n        for (let i = 0; i < replacers.length; i++) {\n            const func = replacers[i];\n            ret = func(ret);\n        }\n        return ret;\n    };\n}\n","import { VisitInfo } from \"@unified-latex/unified-latex-util-visit\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Replaces the current node with `replacement`. It is assumed that the current\n * node is in an array that is a child of a parent element. If this is not the case,\n * the function will error.\n */\nexport function replaceNodeDuringVisit(\n    replacement: Ast.Node | Ast.Argument | (Ast.Node | Ast.Argument)[],\n    info: VisitInfo\n) {\n    const parent = info.parents[0];\n    if (!parent) {\n        throw new Error(`Cannot replace node: parent not found`);\n    }\n    const container = parent[info.key as keyof typeof parent] as\n        | (Ast.Node | Ast.Argument)[]\n        | undefined;\n    if (!Array.isArray(container)) {\n        throw new Error(`Cannot replace node: containing array not found`);\n    }\n    if (info.index == null) {\n        throw new Error(`Cannot replace node: node index undefined`);\n    }\n    if (!Array.isArray(replacement)) {\n        container[info.index] = replacement;\n    } else {\n        container.splice(info.index, 1, ...replacement);\n    }\n}\n","import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trimEnd, trimStart } from \"@unified-latex/unified-latex-util-trim\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { replaceStreamingCommand } from \"./replace-streaming-command\";\nimport { replaceNodeDuringVisit } from \"./replace-node-during-visit\";\n\ntype PluginOptions = {\n    replacers: Record<\n        string,\n        (\n            content: Ast.Node[],\n            streamingCommand: Ast.Macro\n        ) => Ast.Node | Ast.Node[]\n    >;\n};\n\n/**\n * Unified plugin to replace all found streaming commands with their argument-style equivalents.\n * This only applies to sections of the tree with no math ancestor.\n *\n * @param options.replacer A record of macro names and replacer functions. A replacer function accepts content and the original streaming command and is expected to return the argument-style command. It may be called multiple times per streaming command.\n */\nexport const unifiedLatexReplaceStreamingCommands: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexReplaceStreamingCommands(options) {\n    const { replacers = {} } = options || {};\n    const isReplaceable = match.createMacroMatcher(replacers);\n    return (tree) => {\n        // We traverse all groups before we replace nodes in other contexts\n        visit(\n            tree,\n            (group, info) => {\n                if (\n                    info.context.hasMathModeAncestor ||\n                    !group.content.some(isReplaceable)\n                ) {\n                    return;\n                }\n\n                let fixed = replaceStreamingCommand(\n                    group,\n                    isReplaceable,\n                    (content, command) => {\n                        return replacers[command.content](content, command);\n                    }\n                );\n\n                // We cannot replace the node unless we can access the containing array.\n                if (!info.containingArray || info.index == null) {\n                    return;\n                }\n\n                // `fixed` may consist of only whitespace. If this is the case,\n                // surrounding whitespace must trimmed before\n                // inserting the group's contents.\n                const prevToken = info.containingArray[info.index - 1];\n                const nextToken = info.containingArray[info.index + 1];\n                if (\n                    match.whitespaceLike(prevToken) &&\n                    match.whitespaceLike(fixed[0])\n                ) {\n                    trimStart(fixed);\n                }\n                if (\n                    match.whitespaceLike(nextToken) &&\n                    match.whitespaceLike(fixed[fixed.length - 1])\n                ) {\n                    trimEnd(fixed);\n                }\n                replaceNodeDuringVisit(fixed, info);\n            },\n            { test: match.group }\n        );\n\n        visit(\n            tree,\n            (nodes, info) => {\n                if (\n                    info.context.hasMathModeAncestor ||\n                    !nodes.some(isReplaceable)\n                ) {\n                    return;\n                }\n\n                const replaced = replaceStreamingCommand(\n                    nodes,\n                    isReplaceable,\n                    (content, command) => {\n                        return replacers[command.content](content, command);\n                    }\n                );\n\n                // If we get back a different array than we input, the replacement did\n                // not happen in-place. In this case we need to manipulate `nodes`.\n                if (replaced !== nodes) {\n                    nodes.length = 0;\n                    nodes.push(...replaced);\n                }\n            },\n            { includeArrays: true, test: Array.isArray }\n        );\n    };\n};\n"],"names":["visit","match","comment","trimStart","trimEnd","splitOnCondition","nodes","ret","trim","unsplitOnMacro","unifiedLatexReplaceStreamingCommands"],"mappings":"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"}