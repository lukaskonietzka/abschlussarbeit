{"version":3,"file":"index.cjs","sources":["../libs/parse-align-environment.ts"],"sourcesContent":["import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport {\n    AlignEnvironmentPegParser,\n    decorateArrayForPegjs,\n} from \"@unified-latex/unified-latex-util-pegjs\";\n\n// The types returned by the grammar\ninterface RowItems {\n    cells: Ast.Node[][];\n    colSeps: Ast.String[];\n}\n\ninterface Row extends RowItems {\n    rowSep: Ast.Macro | null;\n    trailingComment: Ast.Comment | null;\n}\n\nexport function createMatchers(rowSepMacros: string[], colSep: string[]) {\n    const isRowSep = match.createMacroMatcher(rowSepMacros);\n    return {\n        isRowSep,\n        isColSep: (node: Ast.Node) =>\n            colSep.some((sep) => match.string(node, sep)),\n        isWhitespace: (node: Ast.Node) => match.whitespace(node),\n        isSameLineComment: (node: Ast.Node) =>\n            match.comment(node) && node.sameline,\n        isOwnLineComment: (node: Ast.Node) =>\n            match.comment(node) && !node.sameline,\n    };\n}\n\n/**\n * Parse the content of an align environment into an array of row objects.\n * Each row object looks like\n * ```\n *  {\n *    cells: [...],\n *    colSeps: [...],\n *    rowSep: ...,\n *    trailingComment: ...\n *  }\n * ```\n * `...` may be an ast node or `null`.\n *\n * @export\n * @param {[object]} ast\n * @param {string} [colSep=[\"&\"]]\n * @param {string} [rowSepMacros=[\"\\\\\", \"hline\", \"cr\"]]\n * @returns\n */\nexport function parseAlignEnvironment(\n    ast: Ast.Node[],\n    colSep = [\"&\"],\n    rowSepMacros = [\"\\\\\", \"hline\", \"cr\"]\n): Row[] {\n    if (!Array.isArray(ast)) {\n        throw new Error(\"You must pass an array of nodes\");\n    }\n    // We need to at functions to `nodes` so that it imitates\n    // a Javascript string. Because we're mutating, make a copy first\n    ast = decorateArrayForPegjs([...ast]);\n    // matchers are passed in via the second argument (the `options` argument)\n    // so they are available from within the Pegjs grammar.\n    return AlignEnvironmentPegParser.parse(\n        ast,\n        createMatchers(rowSepMacros, colSep)\n    ) as Row[];\n}\n"],"names":["match","decorateArrayForPegjs","AlignEnvironmentPegParser"],"mappings":";;;;AAkBgB,SAAA,eAAe,cAAwB,QAAkB;AAC/D,QAAA,WAAWA,sBAAAA,MAAM,mBAAmB,YAAY;AAC/C,SAAA;AAAA,IACH;AAAA,IACA,UAAU,CAAC,SACP,OAAO,KAAK,CAAC,QAAQA,sBAAAA,MAAM,OAAO,MAAM,GAAG,CAAC;AAAA,IAChD,cAAc,CAAC,SAAmBA,4BAAM,WAAW,IAAI;AAAA,IACvD,mBAAmB,CAAC,SAChBA,4BAAM,QAAQ,IAAI,KAAK,KAAK;AAAA,IAChC,kBAAkB,CAAC,SACfA,sBAAA,MAAM,QAAQ,IAAI,KAAK,CAAC,KAAK;AAAA,EAAA;AAEzC;AAqBgB,SAAA,sBACZ,KACA,SAAS,CAAC,GAAG,GACb,eAAe,CAAC,MAAM,SAAS,IAAI,GAC9B;AACL,MAAI,CAAC,MAAM,QAAQ,GAAG,GAAG;AACf,UAAA,IAAI,MAAM,iCAAiC;AAAA,EACrD;AAGA,QAAMC,sBAAsB,sBAAA,CAAC,GAAG,GAAG,CAAC;AAGpC,SAAOC,sBAA0B,0BAAA;AAAA,IAC7B;AAAA,IACA,eAAe,cAAc,MAAM;AAAA,EAAA;AAE3C;;;"}