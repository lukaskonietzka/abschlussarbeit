{"version":3,"file":"index.cjs","sources":["../libs/builders.ts"],"sourcesContent":["import type * as Ast from \"@unified-latex/unified-latex-types\";\n\ntype CoercibleNode = string | Ast.Node;\ntype CoercibleArgument = null | CoercibleNode | Ast.Argument;\ntype MacroSpecialOptions = {\n    escapeToken?: string;\n};\ntype ArgumentsSpecialOptions = {\n    braces?: string;\n    defaultOpenMark?: string;\n    defaultCloseMark?: string;\n};\ntype ArgumentSpecialOptions = {\n    braces?: string;\n    openMark?: string;\n    closeMark?: string;\n};\n\nfunction normalizeNode(node: CoercibleNode): Ast.Node {\n    if (typeof node === \"string\") {\n        return s(node);\n    }\n    return node;\n}\n\nfunction normalizeArgument(\n    arg: CoercibleArgument,\n    openMark = \"{\",\n    closeMark = \"}\"\n): Ast.Argument {\n    if (arg == null) {\n        return { type: \"argument\", content: [], openMark: \"\", closeMark: \"\" };\n    }\n    if (typeof arg === \"string\") {\n        return {\n            type: \"argument\",\n            openMark,\n            closeMark,\n            content: [s(arg)],\n        };\n    }\n    if (arg.type === \"argument\") {\n        return arg;\n    }\n    return { type: \"argument\", openMark, closeMark, content: [arg] };\n}\n\nfunction normalizeArgumentsList(\n    args?: CoercibleArgument | CoercibleArgument[],\n    openMark = \"{\",\n    closeMark = \"}\"\n): Ast.Argument[] {\n    if (args == null) {\n        return [];\n    }\n    if (Array.isArray(args)) {\n        return args.map((arg) => normalizeArgument(arg, openMark, closeMark));\n    }\n    return [normalizeArgument(args, openMark, closeMark)];\n}\n\ntype BracesPair = { openMark: string; closeMark: string };\nconst BRACES_MAP: Record<string, BracesPair> = {\n    \"*\": { openMark: \"\", closeMark: \"\" },\n    \"{\": { openMark: \"{\", closeMark: \"}\" },\n    \"[\": { openMark: \"[\", closeMark: \"]\" },\n    \"(\": { openMark: \"(\", closeMark: \")\" },\n    \"<\": { openMark: \"<\", closeMark: \">\" },\n};\nconst CLOSE_BRACES = new Set(\n    Object.values(BRACES_MAP)\n        .map((x) => x.closeMark)\n        .filter((x) => x)\n);\n\n/**\n * Turn a braces signature into an array of braces.\n */\nfunction bracesToOpenAndCloseMarks(braces: string): BracesPair[] {\n    const ret: BracesPair[] = [];\n\n    for (const char of braces.split(\"\")) {\n        if (CLOSE_BRACES.has(char)) {\n            continue;\n        }\n        const braces = BRACES_MAP[char];\n        if (braces == null) {\n            throw new Error(`Unknown open/close mark type \"${char}\"`);\n        }\n        braces;\n        ret.push(braces);\n    }\n\n    return ret;\n}\n\n/**\n * Create an Argument list. `special.braces` can optionally specify\n * the signature of the open/close marks that each argument uses. For example\n * ```\n * args([\"a\", \"b\"], { braces: \"[]{}\" });\n * ```\n * will result in arguments `[a]{b}`. Valid braces are `*`, `[`, `{`, `(`, and `<`.\n *\n * `null` may be passed as the value of an empty optional argument. If `null` is passed,\n * the `openBrace` and `closeBrace` of the argument will be set to empty strings and the\n * contents will be set to an empty array. For example,\n * ```\n * args([null, \"b\"], { braces: \"[]{}\" });\n * ```\n * will produce the same structure as if the the first \"optional argument\" were omitted in regular parsing.\n */\nexport function args(\n    args: CoercibleArgument | CoercibleArgument[],\n    special?: ArgumentsSpecialOptions\n): Ast.Argument[] {\n    if (!Array.isArray(args)) {\n        args = [args];\n    }\n    if (special?.braces) {\n        const braces = bracesToOpenAndCloseMarks(special.braces);\n        if (braces.length !== args.length) {\n            throw new Error(\n                `There is a difference between the number of supplied braces and the number of supplied arguments. ${args.length} supplied with braces signature ${special.braces}`\n            );\n        }\n        return args.map((arg, i) =>\n            normalizeArgument(arg, braces[i].openMark, braces[i].closeMark)\n        );\n    }\n\n    const openMark = special?.defaultOpenMark ?? \"{\";\n    const closeMark = special?.defaultCloseMark ?? \"}\";\n    return normalizeArgumentsList(args, openMark, closeMark);\n}\n\n/**\n * Create an Argument. `special.braces` can optionally specify\n * the signature of the open/close marks that each argument uses. For example\n * ```\n * arg(\"a\", { braces: \"[]\" });\n * ```\n * will result in arguments `[a]`. Valid braces are `*`, `[`, `{`, `<`, and `(`.\n *\n * `null` may be passed as the value of an empty optional argument. If `null` is passed,\n * the `openBrace` and `closeBrace` of the argument will be set to empty strings and the\n * contents will be set to an empty array. For example,\n * ```\n * args([null, \"b\"], { braces: \"[]{}\" });\n * ```\n * will produce the same structure as if the the first \"optional argument\" were omitted in regular parsing.\n */\nexport function arg(\n    args: CoercibleArgument | Ast.Node[],\n    special?: ArgumentSpecialOptions\n): Ast.Argument {\n    if (args == null) {\n        return { type: \"argument\", content: [], openMark: \"\", closeMark: \"\" };\n    }\n    if (typeof args === \"string\") {\n        args = s(args);\n    }\n    if (!Array.isArray(args) && args.type === \"argument\") {\n        return args;\n    }\n\n    let openMark = special?.openMark ?? \"{\";\n    let closeMark = special?.closeMark ?? \"}\";\n    if (special?.braces) {\n        const braces = bracesToOpenAndCloseMarks(special.braces);\n        if (braces[0]) {\n            openMark = braces[0].openMark;\n            closeMark = braces[0].closeMark;\n        }\n    }\n\n    if (!Array.isArray(args)) {\n        args = [args];\n    }\n\n    return { type: \"argument\", content: args, openMark, closeMark };\n}\n\n/**\n * Create a Macro with the given `name`. The macro\n * may be followed by any number of arguments.\n */\nexport function m(\n    name: string,\n    marcoArgs?: CoercibleArgument | CoercibleArgument[],\n    special?: MacroSpecialOptions\n): Ast.Macro {\n    const args = normalizeArgumentsList(marcoArgs);\n    const escapeToken = special?.escapeToken;\n    const ret: Ast.Macro = { type: \"macro\", content: name };\n\n    if (args.length > 0) {\n        ret.args = args;\n    }\n    if (escapeToken != null) {\n        ret.escapeToken = escapeToken;\n    }\n\n    return ret;\n}\n\n/**\n * Create a String node from `value`\n */\nexport function s(value: string | Ast.String): Ast.String {\n    if (typeof value === \"string\") {\n        return { type: \"string\", content: value };\n    }\n    return value;\n}\n\n/**\n * Create an Environment node.\n */\nexport function env(\n    name: string,\n    body: CoercibleNode | CoercibleNode[],\n    envArgs?: CoercibleArgument | CoercibleArgument[],\n    special?: unknown\n): Ast.Environment {\n    if (!Array.isArray(body)) {\n        body = [body];\n    }\n    const args = normalizeArgumentsList(envArgs, \"[\", \"]\");\n    const ret: Ast.Environment = {\n        type: \"environment\",\n        env: name,\n        content: body.map(normalizeNode),\n    };\n    if (args.length > 0) {\n        ret.args = args;\n    }\n\n    return ret;\n}\n\n/**\n * Whitespace node.\n */\nexport const SP: Ast.Whitespace = { type: \"whitespace\" };\n"],"names":["arg","args","braces"],"mappings":"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"}