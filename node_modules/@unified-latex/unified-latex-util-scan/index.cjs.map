{"version":3,"file":"index.cjs","sources":["../libs/scan.ts","../libs/prefix-match.ts"],"sourcesContent":["import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\n/**\n * Scan `nodes` looking for the first occurrence of `token`.\n * If `options.onlySkipWhitespaceAndComments==true`, then the scan\n * will only skip whitespace/comment nodes.\n */\nexport function scan(\n    nodes: (Ast.Node | Ast.Argument)[],\n    token: string | Ast.Node | Ast.Argument,\n    options?: {\n        /**\n         * Index to start scanning.\n         */\n        startIndex?: number;\n        /**\n         * If `true`, whitespace and comments will be skilled but any other\n         * node that doesn't match `token` will cause the scan to terminate.\n         */\n        onlySkipWhitespaceAndComments?: boolean;\n        /**\n         * If `true`, will look inside `Ast.String` nodes to see if the string contents\n         * contain `token`.\n         */\n        allowSubstringMatches?: boolean;\n    }\n): number | null {\n    const { startIndex, onlySkipWhitespaceAndComments, allowSubstringMatches } =\n        options || {};\n    if (typeof token === \"string\") {\n        token = { type: \"string\", content: token } as Ast.String;\n    }\n\n    for (let i = startIndex || 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (node.type === token.type) {\n            switch (node.type) {\n                case \"comment\":\n                case \"displaymath\":\n                case \"inlinemath\":\n                case \"root\":\n                case \"parbreak\":\n                case \"whitespace\":\n                case \"verb\":\n                case \"verbatim\":\n                case \"group\":\n                    return i;\n                case \"macro\":\n                    if (node.content === (token as Ast.Macro).content) {\n                        return i;\n                    }\n                    break;\n                case \"environment\":\n                case \"mathenv\":\n                    if (\n                        printRaw(node.env) ===\n                        printRaw((token as Ast.Environment).env)\n                    ) {\n                        return i;\n                    }\n                    break;\n                case \"string\":\n                    if (node.content === (token as Ast.String).content) {\n                        return i;\n                    }\n                    if (\n                        allowSubstringMatches &&\n                        node.content.indexOf((token as Ast.String).content) >= 0\n                    ) {\n                        return i;\n                    }\n                    break;\n            }\n        }\n        if (\n            onlySkipWhitespaceAndComments &&\n            !match.whitespace(node) &&\n            !match.comment(node)\n        ) {\n            return null;\n        }\n    }\n\n    return null;\n}\n","import Trie from \"trie-prefix-tree\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\nexport { Trie };\n\n/**\n * Efficiently search for a large number of strings using a prefix-tree.\n * The longest match is returned.\n *\n * @param options.startIndex the index to start scanning at. Defaults to 0.\n * @param options.matchSubstrings whether to allow matching only part of a substring.\n * @param options.assumeOneCharStrings assume that all strings are one character long (for example, like they are in math mode)\n */\nexport function prefixMatch(\n    nodes: Ast.Node[],\n    prefixes: string | string[] | ReturnType<typeof Trie>,\n    options?: {\n        startIndex?: number;\n        matchSubstrings?: boolean;\n        assumeOneCharStrings?: boolean;\n    }\n): {\n    match: string;\n    endNodeIndex: number;\n    endNodePartialMatch: string | null;\n} | null {\n    const {\n        startIndex = 0,\n        matchSubstrings = false,\n        assumeOneCharStrings = false,\n    } = options || {};\n\n    if (typeof prefixes === \"string\") {\n        prefixes = [prefixes];\n    }\n    if (Array.isArray(prefixes)) {\n        prefixes = Trie(prefixes);\n    }\n    const prefixTree = prefixes;\n\n    const history = {\n        lastPrefix: \"\",\n        lastWord: \"\",\n        index: startIndex,\n        partialMatch: \"\",\n    };\n\n    /**\n     * Try to match the next character. If it matches,\n     * record it properly in the `history` object.\n     */\n    function tryToMatchNextChar(char: string, index: number): boolean {\n        let ret = false;\n        if (prefixTree.isPrefix(history.lastPrefix + char)) {\n            history.lastPrefix += char;\n            history.index = index;\n            ret = true;\n        }\n        if (prefixTree.hasWord(history.lastPrefix)) {\n            history.lastWord = history.lastPrefix;\n        }\n        return ret;\n    }\n\n    // Loop through the nodes looking for the longest prefix match\n    for (let i = 0; startIndex + i < nodes.length; i++) {\n        const node = nodes[startIndex + i];\n        if (!match.string(node)) {\n            break;\n        }\n        if (assumeOneCharStrings && node.content.length !== 1) {\n            break;\n        }\n        if (matchSubstrings) {\n            // We need to test letter-by-letter for substring matches\n            let fullMatch = true;\n            history.partialMatch = \"\";\n            for (let j = 0; j < node.content.length; j++) {\n                const char = node.content[j];\n                if (tryToMatchNextChar(char, startIndex + i)) {\n                    history.partialMatch += char;\n                } else {\n                    fullMatch = false;\n                    break;\n                }\n            }\n            if (fullMatch) {\n                history.partialMatch = \"\";\n            } else {\n                break;\n            }\n        } else {\n            if (!tryToMatchNextChar(node.content, startIndex + i)) {\n                break;\n            }\n        }\n    }\n\n    return history.lastWord\n        ? {\n              match: history.lastWord,\n              endNodeIndex: history.index,\n              endNodePartialMatch: history.partialMatch\n                  ? history.partialMatch\n                  : null,\n          }\n        : null;\n}\n"],"names":["printRaw","match"],"mappings":"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"}