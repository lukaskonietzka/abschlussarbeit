{"version":3,"file":"index.js","sources":["../libs/gobble-single-argument.ts","../libs/gobble-arguments.ts","../libs/attach-arguments.ts","../libs/unified-latex-attach-macro-arguments.ts","../libs/get-args-content.ts"],"sourcesContent":["/* eslint-disable no-fallthrough */\nimport { arg } from \"@unified-latex/unified-latex-builder\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    ArgSpecAst as ArgSpec,\n    printRaw,\n} from \"@unified-latex/unified-latex-util-argspec\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { scan } from \"@unified-latex/unified-latex-util-scan\";\n\n/**\n * Gobbles an argument of whose type is specified\n * by `argSpec` starting at the position `startPos`.\n * If an argument couldn't be found, `argument` will be `null`.\n */\nexport function gobbleSingleArgument(\n    nodes: Ast.Node[],\n    argSpec: ArgSpec.Node,\n    startPos = 0\n): {\n    argument: Ast.Argument | null;\n    nodesRemoved: number;\n} {\n    if (typeof argSpec === \"string\" || !argSpec.type) {\n        throw new Error(\n            `argSpec must be an already-parsed argument specification, not \"${JSON.stringify(\n                argSpec\n            )}\"`\n        );\n    }\n\n    let argument: Ast.Argument | null = null;\n\n    let currPos = startPos;\n\n    // Gobble whitespace from `currPos` onward, updating `currPos`.\n    // If `argSpec` specifies leading whitespace is not allowed,\n    // this function does nothing.\n    const gobbleWhitespace = (argSpec as ArgSpec.LeadingWhitespace)\n        .noLeadingWhitespace\n        ? () => {}\n        : () => {\n              while (currPos < nodes.length) {\n                  if (!match.whitespace(nodes[currPos])) {\n                      break;\n                  }\n                  currPos++;\n              }\n          };\n\n    const openMark: string = (argSpec as any).openBrace || \"\";\n    const closeMark: string = (argSpec as any).closeBrace || \"\";\n\n    // Only mandatory arguments can be wrapped in {...}.\n    // Since we already parse such things as groups, we need to\n    // check the open and closing symbols to see if we allow for\n    // groups to be accepted as arguments\n    const acceptGroup =\n        (argSpec.type === \"mandatory\" || argSpec.type === \"optional\") &&\n        openMark === \"{\" &&\n        closeMark === \"}\";\n\n    // Do the actual matching\n    gobbleWhitespace();\n    const currNode = nodes[currPos];\n    if (\n        currNode == null ||\n        match.comment(currNode) ||\n        match.parbreak(currNode)\n    ) {\n        const ret: { argument: null; nodesRemoved: number } = {\n            argument,\n            nodesRemoved: 0,\n        };\n        return ret;\n    }\n\n    switch (argSpec.type) {\n        case \"mandatory\":\n            if (acceptGroup) {\n                // We have already gobbled whitespace, so at this point, `currNode`\n                // is either an openMark or we don't have an optional argument.\n                let content: Ast.Node[] = [currNode];\n                if (match.group(currNode)) {\n                    // Unwrap a group if there is one.\n                    content = currNode.content;\n                }\n                argument = arg(content, {\n                    openMark,\n                    closeMark,\n                });\n                currPos++;\n                break;\n            } else {\n                const bracePos = findBracePositions(\n                    nodes,\n                    currPos,\n                    openMark,\n                    closeMark\n                );\n                if (bracePos) {\n                    argument = arg(nodes.slice(bracePos[0] + 1, bracePos[1]), {\n                        openMark,\n                        closeMark,\n                    });\n                    currPos = bracePos[1] + 1;\n                    break;\n                }\n            }\n        // NOTE: Fallthrough is on purpose.\n        // Matching a mandatory argument and an optional argument is the same for our purposes\n        // because we're not going to fail to parse because of a missing argument.\n        case \"optional\":\n            // It is possible that an optional argument accepts a group if its open/close braces are `{}`\n            if (acceptGroup && match.group(currNode)) {\n                argument = arg(currNode.content, {\n                    openMark,\n                    closeMark,\n                });\n                currPos++;\n                break;\n            }\n            // If we're here, we have custom braces to match\n            const bracePos = findBracePositions(\n                nodes,\n                currPos,\n                openMark,\n                closeMark\n            );\n            if (bracePos) {\n                argument = arg(nodes.slice(bracePos[0] + 1, bracePos[1]), {\n                    openMark,\n                    closeMark,\n                });\n                currPos = bracePos[1] + 1;\n                break;\n            }\n            break;\n        case \"optionalStar\":\n        case \"optionalToken\": {\n            const bracePos = findBracePositions(\n                nodes,\n                currPos,\n                argSpec.type === \"optionalStar\" ? \"*\" : argSpec.token\n            );\n            if (bracePos) {\n                argument = arg(currNode, { openMark: \"\", closeMark: \"\" });\n                // Instead of `closeMarkPos` returned from findBracePositions,\n                // one should use `openMarkPos + ` because there's no argument\n                currPos = bracePos[0] + 1;\n            }\n            break;\n        }\n        case \"until\": {\n            if (argSpec.stopTokens.length > 1) {\n                console.warn(\n                    `\"until\" matches with multi-token stop conditions are not yet implemented`\n                );\n                break;\n            }\n            const rawToken = argSpec.stopTokens[0];\n            const stopToken: string | Ast.Whitespace =\n                rawToken === \" \" ? { type: \"whitespace\" } : rawToken;\n\n            let bracePos = findBracePositions(\n                nodes,\n                startPos,\n                undefined,\n                stopToken\n            );\n            // If the corresponding token is not found, eat nothing;\n            if (!bracePos) {\n                break;\n            }\n\n            argument = arg(nodes.slice(startPos, bracePos[1]), {\n                openMark: \"\",\n                closeMark: rawToken,\n            });\n            currPos = bracePos[1];\n            if (currPos < nodes.length) {\n                currPos++;\n            }\n            break;\n        }\n        case \"embellishment\": {\n            for (const token of argSpec.embellishmentTokens) {\n                const bracePos = findBracePositions(nodes, currPos, token);\n                if (!bracePos) {\n                    continue;\n                }\n                let argNode = nodes[bracePos[0] + 1];\n                argument = arg(\n                    match.group(argNode) ? argNode.content : argNode,\n                    {\n                        openMark: token,\n                        closeMark: \"\",\n                    }\n                );\n                currPos = bracePos[1] + 1;\n                break;\n            }\n            break;\n        }\n        default:\n            console.warn(\n                `Don't know how to find an argument of argspec type \"${argSpec.type}\"`\n            );\n    }\n\n    // `currPos` is has already stepped past any whitespace. However,\n    // if we did not consume an argument, we don't want to consume the whitespace.\n    const nodesRemoved = argument ? currPos - startPos : 0;\n    nodes.splice(startPos, nodesRemoved);\n    return { argument, nodesRemoved };\n}\n\nfunction cloneStringNode(node: Ast.String, content: string): Ast.String {\n    return Object.assign({}, node, { content });\n}\n\n/**\n * Find the position of the open brace and the closing brace.\n * Returns undefined if the brace isn't found.\n * This may mutate `nodes`, if braces are not a kind of characters that are\n * always parsed as a separate token\n */\nfunction findBracePositions(\n    nodes: Ast.Node[],\n    startPos: number,\n    openMark?: string,\n    closeMark?: string | Ast.Node\n): [number, number] | undefined {\n    const currNode = nodes[startPos];\n    let openMarkPos = startPos;\n    let closeMarkPos: number | null = startPos;\n    if (openMark) {\n        if (!match.anyString(currNode)) {\n            return;\n        }\n        const nodeContent = currNode.content;\n        // The first node we encounter must contain the opening brace.\n        if (!nodeContent.startsWith(openMark)) {\n            return;\n        }\n        openMarkPos = startPos;\n        if (currNode.content.length > openMark.length) {\n            const nodeContent = currNode.content;\n            currNode.content = openMark;\n            nodes.splice(\n                openMarkPos + 1,\n                0,\n                cloneStringNode(currNode, nodeContent.slice(openMark.length))\n            );\n        }\n        closeMarkPos = openMarkPos + 1;\n    }\n    if (!closeMark) {\n        // In such a case, the token immediately preceding the opening brace\n        // will be treated as an argument. If the next token is a string node,\n        // only its first character is picked up.\n        const argNode = nodes[closeMarkPos];\n        if (!argNode) {\n            return;\n        }\n        if (match.anyString(argNode) && argNode.content.length > 1) {\n            const argContent = argNode.content;\n            argNode.content = argContent[0];\n            nodes.splice(\n                closeMarkPos + 1,\n                0,\n                cloneStringNode(argNode, argContent.slice(1))\n            );\n        }\n        return [openMarkPos, closeMarkPos];\n    }\n    // scan for closing marks\n    closeMarkPos = scan(nodes, closeMark, {\n        startIndex: closeMarkPos,\n        allowSubstringMatches: true,\n    });\n    if (closeMarkPos === null) {\n        return;\n    }\n    const closingNode = nodes[closeMarkPos];\n    if (match.anyString(closingNode) && typeof closeMark === \"string\") {\n        const closingNodeContent = closingNode.content;\n        let closeMarkIndex = closingNodeContent.indexOf(closeMark);\n        if (closingNodeContent.length > closeMark.length) {\n            closingNode.content = closeMark;\n            const prev = closingNodeContent.slice(0, closeMarkIndex);\n            const next = closingNodeContent.slice(\n                closeMarkIndex + closeMark.length\n            );\n            if (prev) {\n                nodes.splice(\n                    closeMarkPos,\n                    0,\n                    cloneStringNode(closingNode, prev)\n                );\n                closeMarkPos++;\n            }\n            if (next) {\n                nodes.splice(\n                    closeMarkPos + 1,\n                    0,\n                    cloneStringNode(closingNode, next)\n                );\n            }\n        }\n    }\n    return [openMarkPos, closeMarkPos];\n}\n","import { arg } from \"@unified-latex/unified-latex-builder\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { ArgumentParser } from \"@unified-latex/unified-latex-types\";\nimport {\n    ArgSpecAst as ArgSpec,\n    parse as parseArgspec,\n} from \"@unified-latex/unified-latex-util-argspec\";\nimport { gobbleSingleArgument } from \"./gobble-single-argument\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\n\n/**\n * Gobbles an argument of whose type is specified\n * by `argSpec` starting at the position `startPos`. If an argument couldn't be found,\n * `argument` will be `null`.\n */\nexport function gobbleArguments(\n    nodes: Ast.Node[],\n    argSpec: string | ArgSpec.Node[] | ArgumentParser,\n    startPos = 0\n): {\n    args: Ast.Argument[];\n    nodesRemoved: number;\n} {\n    if (typeof argSpec === \"function\") {\n        return argSpec(nodes, startPos);\n    }\n\n    if (typeof argSpec === \"string\") {\n        argSpec = parseArgspec(argSpec);\n    }\n\n    const args: Ast.Argument[] = [];\n    let nodesRemoved = 0;\n\n    for (const spec of argSpec) {\n        if (spec.type === \"embellishment\") {\n            // We need special behavior for embellishment argspecs.\n            // Because an embellishment argspec specifies more than one argument,\n            // we need to keep gobbling arguments until we've got them all.\n            const remainingTokens = new Set(spec.embellishmentTokens);\n            const argForToken = Object.fromEntries(\n                spec.embellishmentTokens.map((t, i) => {\n                    // For empty arguments, we also store their default.\n                    const defaultArg =\n                        \"defaultArg\" in spec ? spec.defaultArg?.[i] : undefined;\n                    return [t, emptyArg(defaultArg)];\n                })\n            );\n\n            let { argument, nodesRemoved: removed } = gobbleSingleArgument(\n                nodes,\n                embellishmentSpec(remainingTokens),\n                startPos\n            );\n            while (argument) {\n                const token = argument.openMark;\n                remainingTokens.delete(token);\n                argForToken[token] = argument;\n                nodesRemoved += removed;\n                const newSpec = embellishmentSpec(remainingTokens);\n                ({ argument, nodesRemoved: removed } = gobbleSingleArgument(\n                    nodes,\n                    newSpec,\n                    startPos\n                ));\n            }\n\n            args.push(...spec.embellishmentTokens.map((t) => argForToken[t]));\n        } else {\n            const { argument, nodesRemoved: removed } = gobbleSingleArgument(\n                nodes,\n                spec,\n                startPos\n            );\n            // For empty arguments, we also store their default.\n            const defaultArg =\n                \"defaultArg\" in spec ? spec.defaultArg : undefined;\n            args.push(argument || emptyArg(defaultArg));\n            nodesRemoved += removed;\n        }\n    }\n\n    return { args, nodesRemoved };\n}\n\n/**\n * Create an embellishment argspec from a set of tokens.\n */\nfunction embellishmentSpec(tokens: Set<string>): ArgSpec.Embellishment {\n    return {\n        type: \"embellishment\",\n        embellishmentTokens: [...tokens],\n    };\n}\n\n/**\n * Create an empty argument.\n */\nfunction emptyArg(defaultArg?: string): Ast.Argument {\n    const ret = arg([], { openMark: \"\", closeMark: \"\" });\n    if (defaultArg != null) {\n        updateRenderInfo(ret, { defaultArg });\n    }\n    return ret;\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { MacroInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\nimport { gobbleArguments } from \"./gobble-arguments\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\n\n/**\n * Search (in a right-associative way) through the array for instances of\n * `macros` and attach arguments to the macro. Argument signatures are\n * specified by `macros[].signature`.\n *\n * Info stored in `macros[].renderInfo` will be attached to the node\n * with attribute `_renderInfo`.\n */\nexport function attachMacroArgsInArray(\n    nodes: Ast.Node[],\n    macros: MacroInfoRecord\n): void {\n    // Some preliminaries that are only used if `ast` is an array.\n    let currIndex: number;\n\n    /**\n     * Determine whether `node` matches one of the macros in `macros`.\n     * Care is taken when matching because not all macros have\n     * `\\` as their escape token.\n     */\n    const isRelevantMacro = match.createMacroMatcher(macros);\n\n    function gobbleUntilMacro() {\n        // Step backwards until we find the required macro\n        while (currIndex >= 0 && !isRelevantMacro(nodes[currIndex])) {\n            currIndex--;\n        }\n    }\n\n    // Search for an occurrence of any of the macros `macroName` and its arguments.\n    // Some macros are right-associative, so we should start searching from\n    // the right\n    currIndex = nodes.length - 1;\n    while (currIndex >= 0) {\n        gobbleUntilMacro();\n        if (currIndex < 0) {\n            // We didn't find an occurrence of the macro\n            return;\n        }\n\n        // Store the currIndex, which is where the macro is. Start searching\n        // for its arguments at the next index.\n        const macroIndex = currIndex;\n        const macro = nodes[macroIndex] as Ast.Macro;\n        const macroName = macro.content;\n        const macroInfo = macros[macroName];\n\n        // Add `._renderInfo` if we have any\n        updateRenderInfo(macro, macroInfo.renderInfo);\n\n        const signatureOrParser =\n            macroInfo.argumentParser || macroInfo.signature;\n\n        // If the macro has no signature, it shouldn't consume any arguments. Just move along.\n        // Note: It is important that this happens *after* `updateRenderInfo` is called, since\n        // we still want to update the render info even if there are no args.\n        if (signatureOrParser == null) {\n            currIndex--;\n            continue;\n        }\n\n        // We don't want to search for macro arguments if we already\n        // found them. If the macro has arguments, we assume that\n        // they've already been attached\n        if (macro.args != null) {\n            currIndex = macroIndex - 1;\n            continue;\n        }\n\n        // `currIndex` is the position of the macro. We want to start\n        // looking for the arguments right after the macro\n        currIndex++;\n        const { args } = gobbleArguments(nodes, signatureOrParser, currIndex);\n        macro.args = args;\n        // After we've gobbled the arguments, set\n        // ourselves one space before the macro so we can continue.\n        currIndex = macroIndex - 1;\n    }\n}\n\n/**\n * Recursively search for and attach the arguments for a\n * particular macro to its AST node. `macros` should\n * contain a `signature` property which specifies the arguments\n * signature in xparse syntax.\n */\nexport function attachMacroArgs(tree: Ast.Ast, macros: MacroInfoRecord) {\n    visit(\n        tree,\n        (nodes) => {\n            attachMacroArgsInArray(nodes, macros);\n        },\n        { includeArrays: true, test: Array.isArray }\n    );\n}\n","import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { MacroInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { attachMacroArgsInArray } from \"./attach-arguments\";\n\ntype PluginOptions = { macros: MacroInfoRecord } | undefined;\n\n/**\n * Unified plugin to attach macro arguments to the macros specified via the `macros`\n * option.\n *\n * @param macros An object whose keys are macro names and values contains information about the macro and its argument signature.\n */\nexport const unifiedLatexAttachMacroArguments: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexAttachMacroArguments(options) {\n    return (tree) => {\n        const { macros = {} } = options || {};\n        if (Object.keys(macros).length === 0) {\n            console.warn(\n                \"Attempting to attach macro arguments but no macros are specified.\"\n            );\n        }\n        visit(\n            tree,\n            (nodes) => {\n                attachMacroArgsInArray(nodes, macros);\n            },\n            { includeArrays: true, test: Array.isArray }\n        );\n    };\n};\n","import * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Returns the content of `args` for a macro or environment as an array. If an argument\n * was omitted (e.g., because it was an optional arg that wasn't included), then `null` is returned.\n */\nexport function getArgsContent(\n    node: Ast.Macro | Ast.Environment\n): (Ast.Node[] | null)[] {\n    if (!Array.isArray(node.args)) {\n        return [];\n    }\n\n    return node.args.map((arg) => {\n        if (arg.openMark === \"\" && arg.content.length === 0) {\n            return null;\n        }\n        return arg.content;\n    });\n}\n\n/**\n * Returns the content of `args` for a macro or environment as an object whose keys are the \"names\"\n * of each argument. These names of the arguments must be specified in the `_renderInfo` prop. If `_renderInfo`\n * does not contain a `namedArguments` array, then an empty object will be returned.\n *\n * @namedArgumentsFallback - If `_renderInfo.namedArguments` is not provided, `namedArgumentsFallback` is ued.\n */\nexport function getNamedArgsContent(\n    node: Ast.Macro | Ast.Environment,\n    namedArgumentsFallback: readonly (string | null)[] = []\n): Record<string, Ast.Node[] | null> {\n    const names = node._renderInfo?.namedArguments || namedArgumentsFallback;\n\n    if (\n        !Array.isArray(node.args) ||\n        !Array.isArray(names) ||\n        names.length === 0\n    ) {\n        return {};\n    }\n    const ret: Record<string, Ast.Node[] | null> = {};\n\n    node.args.forEach((arg, i) => {\n        const name = names[i];\n        if (name == null) {\n            // If a null name was given, it shouldn't be listed as a named argument.\n            return;\n        }\n        let val: Ast.Node[] | null = arg.content;\n        if (arg.openMark === \"\" && arg.content.length === 0) {\n            val = null;\n        }\n        ret[name] = val;\n    });\n\n    return ret;\n}\n"],"names":["bracePos","nodeContent","parseArgspec","unifiedLatexAttachMacroArguments","arg"],"mappings":"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"}