{
  "version": 3,
  "sources": ["../node_modules/prettier/doc.mjs", "../libs/printer/common.ts", "../libs/zip.ts", "../libs/printer/macro.ts", "../libs/printer/argument.ts", "../libs/printer/tikz.ts", "../libs/printer/print-argument-pgfkeys.ts", "../libs/printer/root.ts", "../libs/printer/comment.ts", "../libs/printer/math.ts", "../libs/printer/environment.ts", "../libs/printer/printer.ts", "../libs/reference-map.ts", "../libs/prettier-plugin-latex.ts"],
  "sourcesContent": ["var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/document/public.js\nvar public_exports = {};\n__export(public_exports, {\n  builders: () => builders,\n  printer: () => printer,\n  utils: () => utils\n});\n\n// src/document/constants.js\nvar DOC_TYPE_STRING = \"string\";\nvar DOC_TYPE_ARRAY = \"array\";\nvar DOC_TYPE_CURSOR = \"cursor\";\nvar DOC_TYPE_INDENT = \"indent\";\nvar DOC_TYPE_ALIGN = \"align\";\nvar DOC_TYPE_TRIM = \"trim\";\nvar DOC_TYPE_GROUP = \"group\";\nvar DOC_TYPE_FILL = \"fill\";\nvar DOC_TYPE_IF_BREAK = \"if-break\";\nvar DOC_TYPE_INDENT_IF_BREAK = \"indent-if-break\";\nvar DOC_TYPE_LINE_SUFFIX = \"line-suffix\";\nvar DOC_TYPE_LINE_SUFFIX_BOUNDARY = \"line-suffix-boundary\";\nvar DOC_TYPE_LINE = \"line\";\nvar DOC_TYPE_LABEL = \"label\";\nvar DOC_TYPE_BREAK_PARENT = \"break-parent\";\nvar VALID_OBJECT_DOC_TYPES = /* @__PURE__ */ new Set([\n  DOC_TYPE_CURSOR,\n  DOC_TYPE_INDENT,\n  DOC_TYPE_ALIGN,\n  DOC_TYPE_TRIM,\n  DOC_TYPE_GROUP,\n  DOC_TYPE_FILL,\n  DOC_TYPE_IF_BREAK,\n  DOC_TYPE_INDENT_IF_BREAK,\n  DOC_TYPE_LINE_SUFFIX,\n  DOC_TYPE_LINE_SUFFIX_BOUNDARY,\n  DOC_TYPE_LINE,\n  DOC_TYPE_LABEL,\n  DOC_TYPE_BREAK_PARENT\n]);\n\n// src/document/utils/get-doc-type.js\nfunction getDocType(doc) {\n  if (typeof doc === \"string\") {\n    return DOC_TYPE_STRING;\n  }\n  if (Array.isArray(doc)) {\n    return DOC_TYPE_ARRAY;\n  }\n  if (!doc) {\n    return;\n  }\n  const { type } = doc;\n  if (VALID_OBJECT_DOC_TYPES.has(type)) {\n    return type;\n  }\n}\nvar get_doc_type_default = getDocType;\n\n// src/document/invalid-doc-error.js\nvar disjunctionListFormat = (list) => new Intl.ListFormat(\"en-US\", { type: \"disjunction\" }).format(list);\nfunction getDocErrorMessage(doc) {\n  const type = doc === null ? \"null\" : typeof doc;\n  if (type !== \"string\" && type !== \"object\") {\n    return `Unexpected doc '${type}', \nExpected it to be 'string' or 'object'.`;\n  }\n  if (get_doc_type_default(doc)) {\n    throw new Error(\"doc is valid.\");\n  }\n  const objectType = Object.prototype.toString.call(doc);\n  if (objectType !== \"[object Object]\") {\n    return `Unexpected doc '${objectType}'.`;\n  }\n  const EXPECTED_TYPE_VALUES = disjunctionListFormat(\n    [...VALID_OBJECT_DOC_TYPES].map((type2) => `'${type2}'`)\n  );\n  return `Unexpected doc.type '${doc.type}'.\nExpected it to be ${EXPECTED_TYPE_VALUES}.`;\n}\nvar InvalidDocError = class extends Error {\n  name = \"InvalidDocError\";\n  constructor(doc) {\n    super(getDocErrorMessage(doc));\n    this.doc = doc;\n  }\n};\nvar invalid_doc_error_default = InvalidDocError;\n\n// src/document/utils/traverse-doc.js\nvar traverseDocOnExitStackMarker = {};\nfunction traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {\n  const docsStack = [doc];\n  while (docsStack.length > 0) {\n    const doc2 = docsStack.pop();\n    if (doc2 === traverseDocOnExitStackMarker) {\n      onExit(docsStack.pop());\n      continue;\n    }\n    if (onExit) {\n      docsStack.push(doc2, traverseDocOnExitStackMarker);\n    }\n    const docType = get_doc_type_default(doc2);\n    if (!docType) {\n      throw new invalid_doc_error_default(doc2);\n    }\n    if ((onEnter == null ? void 0 : onEnter(doc2)) === false) {\n      continue;\n    }\n    switch (docType) {\n      case DOC_TYPE_ARRAY:\n      case DOC_TYPE_FILL: {\n        const parts = docType === DOC_TYPE_ARRAY ? doc2 : doc2.parts;\n        for (let ic = parts.length, i = ic - 1; i >= 0; --i) {\n          docsStack.push(parts[i]);\n        }\n        break;\n      }\n      case DOC_TYPE_IF_BREAK:\n        docsStack.push(doc2.flatContents, doc2.breakContents);\n        break;\n      case DOC_TYPE_GROUP:\n        if (shouldTraverseConditionalGroups && doc2.expandedStates) {\n          for (let ic = doc2.expandedStates.length, i = ic - 1; i >= 0; --i) {\n            docsStack.push(doc2.expandedStates[i]);\n          }\n        } else {\n          docsStack.push(doc2.contents);\n        }\n        break;\n      case DOC_TYPE_ALIGN:\n      case DOC_TYPE_INDENT:\n      case DOC_TYPE_INDENT_IF_BREAK:\n      case DOC_TYPE_LABEL:\n      case DOC_TYPE_LINE_SUFFIX:\n        docsStack.push(doc2.contents);\n        break;\n      case DOC_TYPE_STRING:\n      case DOC_TYPE_CURSOR:\n      case DOC_TYPE_TRIM:\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n      case DOC_TYPE_LINE:\n      case DOC_TYPE_BREAK_PARENT:\n        break;\n      default:\n        throw new invalid_doc_error_default(doc2);\n    }\n  }\n}\nvar traverse_doc_default = traverseDoc;\n\n// src/document/utils/assert-doc.js\nvar noop = () => {\n};\nvar assertDoc = true ? noop : function(doc) {\n  traverse_doc_default(doc, (doc2) => {\n    if (checked.has(doc2)) {\n      return false;\n    }\n    if (typeof doc2 !== \"string\") {\n      checked.add(doc2);\n    }\n  });\n};\nvar assertDocArray = true ? noop : function(docs, optional = false) {\n  if (optional && !docs) {\n    return;\n  }\n  if (!Array.isArray(docs)) {\n    throw new TypeError(\"Unexpected doc array.\");\n  }\n  for (const doc of docs) {\n    assertDoc(doc);\n  }\n};\n\n// src/document/builders.js\nfunction indent(contents) {\n  assertDoc(contents);\n  return { type: DOC_TYPE_INDENT, contents };\n}\nfunction align(widthOrString, contents) {\n  assertDoc(contents);\n  return { type: DOC_TYPE_ALIGN, contents, n: widthOrString };\n}\nfunction group(contents, opts = {}) {\n  assertDoc(contents);\n  assertDocArray(\n    opts.expandedStates,\n    /* optional */\n    true\n  );\n  return {\n    type: DOC_TYPE_GROUP,\n    id: opts.id,\n    contents,\n    break: Boolean(opts.shouldBreak),\n    expandedStates: opts.expandedStates\n  };\n}\nfunction dedentToRoot(contents) {\n  return align(Number.NEGATIVE_INFINITY, contents);\n}\nfunction markAsRoot(contents) {\n  return align({ type: \"root\" }, contents);\n}\nfunction dedent(contents) {\n  return align(-1, contents);\n}\nfunction conditionalGroup(states, opts) {\n  return group(states[0], { ...opts, expandedStates: states });\n}\nfunction fill(parts) {\n  assertDocArray(parts);\n  return { type: DOC_TYPE_FILL, parts };\n}\nfunction ifBreak(breakContents, flatContents = \"\", opts = {}) {\n  assertDoc(breakContents);\n  if (flatContents !== \"\") {\n    assertDoc(flatContents);\n  }\n  return {\n    type: DOC_TYPE_IF_BREAK,\n    breakContents,\n    flatContents,\n    groupId: opts.groupId\n  };\n}\nfunction indentIfBreak(contents, opts) {\n  assertDoc(contents);\n  return {\n    type: DOC_TYPE_INDENT_IF_BREAK,\n    contents,\n    groupId: opts.groupId,\n    negate: opts.negate\n  };\n}\nfunction lineSuffix(contents) {\n  assertDoc(contents);\n  return { type: DOC_TYPE_LINE_SUFFIX, contents };\n}\nvar lineSuffixBoundary = { type: DOC_TYPE_LINE_SUFFIX_BOUNDARY };\nvar breakParent = { type: DOC_TYPE_BREAK_PARENT };\nvar trim = { type: DOC_TYPE_TRIM };\nvar hardlineWithoutBreakParent = { type: DOC_TYPE_LINE, hard: true };\nvar literallineWithoutBreakParent = {\n  type: DOC_TYPE_LINE,\n  hard: true,\n  literal: true\n};\nvar line = { type: DOC_TYPE_LINE };\nvar softline = { type: DOC_TYPE_LINE, soft: true };\nvar hardline = [hardlineWithoutBreakParent, breakParent];\nvar literalline = [literallineWithoutBreakParent, breakParent];\nvar cursor = { type: DOC_TYPE_CURSOR };\nfunction join(separator, docs) {\n  assertDoc(separator);\n  assertDocArray(docs);\n  const parts = [];\n  for (let i = 0; i < docs.length; i++) {\n    if (i !== 0) {\n      parts.push(separator);\n    }\n    parts.push(docs[i]);\n  }\n  return parts;\n}\nfunction addAlignmentToDoc(doc, size, tabWidth) {\n  assertDoc(doc);\n  let aligned = doc;\n  if (size > 0) {\n    for (let i = 0; i < Math.floor(size / tabWidth); ++i) {\n      aligned = indent(aligned);\n    }\n    aligned = align(size % tabWidth, aligned);\n    aligned = align(Number.NEGATIVE_INFINITY, aligned);\n  }\n  return aligned;\n}\nfunction label(label2, contents) {\n  assertDoc(contents);\n  return label2 ? { type: DOC_TYPE_LABEL, label: label2, contents } : contents;\n}\n\n// scripts/build/shims/at.js\nvar at = (isOptionalObject, object, index) => {\n  if (isOptionalObject && (object === void 0 || object === null)) {\n    return;\n  }\n  if (Array.isArray(object) || typeof object === \"string\") {\n    return object[index < 0 ? object.length + index : index];\n  }\n  return object.at(index);\n};\nvar at_default = at;\n\n// scripts/build/shims/string-replace-all.js\nvar stringReplaceAll = (isOptionalObject, original, pattern, replacement) => {\n  if (isOptionalObject && (original === void 0 || original === null)) {\n    return;\n  }\n  if (original.replaceAll) {\n    return original.replaceAll(pattern, replacement);\n  }\n  if (pattern.global) {\n    return original.replace(pattern, replacement);\n  }\n  return original.split(pattern).join(replacement);\n};\nvar string_replace_all_default = stringReplaceAll;\n\n// src/common/end-of-line.js\nfunction convertEndOfLineToChars(value) {\n  switch (value) {\n    case \"cr\":\n      return \"\\r\";\n    case \"crlf\":\n      return \"\\r\\n\";\n    default:\n      return \"\\n\";\n  }\n}\n\n// node_modules/emoji-regex/index.mjs\nvar emoji_regex_default = () => {\n  return /[#*0-9]\\uFE0F?\\u20E3|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26AA\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C8\\u26CF\\u26D1\\u26D3\\u26E9\\u26F0-\\u26F5\\u26F7\\u26F8\\u26FA\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2757\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B55\\u3030\\u303D\\u3297\\u3299]\\uFE0F?|[\\u261D\\u270C\\u270D](?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?|[\\u270A\\u270B](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u2693\\u26A1\\u26AB\\u26C5\\u26CE\\u26D4\\u26EA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2795-\\u2797\\u27B0\\u27BF\\u2B50]|\\u26F9(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\u2764\\uFE0F?(?:\\u200D(?:\\uD83D\\uDD25|\\uD83E\\uDE79))?|\\uD83C(?:[\\uDC04\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDE02\\uDE37\\uDF21\\uDF24-\\uDF2C\\uDF36\\uDF7D\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E\\uDF9F\\uDFCD\\uDFCE\\uDFD4-\\uDFDF\\uDFF5\\uDFF7]\\uFE0F?|[\\uDF85\\uDFC2\\uDFC7](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDFC3\\uDFC4\\uDFCA](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDFCB\\uDFCC](?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF84\\uDF86-\\uDF93\\uDFA0-\\uDFC1\\uDFC5\\uDFC6\\uDFC8\\uDFC9\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF8-\\uDFFF]|\\uDDE6\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF]|\\uDDE7\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF]|\\uDDE8\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF]|\\uDDE9\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF]|\\uDDEA\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA]|\\uDDEB\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7]|\\uDDEC\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE]|\\uDDED\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA]|\\uDDEE\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9]|\\uDDEF\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5]|\\uDDF0\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF]|\\uDDF1\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE]|\\uDDF2\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF]|\\uDDF3\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF]|\\uDDF4\\uD83C\\uDDF2|\\uDDF5\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE]|\\uDDF6\\uD83C\\uDDE6|\\uDDF7\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC]|\\uDDF8\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF]|\\uDDF9\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF]|\\uDDFA\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF]|\\uDDFB\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA]|\\uDDFC\\uD83C[\\uDDEB\\uDDF8]|\\uDDFD\\uD83C\\uDDF0|\\uDDFE\\uD83C[\\uDDEA\\uDDF9]|\\uDDFF\\uD83C[\\uDDE6\\uDDF2\\uDDFC]|\\uDFF3\\uFE0F?(?:\\u200D(?:\\u26A7\\uFE0F?|\\uD83C\\uDF08))?|\\uDFF4(?:\\u200D\\u2620\\uFE0F?|\\uDB40\\uDC67\\uDB40\\uDC62\\uDB40(?:\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73)\\uDB40\\uDC7F)?)|\\uD83D(?:[\\uDC08\\uDC26](?:\\u200D\\u2B1B)?|[\\uDC3F\\uDCFD\\uDD49\\uDD4A\\uDD6F\\uDD70\\uDD73\\uDD76-\\uDD79\\uDD87\\uDD8A-\\uDD8D\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA\\uDECB\\uDECD-\\uDECF\\uDEE0-\\uDEE5\\uDEE9\\uDEF0\\uDEF3]\\uFE0F?|[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDD74\\uDD90](?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDC00-\\uDC07\\uDC09-\\uDC14\\uDC16-\\uDC25\\uDC27-\\uDC3A\\uDC3C-\\uDC3E\\uDC40\\uDC44\\uDC45\\uDC51-\\uDC65\\uDC6A\\uDC79-\\uDC7B\\uDC7D-\\uDC80\\uDC84\\uDC88-\\uDC8E\\uDC90\\uDC92-\\uDCA9\\uDCAB-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDDA4\\uDDFB-\\uDE2D\\uDE2F-\\uDE34\\uDE37-\\uDE44\\uDE48-\\uDE4A\\uDE80-\\uDEA2\\uDEA4-\\uDEB3\\uDEB7-\\uDEBF\\uDEC1-\\uDEC5\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEDC-\\uDEDF\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB\\uDFF0]|\\uDC15(?:\\u200D\\uD83E\\uDDBA)?|\\uDC3B(?:\\u200D\\u2744\\uFE0F?)?|\\uDC41\\uFE0F?(?:\\u200D\\uD83D\\uDDE8\\uFE0F?)?|\\uDC68(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDC68\\uDC69]\\u200D\\uD83D(?:\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?)|[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?)|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFC-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB-\\uDFFE])))?))?|\\uDC69(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?[\\uDC68\\uDC69]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?|\\uDC69\\u200D\\uD83D(?:\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?))|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFC-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB-\\uDFFE])))?))?|\\uDC6F(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\uDD75(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\uDE2E(?:\\u200D\\uD83D\\uDCA8)?|\\uDE35(?:\\u200D\\uD83D\\uDCAB)?|\\uDE36(?:\\u200D\\uD83C\\uDF2B\\uFE0F?)?)|\\uD83E(?:[\\uDD0C\\uDD0F\\uDD18-\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5\\uDEC3-\\uDEC5\\uDEF0\\uDEF2-\\uDEF8](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDDDE\\uDDDF](?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDD0D\\uDD0E\\uDD10-\\uDD17\\uDD20-\\uDD25\\uDD27-\\uDD2F\\uDD3A\\uDD3F-\\uDD45\\uDD47-\\uDD76\\uDD78-\\uDDB4\\uDDB7\\uDDBA\\uDDBC-\\uDDCC\\uDDD0\\uDDE0-\\uDDFF\\uDE70-\\uDE7C\\uDE80-\\uDE88\\uDE90-\\uDEBD\\uDEBF-\\uDEC2\\uDECE-\\uDEDB\\uDEE0-\\uDEE8]|\\uDD3C(?:\\u200D[\\u2640\\u2642]\\uFE0F?|\\uD83C[\\uDFFB-\\uDFFF])?|\\uDDD1(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83E\\uDDD1))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFC-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFD-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFD\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFE]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?))?|\\uDEF1(?:\\uD83C(?:\\uDFFB(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFC-\\uDFFF])?|\\uDFFC(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])?|\\uDFFD(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])?|\\uDFFE(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])?|\\uDFFF(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB-\\uDFFE])?))?)/g;\n};\n\n// node_modules/eastasianwidth/eastasianwidth.js\nvar eastasianwidth_default = {\n  eastAsianWidth(character) {\n    var x = character.charCodeAt(0);\n    var y = character.length == 2 ? character.charCodeAt(1) : 0;\n    var codePoint = x;\n    if (55296 <= x && x <= 56319 && 56320 <= y && y <= 57343) {\n      x &= 1023;\n      y &= 1023;\n      codePoint = x << 10 | y;\n      codePoint += 65536;\n    }\n    if (12288 == codePoint || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510) {\n      return \"F\";\n    }\n    if (4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141) {\n      return \"W\";\n    }\n    return \"N\";\n  }\n};\n\n// src/utils/get-string-width.js\nvar notAsciiRegex = /[^\\x20-\\x7F]/;\nfunction getStringWidth(text) {\n  if (!text) {\n    return 0;\n  }\n  if (!notAsciiRegex.test(text)) {\n    return text.length;\n  }\n  text = text.replace(emoji_regex_default(), \"  \");\n  let width = 0;\n  for (const character of text) {\n    const codePoint = character.codePointAt(0);\n    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {\n      continue;\n    }\n    if (codePoint >= 768 && codePoint <= 879) {\n      continue;\n    }\n    const code = eastasianwidth_default.eastAsianWidth(character);\n    width += code === \"F\" || code === \"W\" ? 2 : 1;\n  }\n  return width;\n}\nvar get_string_width_default = getStringWidth;\n\n// src/document/utils.js\nvar getDocParts = (doc) => {\n  if (Array.isArray(doc)) {\n    return doc;\n  }\n  if (doc.type !== DOC_TYPE_FILL) {\n    throw new Error(`Expect doc to be 'array' or '${DOC_TYPE_FILL}'.`);\n  }\n  return doc.parts;\n};\nfunction mapDoc(doc, cb) {\n  if (typeof doc === \"string\") {\n    return cb(doc);\n  }\n  const mapped = /* @__PURE__ */ new Map();\n  return rec(doc);\n  function rec(doc2) {\n    if (mapped.has(doc2)) {\n      return mapped.get(doc2);\n    }\n    const result = process2(doc2);\n    mapped.set(doc2, result);\n    return result;\n  }\n  function process2(doc2) {\n    switch (get_doc_type_default(doc2)) {\n      case DOC_TYPE_ARRAY:\n        return cb(doc2.map(rec));\n      case DOC_TYPE_FILL:\n        return cb({\n          ...doc2,\n          parts: doc2.parts.map(rec)\n        });\n      case DOC_TYPE_IF_BREAK:\n        return cb({\n          ...doc2,\n          breakContents: rec(doc2.breakContents),\n          flatContents: rec(doc2.flatContents)\n        });\n      case DOC_TYPE_GROUP: {\n        let {\n          expandedStates,\n          contents\n        } = doc2;\n        if (expandedStates) {\n          expandedStates = expandedStates.map(rec);\n          contents = expandedStates[0];\n        } else {\n          contents = rec(contents);\n        }\n        return cb({\n          ...doc2,\n          contents,\n          expandedStates\n        });\n      }\n      case DOC_TYPE_ALIGN:\n      case DOC_TYPE_INDENT:\n      case DOC_TYPE_INDENT_IF_BREAK:\n      case DOC_TYPE_LABEL:\n      case DOC_TYPE_LINE_SUFFIX:\n        return cb({\n          ...doc2,\n          contents: rec(doc2.contents)\n        });\n      case DOC_TYPE_STRING:\n      case DOC_TYPE_CURSOR:\n      case DOC_TYPE_TRIM:\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n      case DOC_TYPE_LINE:\n      case DOC_TYPE_BREAK_PARENT:\n        return cb(doc2);\n      default:\n        throw new invalid_doc_error_default(doc2);\n    }\n  }\n}\nfunction findInDoc(doc, fn, defaultValue) {\n  let result = defaultValue;\n  let shouldSkipFurtherProcessing = false;\n  function findInDocOnEnterFn(doc2) {\n    if (shouldSkipFurtherProcessing) {\n      return false;\n    }\n    const maybeResult = fn(doc2);\n    if (maybeResult !== void 0) {\n      shouldSkipFurtherProcessing = true;\n      result = maybeResult;\n    }\n  }\n  traverse_doc_default(doc, findInDocOnEnterFn);\n  return result;\n}\nfunction willBreakFn(doc) {\n  if (doc.type === DOC_TYPE_GROUP && doc.break) {\n    return true;\n  }\n  if (doc.type === DOC_TYPE_LINE && doc.hard) {\n    return true;\n  }\n  if (doc.type === DOC_TYPE_BREAK_PARENT) {\n    return true;\n  }\n}\nfunction willBreak(doc) {\n  return findInDoc(doc, willBreakFn, false);\n}\nfunction breakParentGroup(groupStack) {\n  if (groupStack.length > 0) {\n    const parentGroup = at_default(\n      /* isOptionalObject*/\n      false,\n      groupStack,\n      -1\n    );\n    if (!parentGroup.expandedStates && !parentGroup.break) {\n      parentGroup.break = \"propagated\";\n    }\n  }\n  return null;\n}\nfunction propagateBreaks(doc) {\n  const alreadyVisitedSet = /* @__PURE__ */ new Set();\n  const groupStack = [];\n  function propagateBreaksOnEnterFn(doc2) {\n    if (doc2.type === DOC_TYPE_BREAK_PARENT) {\n      breakParentGroup(groupStack);\n    }\n    if (doc2.type === DOC_TYPE_GROUP) {\n      groupStack.push(doc2);\n      if (alreadyVisitedSet.has(doc2)) {\n        return false;\n      }\n      alreadyVisitedSet.add(doc2);\n    }\n  }\n  function propagateBreaksOnExitFn(doc2) {\n    if (doc2.type === DOC_TYPE_GROUP) {\n      const group2 = groupStack.pop();\n      if (group2.break) {\n        breakParentGroup(groupStack);\n      }\n    }\n  }\n  traverse_doc_default(\n    doc,\n    propagateBreaksOnEnterFn,\n    propagateBreaksOnExitFn,\n    /* shouldTraverseConditionalGroups */\n    true\n  );\n}\nfunction removeLinesFn(doc) {\n  if (doc.type === DOC_TYPE_LINE && !doc.hard) {\n    return doc.soft ? \"\" : \" \";\n  }\n  if (doc.type === DOC_TYPE_IF_BREAK) {\n    return doc.flatContents;\n  }\n  return doc;\n}\nfunction removeLines(doc) {\n  return mapDoc(doc, removeLinesFn);\n}\nfunction stripTrailingHardlineFromParts(parts) {\n  parts = [...parts];\n  while (parts.length >= 2 && at_default(\n    /* isOptionalObject*/\n    false,\n    parts,\n    -2\n  ).type === DOC_TYPE_LINE && at_default(\n    /* isOptionalObject*/\n    false,\n    parts,\n    -1\n  ).type === DOC_TYPE_BREAK_PARENT) {\n    parts.length -= 2;\n  }\n  if (parts.length > 0) {\n    const lastPart = stripTrailingHardlineFromDoc(at_default(\n      /* isOptionalObject*/\n      false,\n      parts,\n      -1\n    ));\n    parts[parts.length - 1] = lastPart;\n  }\n  return parts;\n}\nfunction stripTrailingHardlineFromDoc(doc) {\n  switch (get_doc_type_default(doc)) {\n    case DOC_TYPE_ALIGN:\n    case DOC_TYPE_INDENT:\n    case DOC_TYPE_INDENT_IF_BREAK:\n    case DOC_TYPE_GROUP:\n    case DOC_TYPE_LINE_SUFFIX:\n    case DOC_TYPE_LABEL: {\n      const contents = stripTrailingHardlineFromDoc(doc.contents);\n      return {\n        ...doc,\n        contents\n      };\n    }\n    case DOC_TYPE_IF_BREAK:\n      return {\n        ...doc,\n        breakContents: stripTrailingHardlineFromDoc(doc.breakContents),\n        flatContents: stripTrailingHardlineFromDoc(doc.flatContents)\n      };\n    case DOC_TYPE_FILL:\n      return {\n        ...doc,\n        parts: stripTrailingHardlineFromParts(doc.parts)\n      };\n    case DOC_TYPE_ARRAY:\n      return stripTrailingHardlineFromParts(doc);\n    case DOC_TYPE_STRING:\n      return doc.replace(/[\\n\\r]*$/, \"\");\n    case DOC_TYPE_CURSOR:\n    case DOC_TYPE_TRIM:\n    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n    case DOC_TYPE_LINE:\n    case DOC_TYPE_BREAK_PARENT:\n      break;\n    default:\n      throw new invalid_doc_error_default(doc);\n  }\n  return doc;\n}\nfunction stripTrailingHardline(doc) {\n  return stripTrailingHardlineFromDoc(cleanDoc(doc));\n}\nfunction cleanDocFn(doc) {\n  switch (get_doc_type_default(doc)) {\n    case DOC_TYPE_FILL:\n      if (doc.parts.every((part) => part === \"\")) {\n        return \"\";\n      }\n      break;\n    case DOC_TYPE_GROUP:\n      if (!doc.contents && !doc.id && !doc.break && !doc.expandedStates) {\n        return \"\";\n      }\n      if (doc.contents.type === DOC_TYPE_GROUP && doc.contents.id === doc.id && doc.contents.break === doc.break && doc.contents.expandedStates === doc.expandedStates) {\n        return doc.contents;\n      }\n      break;\n    case DOC_TYPE_ALIGN:\n    case DOC_TYPE_INDENT:\n    case DOC_TYPE_INDENT_IF_BREAK:\n    case DOC_TYPE_LINE_SUFFIX:\n      if (!doc.contents) {\n        return \"\";\n      }\n      break;\n    case DOC_TYPE_IF_BREAK:\n      if (!doc.flatContents && !doc.breakContents) {\n        return \"\";\n      }\n      break;\n    case DOC_TYPE_ARRAY: {\n      const parts = [];\n      for (const part of doc) {\n        if (!part) {\n          continue;\n        }\n        const [currentPart, ...restParts] = Array.isArray(part) ? part : [part];\n        if (typeof currentPart === \"string\" && typeof at_default(\n          /* isOptionalObject*/\n          false,\n          parts,\n          -1\n        ) === \"string\") {\n          parts[parts.length - 1] += currentPart;\n        } else {\n          parts.push(currentPart);\n        }\n        parts.push(...restParts);\n      }\n      if (parts.length === 0) {\n        return \"\";\n      }\n      if (parts.length === 1) {\n        return parts[0];\n      }\n      return parts;\n    }\n    case DOC_TYPE_STRING:\n    case DOC_TYPE_CURSOR:\n    case DOC_TYPE_TRIM:\n    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n    case DOC_TYPE_LINE:\n    case DOC_TYPE_LABEL:\n    case DOC_TYPE_BREAK_PARENT:\n      break;\n    default:\n      throw new invalid_doc_error_default(doc);\n  }\n  return doc;\n}\nfunction cleanDoc(doc) {\n  return mapDoc(doc, (currentDoc) => cleanDocFn(currentDoc));\n}\nfunction replaceEndOfLine(doc, replacement = literalline) {\n  return mapDoc(doc, (currentDoc) => typeof currentDoc === \"string\" ? join(replacement, currentDoc.split(\"\\n\")) : currentDoc);\n}\nfunction canBreakFn(doc) {\n  if (doc.type === DOC_TYPE_LINE) {\n    return true;\n  }\n}\nfunction canBreak(doc) {\n  return findInDoc(doc, canBreakFn, false);\n}\n\n// src/document/printer.js\nvar MODE_BREAK = Symbol(\"MODE_BREAK\");\nvar MODE_FLAT = Symbol(\"MODE_FLAT\");\nvar CURSOR_PLACEHOLDER = Symbol(\"cursor\");\nfunction rootIndent() {\n  return {\n    value: \"\",\n    length: 0,\n    queue: []\n  };\n}\nfunction makeIndent(ind, options) {\n  return generateInd(ind, {\n    type: \"indent\"\n  }, options);\n}\nfunction makeAlign(indent2, widthOrDoc, options) {\n  if (widthOrDoc === Number.NEGATIVE_INFINITY) {\n    return indent2.root || rootIndent();\n  }\n  if (widthOrDoc < 0) {\n    return generateInd(indent2, {\n      type: \"dedent\"\n    }, options);\n  }\n  if (!widthOrDoc) {\n    return indent2;\n  }\n  if (widthOrDoc.type === \"root\") {\n    return {\n      ...indent2,\n      root: indent2\n    };\n  }\n  const alignType = typeof widthOrDoc === \"string\" ? \"stringAlign\" : \"numberAlign\";\n  return generateInd(indent2, {\n    type: alignType,\n    n: widthOrDoc\n  }, options);\n}\nfunction generateInd(ind, newPart, options) {\n  const queue = newPart.type === \"dedent\" ? ind.queue.slice(0, -1) : [...ind.queue, newPart];\n  let value = \"\";\n  let length = 0;\n  let lastTabs = 0;\n  let lastSpaces = 0;\n  for (const part of queue) {\n    switch (part.type) {\n      case \"indent\":\n        flush();\n        if (options.useTabs) {\n          addTabs(1);\n        } else {\n          addSpaces(options.tabWidth);\n        }\n        break;\n      case \"stringAlign\":\n        flush();\n        value += part.n;\n        length += part.n.length;\n        break;\n      case \"numberAlign\":\n        lastTabs += 1;\n        lastSpaces += part.n;\n        break;\n      default:\n        throw new Error(`Unexpected type '${part.type}'`);\n    }\n  }\n  flushSpaces();\n  return {\n    ...ind,\n    value,\n    length,\n    queue\n  };\n  function addTabs(count) {\n    value += \"\t\".repeat(count);\n    length += options.tabWidth * count;\n  }\n  function addSpaces(count) {\n    value += \" \".repeat(count);\n    length += count;\n  }\n  function flush() {\n    if (options.useTabs) {\n      flushTabs();\n    } else {\n      flushSpaces();\n    }\n  }\n  function flushTabs() {\n    if (lastTabs > 0) {\n      addTabs(lastTabs);\n    }\n    resetLast();\n  }\n  function flushSpaces() {\n    if (lastSpaces > 0) {\n      addSpaces(lastSpaces);\n    }\n    resetLast();\n  }\n  function resetLast() {\n    lastTabs = 0;\n    lastSpaces = 0;\n  }\n}\nfunction trim2(out) {\n  let trimCount = 0;\n  let cursorCount = 0;\n  let outIndex = out.length;\n  outer:\n    while (outIndex--) {\n      const last = out[outIndex];\n      if (last === CURSOR_PLACEHOLDER) {\n        cursorCount++;\n        continue;\n      }\n      if (false) {\n        throw new Error(`Unexpected value in trim: '${typeof last}'`);\n      }\n      for (let charIndex = last.length - 1; charIndex >= 0; charIndex--) {\n        const char = last[charIndex];\n        if (char === \" \" || char === \"\t\") {\n          trimCount++;\n        } else {\n          out[outIndex] = last.slice(0, charIndex + 1);\n          break outer;\n        }\n      }\n    }\n  if (trimCount > 0 || cursorCount > 0) {\n    out.length = outIndex + 1;\n    while (cursorCount-- > 0) {\n      out.push(CURSOR_PLACEHOLDER);\n    }\n  }\n  return trimCount;\n}\nfunction fits(next, restCommands, width, hasLineSuffix, groupModeMap, mustBeFlat) {\n  if (width === Number.POSITIVE_INFINITY) {\n    return true;\n  }\n  let restIdx = restCommands.length;\n  const cmds = [next];\n  const out = [];\n  while (width >= 0) {\n    if (cmds.length === 0) {\n      if (restIdx === 0) {\n        return true;\n      }\n      cmds.push(restCommands[--restIdx]);\n      continue;\n    }\n    const {\n      mode,\n      doc\n    } = cmds.pop();\n    switch (get_doc_type_default(doc)) {\n      case DOC_TYPE_STRING:\n        out.push(doc);\n        width -= get_string_width_default(doc);\n        break;\n      case DOC_TYPE_ARRAY:\n      case DOC_TYPE_FILL: {\n        const parts = getDocParts(doc);\n        for (let i = parts.length - 1; i >= 0; i--) {\n          cmds.push({\n            mode,\n            doc: parts[i]\n          });\n        }\n        break;\n      }\n      case DOC_TYPE_INDENT:\n      case DOC_TYPE_ALIGN:\n      case DOC_TYPE_INDENT_IF_BREAK:\n      case DOC_TYPE_LABEL:\n        cmds.push({\n          mode,\n          doc: doc.contents\n        });\n        break;\n      case DOC_TYPE_TRIM:\n        width += trim2(out);\n        break;\n      case DOC_TYPE_GROUP: {\n        if (mustBeFlat && doc.break) {\n          return false;\n        }\n        const groupMode = doc.break ? MODE_BREAK : mode;\n        const contents = doc.expandedStates && groupMode === MODE_BREAK ? at_default(\n          /* isOptionalObject*/\n          false,\n          doc.expandedStates,\n          -1\n        ) : doc.contents;\n        cmds.push({\n          mode: groupMode,\n          doc: contents\n        });\n        break;\n      }\n      case DOC_TYPE_IF_BREAK: {\n        const groupMode = doc.groupId ? groupModeMap[doc.groupId] || MODE_FLAT : mode;\n        const contents = groupMode === MODE_BREAK ? doc.breakContents : doc.flatContents;\n        if (contents) {\n          cmds.push({\n            mode,\n            doc: contents\n          });\n        }\n        break;\n      }\n      case DOC_TYPE_LINE:\n        if (mode === MODE_BREAK || doc.hard) {\n          return true;\n        }\n        if (!doc.soft) {\n          out.push(\" \");\n          width--;\n        }\n        break;\n      case DOC_TYPE_LINE_SUFFIX:\n        hasLineSuffix = true;\n        break;\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n        if (hasLineSuffix) {\n          return false;\n        }\n        break;\n    }\n  }\n  return false;\n}\nfunction printDocToString(doc, options) {\n  const groupModeMap = {};\n  const width = options.printWidth;\n  const newLine = convertEndOfLineToChars(options.endOfLine);\n  let pos = 0;\n  const cmds = [{\n    ind: rootIndent(),\n    mode: MODE_BREAK,\n    doc\n  }];\n  const out = [];\n  let shouldRemeasure = false;\n  const lineSuffix2 = [];\n  let printedCursorCount = 0;\n  propagateBreaks(doc);\n  while (cmds.length > 0) {\n    const {\n      ind,\n      mode,\n      doc: doc2\n    } = cmds.pop();\n    switch (get_doc_type_default(doc2)) {\n      case DOC_TYPE_STRING: {\n        const formatted = newLine !== \"\\n\" ? string_replace_all_default(\n          /* isOptionalObject*/\n          false,\n          doc2,\n          \"\\n\",\n          newLine\n        ) : doc2;\n        out.push(formatted);\n        if (cmds.length > 0) {\n          pos += get_string_width_default(formatted);\n        }\n        break;\n      }\n      case DOC_TYPE_ARRAY:\n        for (let i = doc2.length - 1; i >= 0; i--) {\n          cmds.push({\n            ind,\n            mode,\n            doc: doc2[i]\n          });\n        }\n        break;\n      case DOC_TYPE_CURSOR:\n        if (printedCursorCount >= 2) {\n          throw new Error(\"There are too many 'cursor' in doc.\");\n        }\n        out.push(CURSOR_PLACEHOLDER);\n        printedCursorCount++;\n        break;\n      case DOC_TYPE_INDENT:\n        cmds.push({\n          ind: makeIndent(ind, options),\n          mode,\n          doc: doc2.contents\n        });\n        break;\n      case DOC_TYPE_ALIGN:\n        cmds.push({\n          ind: makeAlign(ind, doc2.n, options),\n          mode,\n          doc: doc2.contents\n        });\n        break;\n      case DOC_TYPE_TRIM:\n        pos -= trim2(out);\n        break;\n      case DOC_TYPE_GROUP:\n        switch (mode) {\n          case MODE_FLAT:\n            if (!shouldRemeasure) {\n              cmds.push({\n                ind,\n                mode: doc2.break ? MODE_BREAK : MODE_FLAT,\n                doc: doc2.contents\n              });\n              break;\n            }\n          case MODE_BREAK: {\n            shouldRemeasure = false;\n            const next = {\n              ind,\n              mode: MODE_FLAT,\n              doc: doc2.contents\n            };\n            const rem = width - pos;\n            const hasLineSuffix = lineSuffix2.length > 0;\n            if (!doc2.break && fits(next, cmds, rem, hasLineSuffix, groupModeMap)) {\n              cmds.push(next);\n            } else {\n              if (doc2.expandedStates) {\n                const mostExpanded = at_default(\n                  /* isOptionalObject*/\n                  false,\n                  doc2.expandedStates,\n                  -1\n                );\n                if (doc2.break) {\n                  cmds.push({\n                    ind,\n                    mode: MODE_BREAK,\n                    doc: mostExpanded\n                  });\n                  break;\n                } else {\n                  for (let i = 1; i < doc2.expandedStates.length + 1; i++) {\n                    if (i >= doc2.expandedStates.length) {\n                      cmds.push({\n                        ind,\n                        mode: MODE_BREAK,\n                        doc: mostExpanded\n                      });\n                      break;\n                    } else {\n                      const state = doc2.expandedStates[i];\n                      const cmd = {\n                        ind,\n                        mode: MODE_FLAT,\n                        doc: state\n                      };\n                      if (fits(cmd, cmds, rem, hasLineSuffix, groupModeMap)) {\n                        cmds.push(cmd);\n                        break;\n                      }\n                    }\n                  }\n                }\n              } else {\n                cmds.push({\n                  ind,\n                  mode: MODE_BREAK,\n                  doc: doc2.contents\n                });\n              }\n            }\n            break;\n          }\n        }\n        if (doc2.id) {\n          groupModeMap[doc2.id] = at_default(\n            /* isOptionalObject*/\n            false,\n            cmds,\n            -1\n          ).mode;\n        }\n        break;\n      case DOC_TYPE_FILL: {\n        const rem = width - pos;\n        const {\n          parts\n        } = doc2;\n        if (parts.length === 0) {\n          break;\n        }\n        const [content, whitespace] = parts;\n        const contentFlatCmd = {\n          ind,\n          mode: MODE_FLAT,\n          doc: content\n        };\n        const contentBreakCmd = {\n          ind,\n          mode: MODE_BREAK,\n          doc: content\n        };\n        const contentFits = fits(contentFlatCmd, [], rem, lineSuffix2.length > 0, groupModeMap, true);\n        if (parts.length === 1) {\n          if (contentFits) {\n            cmds.push(contentFlatCmd);\n          } else {\n            cmds.push(contentBreakCmd);\n          }\n          break;\n        }\n        const whitespaceFlatCmd = {\n          ind,\n          mode: MODE_FLAT,\n          doc: whitespace\n        };\n        const whitespaceBreakCmd = {\n          ind,\n          mode: MODE_BREAK,\n          doc: whitespace\n        };\n        if (parts.length === 2) {\n          if (contentFits) {\n            cmds.push(whitespaceFlatCmd, contentFlatCmd);\n          } else {\n            cmds.push(whitespaceBreakCmd, contentBreakCmd);\n          }\n          break;\n        }\n        parts.splice(0, 2);\n        const remainingCmd = {\n          ind,\n          mode,\n          doc: fill(parts)\n        };\n        const secondContent = parts[0];\n        const firstAndSecondContentFlatCmd = {\n          ind,\n          mode: MODE_FLAT,\n          doc: [content, whitespace, secondContent]\n        };\n        const firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], rem, lineSuffix2.length > 0, groupModeMap, true);\n        if (firstAndSecondContentFits) {\n          cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd);\n        } else if (contentFits) {\n          cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd);\n        } else {\n          cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);\n        }\n        break;\n      }\n      case DOC_TYPE_IF_BREAK:\n      case DOC_TYPE_INDENT_IF_BREAK: {\n        const groupMode = doc2.groupId ? groupModeMap[doc2.groupId] : mode;\n        if (groupMode === MODE_BREAK) {\n          const breakContents = doc2.type === DOC_TYPE_IF_BREAK ? doc2.breakContents : doc2.negate ? doc2.contents : indent(doc2.contents);\n          if (breakContents) {\n            cmds.push({\n              ind,\n              mode,\n              doc: breakContents\n            });\n          }\n        }\n        if (groupMode === MODE_FLAT) {\n          const flatContents = doc2.type === DOC_TYPE_IF_BREAK ? doc2.flatContents : doc2.negate ? indent(doc2.contents) : doc2.contents;\n          if (flatContents) {\n            cmds.push({\n              ind,\n              mode,\n              doc: flatContents\n            });\n          }\n        }\n        break;\n      }\n      case DOC_TYPE_LINE_SUFFIX:\n        lineSuffix2.push({\n          ind,\n          mode,\n          doc: doc2.contents\n        });\n        break;\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n        if (lineSuffix2.length > 0) {\n          cmds.push({\n            ind,\n            mode,\n            doc: hardlineWithoutBreakParent\n          });\n        }\n        break;\n      case DOC_TYPE_LINE:\n        switch (mode) {\n          case MODE_FLAT:\n            if (!doc2.hard) {\n              if (!doc2.soft) {\n                out.push(\" \");\n                pos += 1;\n              }\n              break;\n            } else {\n              shouldRemeasure = true;\n            }\n          case MODE_BREAK:\n            if (lineSuffix2.length > 0) {\n              cmds.push({\n                ind,\n                mode,\n                doc: doc2\n              }, ...lineSuffix2.reverse());\n              lineSuffix2.length = 0;\n              break;\n            }\n            if (doc2.literal) {\n              if (ind.root) {\n                out.push(newLine, ind.root.value);\n                pos = ind.root.length;\n              } else {\n                out.push(newLine);\n                pos = 0;\n              }\n            } else {\n              pos -= trim2(out);\n              out.push(newLine + ind.value);\n              pos = ind.length;\n            }\n            break;\n        }\n        break;\n      case DOC_TYPE_LABEL:\n        cmds.push({\n          ind,\n          mode,\n          doc: doc2.contents\n        });\n        break;\n      case DOC_TYPE_BREAK_PARENT:\n        break;\n      default:\n        throw new invalid_doc_error_default(doc2);\n    }\n    if (cmds.length === 0 && lineSuffix2.length > 0) {\n      cmds.push(...lineSuffix2.reverse());\n      lineSuffix2.length = 0;\n    }\n  }\n  const cursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER);\n  if (cursorPlaceholderIndex !== -1) {\n    const otherCursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER, cursorPlaceholderIndex + 1);\n    const beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");\n    const aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join(\"\");\n    const afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");\n    return {\n      formatted: beforeCursor + aroundCursor + afterCursor,\n      cursorNodeStart: beforeCursor.length,\n      cursorNodeText: aroundCursor\n    };\n  }\n  return {\n    formatted: out.join(\"\")\n  };\n}\n\n// src/document/public.js\nvar builders = {\n  join,\n  line,\n  softline,\n  hardline,\n  literalline,\n  group,\n  conditionalGroup,\n  fill,\n  lineSuffix,\n  lineSuffixBoundary,\n  cursor,\n  breakParent,\n  ifBreak,\n  trim,\n  indent,\n  indentIfBreak,\n  align,\n  addAlignmentToDoc,\n  markAsRoot,\n  dedentToRoot,\n  dedent,\n  hardlineWithoutBreakParent,\n  literallineWithoutBreakParent,\n  label,\n  // TODO: Remove this in v4\n  concat: (parts) => parts\n};\nvar printer = { printDocToString };\nvar utils = {\n  willBreak,\n  traverseDoc: traverse_doc_default,\n  findInDoc,\n  mapDoc,\n  removeLines,\n  stripTrailingHardline,\n  replaceEndOfLine,\n  canBreak\n};\n\n// with-default-export:src/document/public.js\nvar public_default = public_exports;\nexport {\n  builders,\n  public_default as default,\n  printer,\n  utils\n};\n", "import { builders } from \"prettier/doc\";\nimport type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { ReferenceMap } from \"../reference-map\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Computes the environment name, start/end, and args.\n * E.g., for \"\\begin{x}abc\\end{x}\", it returns\n * ```\n * {\n *  envName: \"x\",\n *  start: \"\\\\begin{x}\",\n *  end: \"\\\\end{x}\",\n * }\n * ```\n *\n * @param {*} node\n * @returns\n */\nexport function formatEnvSurround(node: Ast.Environment) {\n    const env = printRaw(node.env);\n\n    return {\n        envName: env,\n        start: ESCAPE + \"begin{\" + env + \"}\",\n        end: ESCAPE + \"end{\" + env + \"}\",\n    };\n}\n\n/**\n * Determine if `elm` is a line type (softline/hardline/etc). If `elm` is an\n * array or a concat, the first element is checked.\n */\nfunction isLineType(elm: Doc): boolean {\n    if (elm == null || typeof elm === \"string\") {\n        return false;\n    }\n    if (Array.isArray(elm)) {\n        return isLineType(elm[0]);\n    }\n    // Perhaps we can sneak by with Prettier v2 compatibility?\n    // @ts-ignore\n    if (elm.type === \"concat\") {\n        // @ts-ignore\n        return isLineType(elm.parts);\n    }\n    return elm.type === \"line\";\n}\n\n/**\n * Join an array with `softline`. However, if a `line` is\n * found, do not insert an additional softline. For example\n * `[a, b, c]` -> `[a, softline, b, softline, c]`\n *\n * but\n *\n * `[a, line, b, c]` -> `[a, line, b, softline, c]`\n *\n * @param {*} arr\n * @returns\n */\nexport function joinWithSoftline(arr: Doc[]) {\n    if (arr.length === 0 || arr.length === 1) {\n        return arr;\n    }\n    const ret = [arr[0]];\n    for (let i = 1; i < arr.length; i++) {\n        const prevNode = arr[i - 1];\n        const nextNode = arr[i];\n        if (!isLineType(prevNode) && !isLineType(nextNode)) {\n            ret.push(softline);\n        }\n        ret.push(nextNode);\n    }\n    return ret;\n}\n\nexport function getNodeInfo(\n    node: any,\n    options: PrettierTypes.Options & { referenceMap?: ReferenceMap }\n): {\n    renderInfo: Record<string, any>;\n    renderCache?: object;\n    previousNode?: Ast.Node;\n    nextNode?: Ast.Node;\n    referenceMap?: ReferenceMap;\n} {\n    if (!node) {\n        return { renderInfo: {} };\n    }\n    const renderInfo = node._renderInfo || {};\n    const previousNode =\n        options.referenceMap && options.referenceMap.getPreviousNode(node);\n    const nextNode =\n        options.referenceMap && options.referenceMap.getNextNode(node);\n    const renderCache =\n        options.referenceMap && options.referenceMap.getRenderCache(node);\n    // It's useful to know whether we're the start or end node in an array,\n    // so compute this information.\n    return {\n        renderInfo,\n        renderCache,\n        previousNode,\n        nextNode,\n        referenceMap: options.referenceMap,\n    };\n}\n\nexport const ESCAPE = \"\\\\\";\n\n// Commands to build the prettier syntax tree\nexport const {\n    group,\n    fill,\n    ifBreak,\n    line,\n    softline,\n    hardline,\n    lineSuffix,\n    lineSuffixBoundary,\n    breakParent,\n    indent,\n    markAsRoot,\n    join,\n} = builders;\n\n/**\n * Given an array of nodes and the corresponding printed versions, prepares\n * a final Doc array. This function does things like ensures there are `hardlines`\n * around environments and that there aren't excess hardlines at the start or end.\n * It also unwraps `inParMode` macro contents.\n *\n * @export\n * @param {Ast.Node[]} nodes\n * @param {Doc[]} docArray\n * @param {*} options\n * @returns {Doc[]}\n */\nexport function formatDocArray(\n    nodes: Ast.Node[],\n    docArray: Doc[],\n    options: any\n): Doc[] {\n    const ret: Doc[] = [];\n\n    for (let i = 0; i < nodes.length; i++) {\n        const rawNode = nodes[i];\n        const printedNode = docArray[i];\n        const { renderInfo, referenceMap, previousNode, nextNode } =\n            getNodeInfo(rawNode, options);\n        const renderCache =\n            referenceMap && referenceMap.getRenderCache(rawNode);\n\n        switch (rawNode.type) {\n            case \"comment\":\n                // Comments don't insert hardlines themselves; they depend on appropriate\n                // hardlines being inserted here.\n\n                // This comment printer inserts hardlines after comments, so do not insert\n                // a hardline before a comment if there is a comment right before.\n                if (\n                    !rawNode.sameline &&\n                    previousNode &&\n                    !match.comment(previousNode) &&\n                    !match.parbreak(previousNode)\n                ) {\n                    ret.push(hardline);\n                }\n                ret.push(printedNode);\n                if (nextNode && !rawNode.suffixParbreak) {\n                    ret.push(hardline);\n                }\n                break;\n            case \"environment\":\n            case \"displaymath\":\n            case \"mathenv\":\n                // Environments always start on a new line (unless they are the first\n                // item). Peek to see if there is a newline inserted already.\n                if (previousNode && previousNode?.type !== \"parbreak\") {\n                    if (ret[ret.length - 1] === line) {\n                        // A preceding `line` should be converted into a `hardline`.\n                        // Remove the line so a hardline can be added\n                        ret.pop();\n                    }\n                    if (ret[ret.length - 1] !== hardline) {\n                        ret.push(hardline);\n                    }\n                }\n                ret.push(printedNode);\n                // If an environment is followed by whitespace, replace it with a hardline\n                // instead\n                if (nextNode?.type === \"whitespace\") {\n                    ret.push(hardline);\n                    i++;\n                }\n\n                break;\n            case \"macro\":\n                if (renderInfo.breakBefore || renderInfo.breakAround) {\n                    // Commands like \\section{} should always be preceded by a hardline\n                    if (previousNode) {\n                        if (\n                            ret[ret.length - 1] === line ||\n                            ret[ret.length - 1] === hardline\n                        ) {\n                            // We may be replacing a hardline here for no reason. However,\n                            // if there is already a hardline, we don't want to continue\n                            // and accidentally add too many linebreaks\n                            ret.pop();\n                            ret.push(hardline);\n                        } else if (\n                            !match.comment(previousNode) &&\n                            !match.parbreak(previousNode)\n                        ) {\n                            ret.push(hardline);\n                        }\n                    }\n                }\n                // Macros marked as `inParMode` should be unwrapped\n                // unless they have a hanging indent, in which case the macro\n                // has already be wrapped in an `indent` block\n                if (\n                    renderInfo.inParMode &&\n                    !renderInfo.hangingIndent &&\n                    renderCache\n                ) {\n                    ret.push(\n                        (renderCache as any).content,\n                        ...((renderCache as any).rawArgs || [])\n                    );\n                } else {\n                    ret.push(printedNode);\n                }\n                if (renderInfo.breakAfter || renderInfo.breakAround) {\n                    // Commands like \\section{} should always be followed by a hardline\n                    if (nextNode) {\n                        if (match.whitespace(nextNode)) {\n                            ret.push(hardline);\n                            i++;\n                        } else if (match.parbreak(nextNode)) {\n                            // If the next node is a parbreak, it will insert its own newline\n                        } else if (!match.comment(nextNode)) {\n                            ret.push(hardline);\n                        }\n                    }\n                }\n                break;\n            case \"parbreak\":\n                ret.push(hardline, hardline);\n                break;\n            default:\n                ret.push(printedNode);\n                break;\n        }\n    }\n\n    return ret;\n}\n", "export function zip<T, U>(array1: T[], array2: U[]): [T, U][] {\n    const ret: [T, U][] = [];\n    const len = Math.min(array1.length, array2.length);\n    for (let i = 0; i < len; i++) {\n        ret.push([array1[i], array2[i]]);\n    }\n    return ret;\n}\n", "import type { Doc } from \"prettier\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport { getNodeInfo, fill, ESCAPE, indent, group } from \"./common\";\nimport { zip } from \"../zip\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\nexport function printMacro(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Macro;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    const content =\n        (node.escapeToken != null ? node.escapeToken : ESCAPE) + node.content;\n    const args = node.args ? path.map(print, \"args\" as any) : [];\n\n    // Some of the arguments want to be printed \"inline\".\n    // We loop through the arguments and unwrap the inline ones.\n    const rawArgs = [];\n    for (const [arg, printedArg] of zip(node.args || [], args)) {\n        const renderCache = referenceMap && referenceMap.getRenderCache(arg);\n        if (renderInfo.inParMode && renderCache) {\n            rawArgs.push(...(renderCache as any[]));\n        } else {\n            rawArgs.push(printedArg);\n        }\n    }\n\n    if (referenceMap) {\n        referenceMap.setRenderCache(node, { rawArgs, content });\n    }\n\n    if (renderInfo.hangingIndent) {\n        return indent(fill([content, ...rawArgs]));\n    }\n\n    return group([content, ...rawArgs]);\n}\n", "import type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport { getNodeInfo, formatDocArray, hardline, ifBreak, fill } from \"./common\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\nimport { printTikzArgument } from \"./tikz\";\nimport { printArgumentPgfkeys } from \"./print-argument-pgfkeys\";\n\nexport function printArgument(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Argument;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    // We can return early for empty arguments (this is common for omitted optional arguments)\n    if (\n        node.openMark === \"\" &&\n        node.closeMark === \"\" &&\n        node.content.length === 0\n    ) {\n        return [];\n    }\n    const parentNode = path.getParentNode();\n    const { renderInfo: parentRenderInfo } = getNodeInfo(parentNode, options);\n    // We handle printing pgfkeys arguments manually\n    if (parentRenderInfo.pgfkeysArgs) {\n        const leadingComment =\n            node.content.length > 0 &&\n            match.comment(node.content[0]) &&\n            node.content[0].sameline\n                ? node.content[0]\n                : null;\n        const content = leadingComment ? node.content.slice(1) : node.content;\n        trim(content);\n        return printArgumentPgfkeys(content, {\n            openMark: node.openMark,\n            closeMark: node.closeMark,\n            leadingComment,\n        });\n    }\n    if (parentRenderInfo.tikzPathCommand) {\n        return printTikzArgument(path, print, options);\n    }\n\n    // Regular argument printing\n    const openMark = node.openMark;\n    const closeMark = node.closeMark;\n    let content = path.map(print, \"content\");\n    content = formatDocArray(node.content, content, options);\n\n    // if the last item is a comment, we need to insert a hardline\n    if (match.comment(node.content[node.content.length - 1])) {\n        content.push(hardline);\n    }\n\n    let rawRet: Doc[] = [openMark, fill(content), closeMark];\n    if (renderInfo.inParMode) {\n        // In paragraph node, arguments should flow just like text\n        rawRet = [openMark, ...content, closeMark];\n    }\n    if (referenceMap) {\n        // Save the raw rendered data in case a renderer higher up\n        // wants to unwrap it\n        referenceMap.setRenderCache(node, rawRet);\n    }\n\n    return rawRet;\n}\n", "import type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport {\n    getNodeInfo,\n    formatDocArray,\n    hardline,\n    join,\n    ifBreak,\n    breakParent,\n    line,\n    group,\n    indent,\n    softline,\n    fill,\n} from \"./common\";\nimport {\n    printRaw,\n} from \"@unified-latex/unified-latex-util-print-raw\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\nimport {\n    parse as parseTikz,\n    PathSpec,\n    PathSpecNode,\n    printRaw as tikzPrintRaw,\n} from \"@unified-latex/unified-latex-ctan/package/tikz\";\nimport { printArgumentPgfkeys } from \"./print-argument-pgfkeys\";\n\nexport function printTikzArgument(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Argument;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    const content: Doc[] = [];\n    const nodes = [...node.content];\n    trim(nodes);\n    try {\n        const tikzAst = parseTikz(nodes);\n        if (tikzAst.content.length === 0) {\n            content.push(\";\");\n            return content;\n        }\n\n        const printer = new TikzArgumentPrinter(tikzAst, path, print);\n        return printer.toDoc();\n    } catch (e) {\n        console.warn(\"Encountered error when trying to parse tikz argument\", e);\n    }\n\n    content.push(\";\");\n\n    return content;\n}\n\n/**\n * Print a fragment of an AST to a `Doc`.\n */\nfunction printFragment(\n    fragment: Ast.Node | Ast.Argument,\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc\n): Doc {\n    const tmpKey = Symbol();\n    const currNode = path.getNode();\n    if (!currNode) {\n        throw new Error(\n            \"tried to print a fragment, but the current node is `null`\"\n        );\n    }\n    (currNode as any)[tmpKey] = fragment;\n    const ret = print(tmpKey);\n    delete (currNode as any)[tmpKey];\n    return ret;\n}\n\n/**\n * Turn an item in a tikz PathSpec into a Doc for printing.\n */\nfunction printTikzPathSpecNode(\n    node: PathSpecNode,\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc\n): Doc {\n    switch (node.type) {\n        case \"comment\":\n            return printFragment(node, path, print);\n        case \"unknown\":\n            // `\"unknown\"` nodes contain regular AST nodes as children which couldn't be identified by the parser\n            return printFragment(node.content, path, print);\n        case \"coordinate\":\n            return [printRaw(node.prefix), \"(\", printRaw(node.content), \")\"];\n        case \"line_to\":\n            return node.command;\n        case \"square_brace_group\":\n            return printOptionalArgs(node.content);\n        case \"operation\":\n            return node.content.content;\n        case \"svg_operation\": {\n            const comments = node.comments.map((n) =>\n                printTikzPathSpecNode(n, path, print)\n            );\n            const options = node.options ? printOptionalArgs(node.options) : [];\n            const rest: Doc[] = node.options\n                ? [group(indent([line, printRaw(node.content)]))]\n                : [\" \", printRaw(node.content)];\n            return [...comments, \"svg\", options, ...rest];\n        }\n        case \"curve_to\": {\n            const comments = node.comments.map((n) =>\n                printTikzPathSpecNode(n, path, print)\n            );\n            const printedControls =\n                node.controls.length > 1\n                    ? [\n                          printTikzPathSpecNode(node.controls[0], path, print),\n                          \" \",\n                          \"and\",\n                          line,\n                          printTikzPathSpecNode(node.controls[1]!, path, print),\n                      ]\n                    : [printTikzPathSpecNode(node.controls[0], path, print)];\n            return [\n                ...comments,\n                \"..\",\n                \" \",\n                group(\n                    indent([\"controls\", line, ...printedControls, \" \", \"..\"])\n                ),\n            ];\n        }\n        case \"animation\": {\n            const comments = node.comments.map((n) =>\n                printTikzPathSpecNode(n, path, print)\n            );\n\n            return [\n                ...comments,\n                \":\",\n                node.attribute,\n                \" \",\n                \"=\",\n                \" \",\n                group(\n                    indent([\n                        printArgumentPgfkeys(node.content, {\n                            openMark: \"{\",\n                            closeMark: \"}\",\n                        }),\n                    ])\n                ),\n            ];\n        }\n        case \"foreach\": {\n            const comments = node.comments.map((n) =>\n                printTikzPathSpecNode(n, path, print)\n            );\n            const variables = [...node.variables];\n            trim(variables);\n            const list =\n                node.list.type === \"macro\"\n                    ? printFragment(node.list, path, print)\n                    : printArgumentPgfkeys(node.list.content, {\n                          openMark: \"{\",\n                          closeMark: \"}\",\n                          allowParenGroups: true,\n                      });\n            const doc = [\n                ...comments,\n                printRaw(node.start),\n                \" \",\n                printRaw(variables),\n            ];\n            if (node.options) {\n                doc.push(\" \", indent(printOptionalArgs(node.options)));\n            }\n\n            // The list, e.g. `{1,2,...,9}`\n            doc.push(\" \", \"in\", \" \", group(indent(list)));\n            // The loop body\n            // XXX: if we are in a tikz node, whitespace doesn't matter. If we are in a regular\n            // part of the document, the loop body is whitespace-sensitive\n            const commandType = node.command.type;\n            switch (commandType) {\n                case \"foreach\":\n                    doc.push(\n                        indent([\n                            line,\n                            printTikzPathSpecNode(node.command, path, print),\n                        ])\n                    );\n                    break;\n                case \"macro\":\n                    doc.push(\n                        indent([line, printFragment(node.command, path, print)])\n                    );\n                    break;\n                case \"group\": {\n                    const groupContent = [...node.command.content];\n                    trim(groupContent);\n                    doc.push(\n                        \" \",\n                        indent(\n                            group([\n                                \"{\",\n                                indent([\n                                    softline,\n                                    ...groupContent.map((n) =>\n                                        printFragment(n, path, print)\n                                    ),\n                                ]),\n                                softline,\n                                \"}\",\n                            ])\n                        )\n                    );\n                    break;\n                }\n                default:\n                    const invalidType: void = commandType;\n                    console.warn(\n                        `Unhandled command type when printing \"foreach\": ${invalidType}`\n                    );\n            }\n\n            return indent(doc);\n        }\n    }\n    console.warn(\n        `Encountered unknown type when trying to print tikz PathSpec: \"${\n            (node as any).type\n        }\"`\n    );\n    return [];\n}\n\nfunction printOptionalArgs(nodes: Ast.Node[]): Doc {\n    return printArgumentPgfkeys(nodes, {\n        openMark: \"[\",\n        closeMark: \"]\",\n    });\n}\n\n/**\n * Utility to turn a Tikz PathSpec into a Prettier Doc.\n */\nclass TikzArgumentPrinter {\n    #path: PrettierTypes.AstPath;\n    #print: PrettierTypes.RecursivePrintFunc;\n    nodes: PathSpec[\"content\"];\n    constructor(\n        spec: PathSpec,\n        path: PrettierTypes.AstPath,\n        print: PrettierTypes.RecursivePrintFunc\n    ) {\n        this.#path = path;\n        this.#print = print;\n        this.nodes = [...spec.content];\n    }\n\n    nodeToDoc(node: PathSpecNode): Doc {\n        return printTikzPathSpecNode(node, this.#path, this.#print);\n    }\n\n    toDoc(): Doc {\n        const doc: Doc = [];\n        const startArg = this.eatOptionalArg();\n        if (startArg.optionalArg) {\n            doc.push(\n                ...startArg.comments.map((c) =>\n                    printFragment(c, this.#path, this.#print)\n                )\n            );\n            doc.push(printOptionalArgs(startArg.optionalArg.content));\n        }\n\n        const innerDoc: Doc = [];\n        doc.push(group([indent(innerDoc), \";\"]));\n        let cycle = -1;\n        while (this.nodes.length > 0) {\n            cycle++;\n            // If this is the first item being printed and the draw command has no optional\n            // argument, then we force the command to start printing on the same line.\n            const firstSep = cycle === 0 && !startArg.optionalArg ? \" \" : line;\n            const comingUp = this.peek();\n            switch (comingUp) {\n                case \"short_path\": {\n                    const [n0, n1, n2] = this.nodes.splice(0, 3);\n                    // A short path does not break\n                    innerDoc.push(\n                        firstSep,\n                        this.nodeToDoc(n0),\n                        \" \",\n                        this.nodeToDoc(n1),\n                        \" \",\n                        this.nodeToDoc(n2)\n                    );\n                    continue;\n                }\n                case \"long_path\": {\n                    // A long path consists of at least a node followed by a joiner\n                    const [n0, n1] = this.nodes.splice(0, 2);\n                    if (n1.type === \"operation\") {\n                        this.nodes.unshift(n1);\n                        innerDoc.push(\n                            firstSep,\n                            this.nodeToDoc(n0),\n                            \" \",\n                            this.eatOperation()\n                        );\n                    } else {\n                        innerDoc.push(\n                            firstSep,\n                            this.nodeToDoc(n0),\n                            \" \",\n                            this.nodeToDoc(n1)\n                        );\n                    }\n                    continue;\n                }\n                case \"node\":\n                    {\n                        const eatenNode = this.eatNode();\n                        if (eatenNode) {\n                            innerDoc.push(line, ...eatenNode);\n                            continue;\n                        }\n                        console.warn(\n                            \"Expected to print a tikz `node` PathSpec but couldn't find the text `node`\"\n                        );\n                    }\n                    continue;\n                case \"operation\":\n                    innerDoc.push(firstSep, this.eatOperation());\n                    continue;\n                case \"unknown\": {\n                    const node = this.nodes.shift()!;\n                    innerDoc.push(firstSep, this.nodeToDoc(node));\n                    continue;\n                }\n            }\n            this.nodes.shift();\n        }\n\n        return doc;\n    }\n\n    /**\n     * Look at the current node and the nodes that follow. Return what\n     * \"type\" is recognized.\n     */\n    peek() {\n        // A short path is two coordinates, joined by a line_to (with no coordinates/line_to's following).\n        // If there are comments intermixed, the short path is broken.\n        const [n0, n1, n2, n3] = [\n            this.nodes[0],\n            this.nodes[1],\n            this.nodes[2],\n            this.nodes[3],\n        ];\n        if (n0?.type === \"coordinate\" && isPathJoinOperation(n1)) {\n            if (\n                n2?.type === \"coordinate\" &&\n                !(n3?.type === \"coordinate\" || isPathJoinOperation(n3))\n            ) {\n                return \"short_path\";\n            }\n            return \"long_path\";\n        }\n        if (n0?.type === \"operation\") {\n            if (n0.content.content === \"node\") {\n                // Nodes are a special type of operation.\n                return \"node\";\n            }\n            return \"operation\";\n        }\n\n        return \"unknown\";\n    }\n\n    /**\n     * Eat comments and an optional arg if present. If no optional\n     * arg is present, do nothing.\n     */\n    eatOptionalArg() {\n        let i = 0;\n        const comments: Ast.Comment[] = [];\n        let optionalArg:\n            | (PathSpecNode & { type: \"square_brace_group\" })\n            | null = null;\n        for (; i < this.nodes.length; i++) {\n            const node = this.nodes[i];\n            if (node.type === \"square_brace_group\") {\n                optionalArg = node;\n                i++;\n                break;\n            }\n            if (node.type === \"comment\") {\n                comments.push(node);\n                continue;\n            }\n            break;\n        }\n        if (optionalArg) {\n            // If we grabbed an optional argument, remove it and everything\n            // preceding it.\n            this.nodes.splice(0, i);\n        }\n        return { optionalArg, comments };\n    }\n\n    /**\n     * Eat a `type === \"operation\"` node whose contents is `\"node\"`. I.e.,\n     * the type of thing that shows up in `\\path node at (1,1) {foo};`\n     */\n    eatNode(): Doc[] | null {\n        const firstNode = this.nodes[0];\n        if (\n            firstNode?.type === \"operation\" &&\n            firstNode.content.content === \"node\"\n        ) {\n            this.nodes.shift();\n        } else {\n            return null;\n        }\n\n        // From the tikz documentation:\n        // \\path \u2026 node \u27E8foreach statements\u27E9 [\u27E8options\u27E9] (\u27E8name\u27E9) at(\u27E8coordinate\u27E9)\n        //       :\u27E8animation attribute\u27E9={\u27E8options\u27E9} {\u27E8node contents\u27E9} \u2026;\n        //\n        // Order of the parts of the specification.\n        // Everything between \u201Cnode\u201D and the opening brace of a node is optional.\n        // If there are \u27E8foreach statements\u27E9, they must come first, directly following \u201Cnode\u201D.\n        // Other than that, the ordering of all the other elements of a node specification\n        // (the \u27E8options\u27E9, the \u27E8name\u27E9, \u27E8coordinate\u27E9, and \u27E8animation attribute\u27E9) is arbitrary, indeed,\n        // there can be multiple occurrences of any of these elements (although for the name and the\n        // coordinate this makes no sense).\n\n        const innerDoc: Doc = [];\n        const commentBlock: Doc = [];\n        const doc: Doc = [commentBlock, \"node\", group(indent(innerDoc))];\n        // We now peek to see if a group `{...}` is the next thing. If so,\n        // we're going to eat everything up to it and call it quits. Otherwise,\n        // we bail.\n        let hasNodeArgument = false;\n        let shouldBail = false;\n        let i = 0;\n        const comments: Doc[] = [];\n        const options: Doc[] = [];\n        const name: Doc[] = [];\n        const atLocations: Doc[] = [];\n        const animations: Doc[] = [];\n        let content: Doc = [];\n        for (; i < this.nodes.length && !shouldBail; i++) {\n            const node = this.nodes[i];\n            switch (node.type) {\n                case \"animation\":\n                    animations.push(this.nodeToDoc(node));\n                    continue;\n                case \"comment\": {\n                    const comment: Ast.Comment = {\n                        ...node,\n                        leadingWhitespace: false,\n                    };\n                    comments.push(this.nodeToDoc(comment));\n                    continue;\n                }\n                case \"square_brace_group\":\n                    options.push(printOptionalArgs(node.content));\n                    continue;\n                case \"coordinate\":\n                    name.push(this.nodeToDoc(node));\n                    continue;\n                case \"operation\": {\n                    // An \"at\" should be followed by a coordinate or a macro. If it is,\n                    // then we slurp it. Otherwise we bail.\n                    if (node.content.content === \"at\") {\n                        const nextNode = this.nodes[i + 1];\n                        if (\n                            !nextNode ||\n                            !(\n                                nextNode.type === \"coordinate\" ||\n                                (nextNode.type === \"unknown\" &&\n                                    match.anyMacro(nextNode.content))\n                            )\n                        ) {\n                            shouldBail = true;\n                            continue;\n                        }\n                        atLocations.push([\"at\", \" \", this.nodeToDoc(nextNode)]);\n                        i++;\n                        continue;\n                    }\n                    shouldBail = true;\n                    continue;\n                }\n                case \"unknown\": {\n                    // If we're here, we must be the termination group.\n                    if (match.group(node.content)) {\n                        hasNodeArgument = true;\n                        content = this.nodeToDoc(node);\n                    }\n                    // NOTE: the fallthrough here is on purpose. Finding the terminating\n                    // groups should end our loop.\n                }\n            }\n            break;\n        }\n        if (!hasNodeArgument) {\n            return innerDoc;\n        }\n        // We have collected docs for all the nodes we've scanned, so delete\n        // them from the list.\n        this.nodes.splice(0, i + 1);\n\n        // We standardize node rendering as `[options] :animations (name) at (pos) {content}`\n        let isFirstElement = true;\n        let isNamed = !(Array.isArray(name) && name.length === 0);\n        // Comments get hoisted to before the \"node\" keyword\n        for (const comment of comments) {\n            commentBlock.push(comment, hardline);\n        }\n        if (options.length > 0) {\n            innerDoc.push(join(\" \", options));\n            isFirstElement = false;\n        }\n        if (animations.length > 0) {\n            innerDoc.push(isFirstElement ? \" \" : line);\n            innerDoc.push(join(line, animations));\n            isFirstElement = false;\n        }\n        if (isNamed) {\n            innerDoc.push(isFirstElement ? \" \" : line);\n            innerDoc.push(name);\n            isFirstElement = false;\n        }\n        if (atLocations.length > 0) {\n            innerDoc.push(isFirstElement || isNamed ? \" \" : line);\n            innerDoc.push(join(line, atLocations));\n            isFirstElement = false;\n        }\n        innerDoc.push(line, content);\n\n        return doc;\n    }\n\n    /**\n     * Eat a `type === \"operation\"` node, including its optional arguments.\n     */\n    eatOperation(): Doc[] {\n        const node = this.nodes[0];\n        if (node?.type === \"operation\") {\n            this.nodes.shift();\n        } else {\n            return [];\n        }\n\n        const doc: Doc[] = [];\n        if (node?.type !== \"operation\") {\n            throw new Error(\"Expecting `operation` node.\");\n        }\n        const options = this.eatOptionalArg();\n        doc.push(\n            ...options.comments.map((c) =>\n                printFragment(c, this.#path, this.#print)\n            ),\n            node.content.content\n        );\n        if (options.optionalArg) {\n            doc.push(indent(printOptionalArgs(options.optionalArg.content)));\n        }\n\n        return doc;\n    }\n}\n\nconst PATH_JOIN_OPERATIONS = new Set([\"rectangle\", \"grid\", \"sin\", \"cos\", \"to\"]);\n/**\n * Return whether `node` is a \"path join\", like `--`, `rectangle`, etc.\n *\n * A path join is an operation that sits between two coordinates, like\n * `(a) -- (b)` or `(a) rectangle (b)`.\n */\nfunction isPathJoinOperation(node?: PathSpecNode): boolean {\n    if (!node) {\n        return false;\n    }\n    switch (node.type) {\n        case \"line_to\":\n        case \"curve_to\":\n            return true;\n        case \"operation\":\n            return PATH_JOIN_OPERATIONS.has(node.content.content);\n    }\n    return false;\n}\n", "import { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    hardline,\n    join,\n    breakParent,\n    line,\n    group,\n    indent,\n    softline,\n} from \"./common\";\nimport {\n    linebreak,\n    printRaw,\n} from \"@unified-latex/unified-latex-util-print-raw\";\nimport { parsePgfkeys } from \"@unified-latex/unified-latex-util-pgfkeys\";\n\n/**\n * Format a sequence of Pgfkeys key-value pairs. `nodes` will be parsed\n * by a grammar defining Pgfkeys\n */\nexport function printArgumentPgfkeys(\n    nodes: Ast.Node[],\n    options: {\n        openMark: string;\n        closeMark: string;\n        leadingComment?: Ast.Comment | null | undefined;\n        allowParenGroups?: boolean;\n    }\n): Doc {\n    const { allowParenGroups = false } = options;\n    const parsed = parsePgfkeys(nodes, { allowParenGroups });\n\n    const content: Doc[] = [];\n    for (const part of parsed) {\n        const isLastItem = part === parsed[parsed.length - 1];\n\n        if (part.itemParts) {\n            // parts are printed using `printRaw`, `hardline` is used in place\n            // of \"\\n\"\n            const parts = part.itemParts.map((node) =>\n                printRaw(node, { asArray: true }).map((token) =>\n                    token === linebreak ? hardline : token\n                )\n            );\n            const row = join(\"=\", parts);\n            content.push(row);\n            if (part.trailingComma) {\n                content.push(\",\");\n            }\n        }\n        if (part.trailingComment) {\n            const leadingContent: Doc[] = part.itemParts ? [\" \"] : [];\n            if (part.leadingParbreak) {\n                // We preserve parbreaks before comments, so if we have\n                // one, insert an extra hardline\n                leadingContent.push(hardline);\n            }\n\n            content.push(\n                ...leadingContent,\n                // We're carefully and manually controlling the newlines,\n                // so print the comment directly without any newlines\n                \"%\",\n                part.trailingComment.content,\n                breakParent\n            );\n        }\n\n        if (!isLastItem) {\n            content.push(line);\n        }\n    }\n\n    let leadingComment: Doc[] = [\"\"];\n    if (options.leadingComment) {\n        if (options.leadingComment.leadingWhitespace) {\n            leadingComment.push(\" \");\n        }\n        leadingComment.push(\"%\" + options.leadingComment.content, breakParent);\n    }\n\n    return group([\n        options.openMark,\n        ...leadingComment,\n        // If there is no content, we don't want to push an extra `softline`.\n        // This matters because the braces group could still be broken by `leadingComment`\n        content.length > 0 ? indent([softline, ...content]) : \"\",\n        softline,\n        options.closeMark,\n    ]);\n}\n", "import type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport { getNodeInfo, fill, formatDocArray } from \"./common\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Returns true if a `\\documentclass` macro is detected,\n * which would indicate that the node list contains the preamble.\n *\n * @param {[object]} nodes\n */\nexport function hasPreambleCode(nodes: Ast.Node[]) {\n    return nodes.some((node) => match.macro(node, \"documentclass\"));\n}\n\nexport function printRoot(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Root;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    const content = path.map(print, \"content\");\n    const rawContent = formatDocArray(node.content, content, options);\n\n    const concatFunction = hasPreambleCode(node.content) ? (x: any) => x : fill;\n    return concatFunction(rawContent);\n}\n", "import type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport * as PrettierTypes from \"./prettier-types\";\n\nexport function printComment(\n    path: PrettierTypes.AstPath,\n    _print: PrettierTypes.RecursivePrintFunc,\n    _options: any\n): Doc {\n    const node = path.getNode() as Ast.Comment;\n\n    // If a comment is on the same line as other content and it has leading whitespace,\n    // add a single whitespace token.\n    let leadingWhitespace = \"\";\n    if (node.leadingWhitespace && node.sameline) {\n        leadingWhitespace = \" \";\n    }\n\n    const content: Doc[] = [leadingWhitespace, \"%\" + printRaw(node.content)];\n    return content;\n}\n", "import type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport {\n    getNodeInfo,\n    softline,\n    fill,\n    hardline,\n    line,\n    indent,\n    ESCAPE,\n    joinWithSoftline,\n    formatDocArray,\n} from \"./common\";\n\nexport function printInlineMath(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.InlineMath;\n\n    // Since `$$` starts display math mode (in plain TeX),\n    // an empty inline math environment must be printed as `$ $`.\n    // We special case this.\n    if (node.content.length === 0) {\n        // We won't allow an empty math environment to be broken\n        return [\"$\", \" \", \"$\"];\n    }\n\n    let content = path.map(print, \"content\");\n    content = formatDocArray(node.content, content, options);\n    content = joinWithSoftline(content);\n\n    // If the last node is a comment, we need a linebreak before the closing `$`\n    if (node.content[node.content.length - 1].type === \"comment\") {\n        content.push(hardline);\n    }\n\n    return fill([\"$\", ...content, \"$\"]);\n}\n\nexport function printDisplayMath(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.InlineMath;\n\n    let content = path.map(print, \"content\");\n    content = formatDocArray(node.content, content, options);\n    content = joinWithSoftline(content);\n\n    // If we start with a comment on the same line as the environment\n    // We should not insert a newline at the start of the environment body\n    const bodyStartToken: PrettierTypes.Doc[] = [hardline];\n    if (\n        node.content.length === 0 ||\n        (node.content[0].type === \"comment\" && node.content[0].sameline)\n    ) {\n        bodyStartToken.pop();\n    }\n\n    return [\n        ESCAPE + \"[\",\n        indent(fill(bodyStartToken.concat(content))),\n        hardline,\n        ESCAPE + \"]\",\n    ];\n}\n", "import type { Doc } from \"prettier\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport {\n    getNodeInfo,\n    softline,\n    fill,\n    indent,\n    hardline,\n    line,\n    ESCAPE,\n    formatEnvSurround,\n    joinWithSoftline,\n    formatDocArray,\n} from \"./common\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { parseAlignEnvironment } from \"@unified-latex/unified-latex-util-align\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\n\nexport function printVerbatimEnvironment(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.VerbatimEnvironment;\n\n    const env = formatEnvSurround(node as any);\n\n    return [env.start, node.content, env.end];\n}\n\nexport function printEnvironment(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Environment;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    const args = node.args ? path.map(print, \"args\" as any) : [];\n    const env = formatEnvSurround(node);\n\n    let content = path.map(print, \"content\");\n    content = formatDocArray(node.content, content, options);\n    if (renderInfo.inMathMode) {\n        content = joinWithSoftline(content);\n    }\n\n    // If we start with a comment on the same line as the environment\n    // We should not insert a newline at the start of the environment body\n    let bodyStartToken: PrettierTypes.Doc[] = [hardline];\n    if (\n        node.content.length === 0 ||\n        (node.content[0].type === \"comment\" && node.content[0].sameline)\n    ) {\n        bodyStartToken.pop();\n    }\n\n    return [\n        env.start,\n        ...args,\n        indent(fill(bodyStartToken.concat(content))),\n        hardline,\n        env.end,\n    ];\n}\n\nexport function printAlignedEnvironment(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Environment;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    const args = node.args ? path.map(print, \"args\" as any) : [];\n    const env = formatEnvSurround(node);\n\n    // If an aligned environment starts with a same-line comment, we want\n    // to ignore it. It will be printed by the environment itself.\n    const leadingComment =\n        node.content[0] &&\n        node.content[0].type === \"comment\" &&\n        node.content[0].sameline\n            ? node.content[0]\n            : null;\n\n    const { rows, rowSeps, trailingComments } = formatAlignedContent(\n        leadingComment ? node.content.slice(1) : node.content\n    );\n\n    const content = [];\n    for (let i = 0; i < rows.length; i++) {\n        const row = rows[i];\n        const rowSep = rowSeps[i];\n        const trailingComment = trailingComments[i];\n\n        // A row has\n        // 1) Content\n        // 2) (optional) rowSep (e.g., `\\\\`)\n        // 3) (optional) comment\n        // We want there to be exactly one space before the rowsep and exactly one space\n        // before any comment.\n        content.push(row);\n        if (rowSep) {\n            content.push(printRaw(rowSep));\n        }\n        if (rowSep && trailingComment) {\n            content.push(\" \");\n        }\n        if (trailingComment) {\n            content.push([\"%\", printRaw(trailingComment.content)]);\n        }\n        if (rowSep || trailingComment) {\n            content.push(hardline);\n        }\n    }\n    // Make sure the last item is not a `hardline`.\n    if (content[content.length - 1] === hardline) {\n        content.pop();\n    }\n\n    if (leadingComment) {\n        content.unshift(\n            leadingComment.leadingWhitespace ? \" \" : \"\",\n            \"%\" + printRaw(leadingComment.content),\n            hardline\n        );\n        return [env.start, ...args, indent(content), hardline, env.end];\n    }\n    return [\n        env.start,\n        ...args,\n        indent([hardline, ...content]),\n        hardline,\n        env.end,\n    ];\n}\n\n/**\n * Formats the content of an aligned/tabular environment's content.\n * Ensures the \"&\" delimiters all line up.\n *\n * @export\n * @param {[object]} nodes\n * @returns {{rows: [string], rowSeps: [object]}}\n */\nexport function formatAlignedContent(nodes: Ast.Node[]) {\n    function getSpace(len = 1) {\n        return \" \".repeat(len);\n    }\n\n    const rows = parseAlignEnvironment(nodes as any);\n    // Find the number of columns\n    const numCols = Math.max(...rows.map((r) => r.cells.length));\n    const rowSeps = rows.map(({ rowSep }) => printRaw(rowSep || []));\n    const trailingComments = rows.map(({ trailingComment }) => trailingComment);\n\n    // Get the widths of each column.\n    // Column widths will be the width of column contents plus the width\n    // of the separator. This way, even multi-character separators\n    // can be accommodated when rendering.\n    const renderedRows = rows.map(({ cells, colSeps }) => ({\n        cells: cells.map((nodes) => {\n            trim(nodes);\n\n            return printRaw(nodes);\n        }),\n        seps: colSeps.map((nodes) => printRaw(nodes)),\n    }));\n    const colWidths: number[] = [];\n    for (let i = 0; i < numCols; i++) {\n        colWidths.push(\n            Math.max(\n                ...renderedRows.map(\n                    ({ cells, seps }) =>\n                        ((cells[i] || \"\") + (seps[i] || \"\")).length\n                )\n            )\n        );\n    }\n\n    const joinedRows = renderedRows.map(({ cells, seps }) => {\n        if (cells.length === 1 && cells[0] === \"\") {\n            return \"\";\n        }\n        let ret = \"\";\n        for (let i = 0; i < cells.length; i++) {\n            // There are at least as many cells as there are `seps`. Possibly one extra\n            const width = colWidths[i] - (seps[i] || \"\").length;\n\n            // Insert a space at the start so we don't run into the prior separator.\n            // We'll trim this off in the end, in case it's not needed.\n            ret +=\n                (i === 0 ? \"\" : \" \") +\n                cells[i] +\n                getSpace(width - cells[i].length + 1) +\n                (seps[i] || \"\");\n        }\n        return ret;\n    });\n\n    return { rows: joinedRows, rowSeps, trailingComments };\n}\n", "import type { Doc } from \"prettier\";\nimport * as PrettierTypes from \"./prettier-types\";\n\nimport { hardline, line, ESCAPE, getNodeInfo } from \"./common\";\nimport { printMacro } from \"./macro\";\nimport { printArgument } from \"./argument\";\nimport { printRoot } from \"./root\";\nimport { printComment } from \"./comment\";\nimport { printInlineMath, printDisplayMath } from \"./math\";\nimport {\n    printVerbatimEnvironment,\n    printEnvironment,\n    printAlignedEnvironment,\n} from \"./environment\";\nimport {\n    linebreak,\n    printRaw,\n} from \"@unified-latex/unified-latex-util-print-raw\";\nimport { ReferenceMap } from \"../reference-map\";\n\nexport function printLatexAst(\n    path: PrettierTypes.AstPath,\n    options: PrettierTypes.Options & { referenceMap?: ReferenceMap },\n    print: PrettierTypes.RecursivePrintFunc\n): Doc {\n    const node = path.getValue();\n    const { renderInfo } = getNodeInfo(node, options);\n\n    if (node == null) {\n        return node;\n    }\n    if (typeof node === \"string\") {\n        return node;\n    }\n\n    switch (node.type) {\n        case \"root\":\n            // Create the ReferenceMap from the root node, so that\n            // it can traverse the entire AST\n            if (options.referenceMap) {\n                console.warn(\n                    \"Processing root node, but ReferenceMap already exists. Are there multiple nodes of type 'root'?\"\n                );\n            }\n            options.referenceMap = new ReferenceMap(node);\n            return printRoot(path, print, options);\n        case \"argument\":\n            return printArgument(path, print, options);\n        case \"comment\":\n            return printComment(path, print, options);\n        case \"environment\":\n        case \"mathenv\":\n            if (renderInfo.alignContent) {\n                return printAlignedEnvironment(path, print, options);\n            }\n            return printEnvironment(path, print, options);\n        case \"displaymath\":\n            return printDisplayMath(path, print, options);\n        case \"group\":\n            // When we print a group, we are conservative and do a raw print of its contents.\n            // However, we want to use `linebreak`s instead of literal `\\n` tokens.\n            const content = printRaw(node.content, {\n                asArray: true,\n            }).map((token) => (token === linebreak ? hardline : token));\n            return [\"{\", ...content, \"}\"];\n        case \"inlinemath\":\n            return printInlineMath(path, print, options);\n        case \"macro\":\n            return printMacro(path, print, options);\n        case \"parbreak\":\n            return [hardline, hardline];\n        case \"string\":\n            return node.content;\n        case \"verb\":\n            return [\n                ESCAPE,\n                node.env,\n                node.escape,\n                printRaw(node.content),\n                node.escape,\n            ];\n        case \"verbatim\":\n            return printVerbatimEnvironment(path, print, options);\n        case \"whitespace\":\n            return line;\n        default:\n            console.warn(\"Printing unknown type\", node);\n            return printRaw(node);\n    }\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\n\n/**\n * Generate a data structure that can be queried\n * for the next/previous node. This allows for \"peeking\"\n * during the rendering process.\n *\n * @class ReferenceMap\n */\nexport class ReferenceMap {\n    ast: Ast.Ast;\n    map: Map<\n        Ast.Ast,\n        { previous?: Ast.Ast; next?: Ast.Ast; renderCache?: any }\n    >;\n\n    constructor(ast: Ast.Ast) {\n        this.ast = ast;\n        this.map = new Map();\n        visit(\n            this.ast,\n            (nodeList) => {\n                for (let i = 0; i < nodeList.length; i++) {\n                    this.map.set(nodeList[i], {\n                        previous: nodeList[i - 1],\n                        next: nodeList[i + 1],\n                    });\n                }\n            },\n            { includeArrays: true, test: Array.isArray }\n        );\n    }\n\n    /**\n     * Associate render-specific data with this node. This data\n     * will be overwritten if `setRenderCache` is called twice.\n     *\n     * @param {Ast.Ast} node\n     * @param {*} data\n     * @memberof ReferenceMap\n     */\n    setRenderCache(node: any, data: any): void {\n        const currData = this.map.get(node) || {};\n        this.map.set(node, { ...currData, renderCache: data });\n    }\n\n    /**\n     * Retrieve data associated with `node` via `setRenderCache`\n     *\n     * @param {Ast.Ast} node\n     * @returns {(object | undefined)}\n     * @memberof ReferenceMap\n     */\n    getRenderCache(node: any): object | any[] | undefined {\n        return this.map.get(node)?.renderCache;\n    }\n\n    getPreviousNode(node: Ast.Ast): Ast.Node | undefined {\n        return (this.map.get(node) || ({} as any)).previous;\n    }\n\n    getNextNode(node: Ast.Ast): Ast.Node | undefined {\n        return (this.map.get(node) || ({} as any)).next;\n    }\n}\n", "import type { Plugin, Printer } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { parse } from \"@unified-latex/unified-latex-util-parse\";\nimport { printLatexAst } from \"./printer\";\n\nconst languages = [\n    {\n        name: \"latex\",\n        extensions: [\".tex\"],\n        parsers: [\"latex-parser\"],\n    },\n];\n\nconst parsers = {\n    \"latex-parser\": {\n        parse,\n        astFormat: \"latex-ast\",\n        locStart: (node: Ast.Node) =>\n            node.position ? node.position.start.offset : 0,\n        locEnd: (node: Ast.Node) =>\n            node.position ? node.position.end.offset : 1,\n    },\n};\n\nconst printers = {\n    \"latex-ast\": {\n        print: printLatexAst,\n    } as Printer,\n};\n\nconst prettierPluginLatex: Plugin<Ast.Node> = { languages, parsers, printers };\n\nexport { prettierPluginLatex };\n"],
  "mappings": "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",
  "names": ["group2", "indent2", "lineSuffix2", "softline", "group", "fill", "ifBreak", "line", "hardline", "lineSuffix", "lineSuffixBoundary", "breakParent", "indent", "markAsRoot", "join", "indent", "fill", "group", "match", "trim", "printRaw", "match", "trim", "printRaw", "hardline", "join", "breakParent", "line", "group", "indent", "softline", "trim", "printer", "printRaw", "group", "indent", "line", "softline", "match", "hardline", "join", "match", "content", "trim", "hardline", "fill", "match", "fill", "printRaw", "_print", "hardline", "fill", "indent", "printRaw", "trim", "hardline", "indent", "fill", "nodes", "linebreak", "printRaw", "printRaw", "linebreak", "hardline", "line"]
}
