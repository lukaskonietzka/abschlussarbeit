{
  "version": 3,
  "sources": ["../../../node_modules/trie-prefix-tree/dist/config.js", "../../../node_modules/trie-prefix-tree/dist/append.js", "../../../node_modules/trie-prefix-tree/dist/create.js", "../../../node_modules/trie-prefix-tree/dist/utils.js", "../../../node_modules/trie-prefix-tree/dist/checkPrefix.js", "../../../node_modules/trie-prefix-tree/dist/recursePrefix.js", "../../../node_modules/trie-prefix-tree/dist/recurseRandomWord.js", "../../../node_modules/trie-prefix-tree/dist/permutations.js", "../../../node_modules/trie-prefix-tree/dist/index.js", "../../../node_modules/is-buffer/index.js", "../../../node_modules/extend/index.js", "../../../node_modules/color-name/index.js", "../../../node_modules/simple-swizzle/node_modules/is-arrayish/index.js", "../../../node_modules/simple-swizzle/index.js", "../../../node_modules/color-string/index.js", "../../../node_modules/color-convert/conversions.js", "../../../node_modules/color-convert/route.js", "../../../node_modules/color-convert/index.js", "../../../node_modules/color/index.js", "../index.ts", "../node_modules/prettier/doc.mjs", "../../unified-latex-util-print-raw/libs/print-raw.ts", "../../unified-latex-util-match/libs/match.ts", "../libs/printer/common.ts", "../libs/zip.ts", "../libs/printer/macro.ts", "../../unified-latex-util-visit/libs/list-math-children.ts", "../../unified-latex-util-visit/libs/visit.ts", "../../unified-latex-util-trim/libs/trim.ts", "../../unified-latex-util-trim/libs/unified-latex-trim-environment-contents.ts", "../../unified-latex-util-trim/libs/unified-latex-trim-root.ts", "../../unified-latex-util-trim/libs/has-whitespace-equivalent.ts", "../../unified-latex-util-pegjs/libs/decorate-array-for-pegjs.ts", "../../unified-latex-util-pegjs/libs/split-strings.ts", "../../unified-latex-util-pegjs/grammars/latex.pegjs", "../../unified-latex-util-pegjs/grammars/align-environment.pegjs", "../../unified-latex-util-pegjs/grammars/xparse-argspec.pegjs", "../../unified-latex-util-pegjs/grammars/pgfkeys.pegjs", "../../unified-latex-util-pegjs/grammars/macro-substitutions.pegjs", "../../unified-latex-util-pegjs/grammars/ligatures.pegjs", "../../unified-latex-util-pegjs/grammars/xcolor-expressions.pegjs", "../../unified-latex-util-pegjs/grammars/tabular-spec.pegjs", "../../unified-latex-util-pegjs/grammars/systeme-environment.pegjs", "../../unified-latex-util-pegjs/grammars/tex-glue.pegjs", "../../unified-latex-util-pegjs/grammars/tikz.pegjs", "../../unified-latex-util-pegjs/libs/pegjs-parsers.ts", "../../unified-latex-util-argspec/libs/argspec-parser.ts", "../../unified-latex-util-argspec/libs/argspec-types.ts", "../../unified-latex-builder/libs/builders.ts", "../../unified-latex-util-scan/libs/scan.ts", "../../unified-latex-util-scan/libs/prefix-match.ts", "../../unified-latex-util-render-info/index.ts", "../../unified-latex-util-arguments/libs/gobble-arguments.ts", "../../unified-latex-util-arguments/libs/gobble-single-argument.ts", "../../unified-latex-util-arguments/libs/attach-arguments.ts", "../../unified-latex-util-arguments/libs/unified-latex-attach-macro-arguments.ts", "../../unified-latex-util-arguments/libs/get-args-content.ts", "../../unified-latex-ctan/package/tikz/libs/tikz-command-argument-parser.ts", "../../unified-latex-ctan/package/tikz/libs/parser.ts", "../../unified-latex-util-pgfkeys/libs/pgfkeys-parser.ts", "../../unified-latex-util-pgfkeys/libs/pgfkeys-to-object.ts", "../libs/printer/print-argument-pgfkeys.ts", "../libs/printer/tikz.ts", "../libs/printer/argument.ts", "../libs/printer/root.ts", "../libs/printer/comment.ts", "../libs/printer/math.ts", "../../unified-latex-util-align/libs/parse-align-environment.ts", "../libs/printer/environment.ts", "../libs/reference-map.ts", "../libs/printer/printer.ts", "../../../node_modules/bail/index.js", "../../../node_modules/unified/lib/index.js", "../../../node_modules/unified/node_modules/is-plain-obj/index.js", "../../../node_modules/trough/index.js", "../../../node_modules/vfile/lib/index.js", "../../../node_modules/unist-util-stringify-position/lib/index.js", "../../../node_modules/vfile-message/index.js", "../../../node_modules/vfile/lib/minpath.browser.js", "../../../node_modules/vfile/lib/minproc.browser.js", "../../../node_modules/vfile/lib/minurl.shared.js", "../../../node_modules/vfile/lib/minurl.browser.js", "../../unified-latex-util-split/libs/split-on-macro.ts", "../../unified-latex-util-split/libs/split-on-condition.ts", "../../unified-latex-util-split/libs/unsplit-on-macro.ts", "../../unified-latex-util-split/libs/array-join.ts", "../../unified-latex-util-replace/libs/replace-node.ts", "../../unified-latex-util-replace/libs/unified-latex-streaming-command.ts", "../../unified-latex-util-replace/libs/replace-streaming-command.ts", "../../unified-latex-util-replace/libs/utils/significant-node.ts", "../../unified-latex-util-replace/libs/utils/replace-streaming-command-in-array.ts", "../../unified-latex-util-replace/libs/utils/join-without-excess-whitespace.ts", "../../unified-latex-util-replace/libs/utils/wrap-significant-content.ts", "../../unified-latex-util-replace/libs/replace-node-during-visit.ts", "../../unified-latex-ctan/package/cleveref/provides.ts", "../../unified-latex-ctan/utils/enumerate.ts", "../../unified-latex-ctan/package/exam/provides.ts", "../../unified-latex-ctan/package/geometry/provides.ts", "../../unified-latex-ctan/package/hyperref/provides.ts", "../../unified-latex-ctan/package/latex2e/provides.ts", "../../unified-latex-ctan/package/listings/libs/argument-parser.ts", "../../unified-latex-ctan/package/listings/provides.ts", "../../unified-latex-ctan/package/makeidx/provides.ts", "../../unified-latex-ctan/package/mathtools/provides.ts", "../../unified-latex-ctan/package/minted/libs/argument-parser.ts", "../../unified-latex-ctan/package/minted/provides.ts", "../../unified-latex-ctan/package/nicematrix/provides.ts", "../../unified-latex-ctan/package/systeme/provides.ts", "../../unified-latex-ctan/package/systeme/libs/parser.ts", "../../unified-latex-ctan/package/systeme/libs/print-raw.ts", "../../unified-latex-ctan/package/systeme/libs/systeme.ts", "../../structured-clone/index.ts", "../../unified-latex-ctan/package/tikz/provides.ts", "../../unified-latex-ctan/package/tikz/libs/tikz-command-argument-parser.ts", "../../unified-latex-ctan/package/tikz/libs/print-raw.ts", "../../unified-latex-ctan/package/tikz/libs/parser.ts", "../../unified-latex-ctan/package/xcolor/provides.ts", "../../unified-latex-ctan/package/xcolor/libs/xcolor.ts", "../../unified-latex-ctan/package/xcolor/libs/predefined-colors.ts", "../../unified-latex-ctan/package/xcolor/libs/parser.ts", "../../unified-latex-ctan/package/xcolor/libs/xcolor-macro-to-hex.ts", "../../unified-latex-ctan/package/xcolor/libs/color-to-textcolor-macro.ts", "../../unified-latex-ctan/package/xparse/provides.ts", "../../unified-latex-ctan/package/beamer/provides.ts", "../../unified-latex-ctan/package/multicol/provides.ts", "../../unified-latex-ctan/index.ts", "../../unified-latex-util-environments/libs/process-environment.ts", "../../unified-latex-util-environments/libs/unified-latex-process-environment.ts", "../../unified-latex-util-catcode/libs/find-region.ts", "../../unified-latex-util-catcode/libs/special-regions.ts", "../../unified-latex-util-catcode/libs/regions.ts", "../../unified-latex-util-catcode/libs/reparse-macro-names.ts", "../../unified-latex-util-parse/libs/compiler-ast.ts", "../../unified-latex-util-parse/libs/plugin-from-string.ts", "../../unified-latex-util-parse/libs/parse-minimal.ts", "../../unified-latex-util-parse/libs/plugin-from-string-minimal.ts", "../../unified-latex-util-parse/libs/process-macros-and-environments.ts", "../../unified-latex-util-parse/libs/reparse-math.ts", "../../unified-latex-util-parse/libs/process-at-letter-and-expl-macros.ts", "../../unified-latex-util-parse/libs/parse.ts", "../../unified-latex-util-parse/libs/parse-math.ts", "../libs/prettier-plugin-latex.ts"],
  "sourcesContent": ["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = {\n  END_WORD: '$',\n  END_WORD_REPLACER: '9a219a89-91cd-42e2-abd5-eb113af08ca8',\n  PERMS_MIN_LEN: 2\n};\nmodule.exports = exports['default'];", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = append;\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction append(trie, letter, index, array) {\n  var isEndWordLetter = letter === _config2.default.END_WORD;\n  var isLastLetter = index === array.length - 1;\n\n  if (isEndWordLetter && !isLastLetter) {\n    trie[_config2.default.END_WORD] = 1;\n    trie[_config2.default.END_WORD_REPLACER] = {};\n    trie = trie[_config2.default.END_WORD_REPLACER];\n  } else {\n    trie[letter] = trie[letter] || {};\n    trie = trie[letter];\n  }\n\n  if (isLastLetter) {\n    trie[_config2.default.END_WORD] = 1;\n  }\n\n  return trie;\n}\nmodule.exports = exports['default'];", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = create;\n\nvar _append = require('./append');\n\nvar _append2 = _interopRequireDefault(_append);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction create(input) {\n  if (!Array.isArray(input)) {\n    throw 'Expected parameter Array, received ' + (typeof input === 'undefined' ? 'undefined' : _typeof(input));\n  }\n\n  var trie = input.reduce(function (accumulator, item) {\n    item.toLowerCase().split('').reduce(_append2.default, accumulator);\n\n    return accumulator;\n  }, {});\n\n  return trie;\n};\nmodule.exports = exports['default'];", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = {\n  objectCopy: function objectCopy(obj) {\n    if (typeof obj === 'undefined') {\n      return {};\n    }\n    return JSON.parse(JSON.stringify(obj));\n  },\n  stringify: function stringify(obj) {\n    var spacer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n\n    if (typeof obj === 'undefined') {\n      return '';\n    }\n    return JSON.stringify(obj, null, spacer);\n  }\n};\nmodule.exports = exports['default'];", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = checkPrefix;\n\nvar _utils = require('./utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction checkPrefix(prefixNode, prefix) {\n  var input = prefix.toLowerCase().split('');\n  var prefixFound = input.every(function (letter, index) {\n    if (!prefixNode[letter]) {\n      return false;\n    }\n    return prefixNode = prefixNode[letter];\n  });\n\n  return {\n    prefixFound: prefixFound,\n    prefixNode: prefixNode\n  };\n};\nmodule.exports = exports['default'];", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = recursePrefix;\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// sort items as they're being found\n// to prevent slow .sort() in NodeJs\nvar pushInOrder = function pushInOrder(word, prefixes) {\n  var i = 0;\n\n  while (i < prefixes.length) {\n    if (word < prefixes[i]) {\n      break;\n    }\n    i += 1;\n  }\n\n  prefixes.splice(i, 0, word);\n\n  return prefixes;\n};\n\nfunction recursePrefix(node, prefix, sorted) {\n  var prefixes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n  var word = prefix;\n\n  for (var branch in node) {\n    var currentLetter = branch;\n    if (branch === _config2.default.END_WORD && typeof node[branch] === 'number') {\n      if (sorted) {\n        pushInOrder(word, prefixes);\n      } else {\n        prefixes.push(word);\n      }\n      word = '';\n    } else if (branch === _config2.default.END_WORD_REPLACER) {\n      currentLetter = _config2.default.END_WORD;\n    }\n    recursePrefix(node[branch], prefix + currentLetter, sorted, prefixes);\n  }\n\n  return prefixes;\n}\nmodule.exports = exports['default'];", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = recurseRandomWord;\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction recurseRandomWord(node, prefix) {\n  var word = prefix;\n  var branches = Object.keys(node);\n  var branch = branches[Math.floor(Math.random() * branches.length)];\n\n  if (branch === _config2.default.END_WORD) {\n    return word;\n  }\n  return recurseRandomWord(node[branch], prefix + branch);\n};\nmodule.exports = exports['default'];", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = permutations;\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction permutations(letters, trie) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    type: 'anagram'\n  };\n\n  if (typeof letters !== 'string') {\n    throw 'Permutations expects string letters, received ' + (typeof letters === 'undefined' ? 'undefined' : _typeof(letters));\n  }\n\n  var words = [];\n\n  var permute = function permute(word, node) {\n    var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n    var wordIsEmpty = word.length === 0;\n    var wordFound = words.indexOf(prefix) !== -1;\n    var endWordFound = node[_config2.default.END_WORD] === 1;\n\n    if (wordIsEmpty && endWordFound && !wordFound) {\n      words.push(prefix);\n    }\n\n    for (var i = 0, len = word.length; i < len; i++) {\n      var letter = word[i];\n\n      if (opts.type === 'sub-anagram') {\n        if (endWordFound && !(words.indexOf(prefix) !== -1)) {\n          words.push(prefix);\n        }\n      }\n\n      if (node[letter]) {\n        var remaining = word.substring(0, i) + word.substring(i + 1, len);\n        permute(remaining, node[letter], prefix + letter, words);\n      }\n    }\n\n    return words.sort();\n  };\n\n  return permute(letters, trie);\n};\nmodule.exports = exports['default'];", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = function (input) {\n  if (!Array.isArray(input)) {\n    throw 'Expected parameter Array, received ' + (typeof input === 'undefined' ? 'undefined' : _typeof(input));\n  }\n\n  var trie = (0, _create2.default)([].concat(_toConsumableArray(input)));\n\n  return {\n    /**\n     * Get the generated raw trie object\n    */\n    tree: function tree() {\n      return trie;\n    },\n\n\n    /**\n     * Get a string representation of the trie\n    */\n    dump: function dump() {\n      var spacer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      return _utils2.default.stringify(trie, spacer);\n    },\n\n\n    /**\n     * Add a new word to the trie\n     */\n    addWord: function addWord(word) {\n      if (typeof word !== 'string' || word === '') {\n        throw 'Expected parameter string, received ' + (typeof word === 'undefined' ? 'undefined' : _typeof(word));\n      }\n\n      var reducer = function reducer() {\n        return _append2.default.apply(undefined, arguments);\n      };\n\n      var input = word.toLowerCase().split('');\n      input.reduce(reducer, trie);\n\n      return this;\n    },\n\n\n    /**\n     * Remove an existing word from the trie\n     */\n    removeWord: function removeWord(word) {\n      if (typeof word !== 'string' || word === '') {\n        throw 'Expected parameter string, received ' + (typeof word === 'undefined' ? 'undefined' : _typeof(word));\n      }\n\n      var _checkPrefix = (0, _checkPrefix6.default)(trie, word),\n          prefixFound = _checkPrefix.prefixFound,\n          prefixNode = _checkPrefix.prefixNode;\n\n      if (prefixFound) {\n        delete prefixNode[_config2.default.END_WORD];\n      }\n\n      return this;\n    },\n\n\n    /**\n     * Check a prefix is valid\n     * @returns Boolean\n    */\n    isPrefix: function isPrefix(prefix) {\n      if (typeof prefix !== 'string') {\n        throw 'Expected string prefix, received ' + (typeof prefix === 'undefined' ? 'undefined' : _typeof(prefix));\n      }\n\n      var _checkPrefix2 = (0, _checkPrefix6.default)(trie, prefix),\n          prefixFound = _checkPrefix2.prefixFound;\n\n      return prefixFound;\n    },\n\n\n    /**\n    * Get a list of all words in the trie with the given prefix\n    * @returns Array\n    */\n    getPrefix: function getPrefix(strPrefix) {\n      var sorted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (typeof strPrefix !== 'string') {\n        throw 'Expected string prefix, received ' + (typeof strPrefix === 'undefined' ? 'undefined' : _typeof(strPrefix));\n      }\n\n      if (typeof sorted !== 'boolean') {\n        throw 'Expected sort parameter as boolean, received ' + (typeof sorted === 'undefined' ? 'undefined' : _typeof(sorted));\n      }\n\n      if (!this.isPrefix(strPrefix)) {\n        return [];\n      }\n\n      var prefixNode = strPrefix.length ? (0, _checkPrefix6.default)(trie, strPrefix).prefixNode : trie;\n\n      return (0, _recursePrefix2.default)(prefixNode, strPrefix, sorted);\n    },\n\n\n    /**\n    * Get a random word in the trie with the given prefix\n    * @returns Array\n    */\n    getRandomWordWithPrefix: function getRandomWordWithPrefix(strPrefix) {\n      if (typeof strPrefix !== 'string') {\n        throw 'Expected string prefix, received ' + (typeof strPrefix === 'undefined' ? 'undefined' : _typeof(strPrefix));\n      }\n\n      if (!this.isPrefix(strPrefix)) {\n        return '';\n      }\n\n      var _checkPrefix3 = (0, _checkPrefix6.default)(trie, strPrefix),\n          prefixNode = _checkPrefix3.prefixNode;\n\n      return (0, _recurseRandomWord2.default)(prefixNode, strPrefix);\n    },\n\n\n    /**\n    * Count the number of words with the given prefixSearch\n    * @returns Number\n    */\n    countPrefix: function countPrefix(strPrefix) {\n      var prefixes = this.getPrefix(strPrefix);\n\n      return prefixes.length;\n    },\n\n\n    /**\n    * Get all words in the trie\n    * @returns Array\n    */\n    getWords: function getWords() {\n      var sorted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      return this.getPrefix('', sorted);\n    },\n\n\n    /**\n    * Check the existence of a word in the trie\n    * @returns Boolean\n    */\n    hasWord: function hasWord(word) {\n      if (typeof word !== 'string') {\n        throw 'Expected string word, received ' + (typeof word === 'undefined' ? 'undefined' : _typeof(word));\n      }\n\n      var _checkPrefix4 = (0, _checkPrefix6.default)(trie, word),\n          prefixFound = _checkPrefix4.prefixFound,\n          prefixNode = _checkPrefix4.prefixNode;\n\n      if (prefixFound) {\n        return prefixNode[_config2.default.END_WORD] === 1;\n      }\n\n      return false;\n    },\n\n\n    /**\n    * Get a list of valid anagrams that can be made from the given letters\n    * @returns Array\n    */\n    getAnagrams: function getAnagrams(letters) {\n      if (typeof letters !== 'string') {\n        throw 'Anagrams expected string letters, received ' + (typeof letters === 'undefined' ? 'undefined' : _typeof(letters));\n      }\n\n      if (letters.length < PERMS_MIN_LEN) {\n        throw 'getAnagrams expects at least ' + PERMS_MIN_LEN + ' letters';\n      }\n\n      return (0, _permutations2.default)(letters, trie, {\n        type: 'anagram'\n      });\n    },\n\n\n    /**\n    * Get a list of all sub-anagrams that can be made from the given letters\n    * @returns Array\n    */\n    getSubAnagrams: function getSubAnagrams(letters) {\n      if (typeof letters !== 'string') {\n        throw 'Expected string letters, received ' + (typeof letters === 'undefined' ? 'undefined' : _typeof(letters));\n      }\n\n      if (letters.length < PERMS_MIN_LEN) {\n        throw 'getSubAnagrams expects at least ' + PERMS_MIN_LEN + ' letters';\n      }\n\n      return (0, _permutations2.default)(letters, trie, {\n        type: 'sub-anagram'\n      });\n    }\n  };\n};\n\nvar _create = require('./create');\n\nvar _create2 = _interopRequireDefault(_create);\n\nvar _append = require('./append');\n\nvar _append2 = _interopRequireDefault(_append);\n\nvar _checkPrefix5 = require('./checkPrefix');\n\nvar _checkPrefix6 = _interopRequireDefault(_checkPrefix5);\n\nvar _recursePrefix = require('./recursePrefix');\n\nvar _recursePrefix2 = _interopRequireDefault(_recursePrefix);\n\nvar _recurseRandomWord = require('./recurseRandomWord');\n\nvar _recurseRandomWord2 = _interopRequireDefault(_recurseRandomWord);\n\nvar _utils = require('./utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _permutations = require('./permutations');\n\nvar _permutations2 = _interopRequireDefault(_permutations);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar PERMS_MIN_LEN = _config2.default.PERMS_MIN_LEN;\n\n;\nmodule.exports = exports['default'];", "/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n", "'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n", "'use strict'\r\n\r\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n", "module.exports = function isArrayish(obj) {\n\tif (!obj || typeof obj === 'string') {\n\t\treturn false;\n\t}\n\n\treturn obj instanceof Array || Array.isArray(obj) ||\n\t\t(obj.length >= 0 && (obj.splice instanceof Function ||\n\t\t\t(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));\n};\n", "'use strict';\n\nvar isArrayish = require('is-arrayish');\n\nvar concat = Array.prototype.concat;\nvar slice = Array.prototype.slice;\n\nvar swizzle = module.exports = function swizzle(args) {\n\tvar results = [];\n\n\tfor (var i = 0, len = args.length; i < len; i++) {\n\t\tvar arg = args[i];\n\n\t\tif (isArrayish(arg)) {\n\t\t\t// http://jsperf.com/javascript-array-concat-vs-push/98\n\t\t\tresults = concat.call(results, slice.call(arg));\n\t\t} else {\n\t\t\tresults.push(arg);\n\t\t}\n\t}\n\n\treturn results;\n};\n\nswizzle.wrap = function (fn) {\n\treturn function () {\n\t\treturn fn(swizzle(arguments));\n\t};\n};\n", "/* MIT license */\nvar colorNames = require('color-name');\nvar swizzle = require('simple-swizzle');\nvar hasOwnProperty = Object.hasOwnProperty;\n\nvar reverseNames = Object.create(null);\n\n// create a list of reverse color names\nfor (var name in colorNames) {\n\tif (hasOwnProperty.call(colorNames, name)) {\n\t\treverseNames[colorNames[name]] = name;\n\t}\n}\n\nvar cs = module.exports = {\n\tto: {},\n\tget: {}\n};\n\ncs.get = function (string) {\n\tvar prefix = string.substring(0, 3).toLowerCase();\n\tvar val;\n\tvar model;\n\tswitch (prefix) {\n\t\tcase 'hsl':\n\t\t\tval = cs.get.hsl(string);\n\t\t\tmodel = 'hsl';\n\t\t\tbreak;\n\t\tcase 'hwb':\n\t\t\tval = cs.get.hwb(string);\n\t\t\tmodel = 'hwb';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval = cs.get.rgb(string);\n\t\t\tmodel = 'rgb';\n\t\t\tbreak;\n\t}\n\n\tif (!val) {\n\t\treturn null;\n\t}\n\n\treturn {model: model, value: val};\n};\n\ncs.get.rgb = function (string) {\n\tif (!string) {\n\t\treturn null;\n\t}\n\n\tvar abbr = /^#([a-f0-9]{3,4})$/i;\n\tvar hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;\n\tvar rgba = /^rgba?\\(\\s*([+-]?\\d+)(?=[\\s,])\\s*(?:,\\s*)?([+-]?\\d+)(?=[\\s,])\\s*(?:,\\s*)?([+-]?\\d+)\\s*(?:[,|\\/]\\s*([+-]?[\\d\\.]+)(%?)\\s*)?\\)$/;\n\tvar per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,?\\s*([+-]?[\\d\\.]+)\\%\\s*,?\\s*([+-]?[\\d\\.]+)\\%\\s*(?:[,|\\/]\\s*([+-]?[\\d\\.]+)(%?)\\s*)?\\)$/;\n\tvar keyword = /^(\\w+)$/;\n\n\tvar rgb = [0, 0, 0, 1];\n\tvar match;\n\tvar i;\n\tvar hexAlpha;\n\n\tif (match = string.match(hex)) {\n\t\thexAlpha = match[2];\n\t\tmatch = match[1];\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\t// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19\n\t\t\tvar i2 = i * 2;\n\t\t\trgb[i] = parseInt(match.slice(i2, i2 + 2), 16);\n\t\t}\n\n\t\tif (hexAlpha) {\n\t\t\trgb[3] = parseInt(hexAlpha, 16) / 255;\n\t\t}\n\t} else if (match = string.match(abbr)) {\n\t\tmatch = match[1];\n\t\thexAlpha = match[3];\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trgb[i] = parseInt(match[i] + match[i], 16);\n\t\t}\n\n\t\tif (hexAlpha) {\n\t\t\trgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;\n\t\t}\n\t} else if (match = string.match(rgba)) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trgb[i] = parseInt(match[i + 1], 0);\n\t\t}\n\n\t\tif (match[4]) {\n\t\t\tif (match[5]) {\n\t\t\t\trgb[3] = parseFloat(match[4]) * 0.01;\n\t\t\t} else {\n\t\t\t\trgb[3] = parseFloat(match[4]);\n\t\t\t}\n\t\t}\n\t} else if (match = string.match(per)) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\n\t\t}\n\n\t\tif (match[4]) {\n\t\t\tif (match[5]) {\n\t\t\t\trgb[3] = parseFloat(match[4]) * 0.01;\n\t\t\t} else {\n\t\t\t\trgb[3] = parseFloat(match[4]);\n\t\t\t}\n\t\t}\n\t} else if (match = string.match(keyword)) {\n\t\tif (match[1] === 'transparent') {\n\t\t\treturn [0, 0, 0, 0];\n\t\t}\n\n\t\tif (!hasOwnProperty.call(colorNames, match[1])) {\n\t\t\treturn null;\n\t\t}\n\n\t\trgb = colorNames[match[1]];\n\t\trgb[3] = 1;\n\n\t\treturn rgb;\n\t} else {\n\t\treturn null;\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\trgb[i] = clamp(rgb[i], 0, 255);\n\t}\n\trgb[3] = clamp(rgb[3], 0, 1);\n\n\treturn rgb;\n};\n\ncs.get.hsl = function (string) {\n\tif (!string) {\n\t\treturn null;\n\t}\n\n\tvar hsl = /^hsla?\\(\\s*([+-]?(?:\\d{0,3}\\.)?\\d+)(?:deg)?\\s*,?\\s*([+-]?[\\d\\.]+)%\\s*,?\\s*([+-]?[\\d\\.]+)%\\s*(?:[,|\\/]\\s*([+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\s*)?\\)$/;\n\tvar match = string.match(hsl);\n\n\tif (match) {\n\t\tvar alpha = parseFloat(match[4]);\n\t\tvar h = ((parseFloat(match[1]) % 360) + 360) % 360;\n\t\tvar s = clamp(parseFloat(match[2]), 0, 100);\n\t\tvar l = clamp(parseFloat(match[3]), 0, 100);\n\t\tvar a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);\n\n\t\treturn [h, s, l, a];\n\t}\n\n\treturn null;\n};\n\ncs.get.hwb = function (string) {\n\tif (!string) {\n\t\treturn null;\n\t}\n\n\tvar hwb = /^hwb\\(\\s*([+-]?\\d{0,3}(?:\\.\\d+)?)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\s*)?\\)$/;\n\tvar match = string.match(hwb);\n\n\tif (match) {\n\t\tvar alpha = parseFloat(match[4]);\n\t\tvar h = ((parseFloat(match[1]) % 360) + 360) % 360;\n\t\tvar w = clamp(parseFloat(match[2]), 0, 100);\n\t\tvar b = clamp(parseFloat(match[3]), 0, 100);\n\t\tvar a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);\n\t\treturn [h, w, b, a];\n\t}\n\n\treturn null;\n};\n\ncs.to.hex = function () {\n\tvar rgba = swizzle(arguments);\n\n\treturn (\n\t\t'#' +\n\t\thexDouble(rgba[0]) +\n\t\thexDouble(rgba[1]) +\n\t\thexDouble(rgba[2]) +\n\t\t(rgba[3] < 1\n\t\t\t? (hexDouble(Math.round(rgba[3] * 255)))\n\t\t\t: '')\n\t);\n};\n\ncs.to.rgb = function () {\n\tvar rgba = swizzle(arguments);\n\n\treturn rgba.length < 4 || rgba[3] === 1\n\t\t? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'\n\t\t: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';\n};\n\ncs.to.rgb.percent = function () {\n\tvar rgba = swizzle(arguments);\n\n\tvar r = Math.round(rgba[0] / 255 * 100);\n\tvar g = Math.round(rgba[1] / 255 * 100);\n\tvar b = Math.round(rgba[2] / 255 * 100);\n\n\treturn rgba.length < 4 || rgba[3] === 1\n\t\t? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'\n\t\t: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';\n};\n\ncs.to.hsl = function () {\n\tvar hsla = swizzle(arguments);\n\treturn hsla.length < 4 || hsla[3] === 1\n\t\t? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'\n\t\t: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';\n};\n\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\n// (hwb have alpha optional & 1 is default value)\ncs.to.hwb = function () {\n\tvar hwba = swizzle(arguments);\n\n\tvar a = '';\n\tif (hwba.length >= 4 && hwba[3] !== 1) {\n\t\ta = ', ' + hwba[3];\n\t}\n\n\treturn 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';\n};\n\ncs.to.keyword = function (rgb) {\n\treturn reverseNames[rgb.slice(0, 3)];\n};\n\n// helpers\nfunction clamp(num, min, max) {\n\treturn Math.min(Math.max(min, num), max);\n}\n\nfunction hexDouble(num) {\n\tvar str = Math.round(num).toString(16).toUpperCase();\n\treturn (str.length < 2) ? '0' + str : str;\n}\n", "/* MIT license */\n/* eslint-disable no-mixed-operators */\nconst cssKeywords = require('color-name');\n\n// NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\n\nconst reverseKeywords = {};\nfor (const key of Object.keys(cssKeywords)) {\n\treverseKeywords[cssKeywords[key]] = key;\n}\n\nconst convert = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\nmodule.exports = convert;\n\n// Hide .channels and .labels properties\nfor (const model of Object.keys(convert)) {\n\tif (!('channels' in convert[model])) {\n\t\tthrow new Error('missing channels property: ' + model);\n\t}\n\n\tif (!('labels' in convert[model])) {\n\t\tthrow new Error('missing channel labels property: ' + model);\n\t}\n\n\tif (convert[model].labels.length !== convert[model].channels) {\n\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t}\n\n\tconst {channels, labels} = convert[model];\n\tdelete convert[model].channels;\n\tdelete convert[model].labels;\n\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\tObject.defineProperty(convert[model], 'labels', {value: labels});\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst min = Math.min(r, g, b);\n\tconst max = Math.max(r, g, b);\n\tconst delta = max - min;\n\tlet h;\n\tlet s;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst l = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tlet rdif;\n\tlet gdif;\n\tlet bdif;\n\tlet h;\n\tlet s;\n\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst v = Math.max(r, g, b);\n\tconst diff = v - Math.min(r, g, b);\n\tconst diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif (diff === 0) {\n\t\th = 0;\n\t\ts = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t} else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v) {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t} else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tconst r = rgb[0];\n\tconst g = rgb[1];\n\tlet b = rgb[2];\n\tconst h = convert.rgb.hsl(rgb)[0];\n\tconst w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\n\tconst k = Math.min(1 - r, 1 - g, 1 - b);\n\tconst c = (1 - r - k) / (1 - k) || 0;\n\tconst m = (1 - g - k) / (1 - k) || 0;\n\tconst y = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\n\nfunction comparativeDistance(x, y) {\n\t/*\n\t\tSee https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n\t*/\n\treturn (\n\t\t((x[0] - y[0]) ** 2) +\n\t\t((x[1] - y[1]) ** 2) +\n\t\t((x[2] - y[2]) ** 2)\n\t);\n}\n\nconvert.rgb.keyword = function (rgb) {\n\tconst reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\n\tlet currentClosestDistance = Infinity;\n\tlet currentClosestKeyword;\n\n\tfor (const keyword of Object.keys(cssKeywords)) {\n\t\tconst value = cssKeywords[keyword];\n\n\t\t// Compute comparative distance\n\t\tconst distance = comparativeDistance(rgb, value);\n\n\t\t// Check if its less, if so set as closest\n\t\tif (distance < currentClosestDistance) {\n\t\t\tcurrentClosestDistance = distance;\n\t\t\tcurrentClosestKeyword = keyword;\n\t\t}\n\t}\n\n\treturn currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn cssKeywords[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tlet r = rgb[0] / 255;\n\tlet g = rgb[1] / 255;\n\tlet b = rgb[2] / 255;\n\n\t// Assume sRGB\n\tr = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);\n\n\tconst x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tconst y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tconst z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100, z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tconst xyz = convert.rgb.xyz(rgb);\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tconst h = hsl[0] / 360;\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\tlet t2;\n\tlet t3;\n\tlet val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\n\tconst t1 = 2 * l - t2;\n\n\tconst rgb = [0, 0, 0];\n\tfor (let i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv = function (hsl) {\n\tconst h = hsl[0];\n\tlet s = hsl[1] / 100;\n\tlet l = hsl[2] / 100;\n\tlet smin = s;\n\tconst lmin = Math.max(l, 0.01);\n\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tconst v = (l + s) / 2;\n\tconst sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tconst h = hsv[0] / 60;\n\tconst s = hsv[1] / 100;\n\tlet v = hsv[2] / 100;\n\tconst hi = Math.floor(h) % 6;\n\n\tconst f = h - Math.floor(h);\n\tconst p = 255 * v * (1 - s);\n\tconst q = 255 * v * (1 - (s * f));\n\tconst t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl = function (hsv) {\n\tconst h = hsv[0];\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\tconst vmin = Math.max(v, 0.01);\n\tlet sl;\n\tlet l;\n\n\tl = (2 - s) * v;\n\tconst lmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb) {\n\tconst h = hwb[0] / 360;\n\tlet wh = hwb[1] / 100;\n\tlet bl = hwb[2] / 100;\n\tconst ratio = wh + bl;\n\tlet f;\n\n\t// Wh + bl cant be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\tconst i = Math.floor(6 * h);\n\tconst v = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\n\tconst n = wh + f * (v - wh); // Linear interpolation\n\n\tlet r;\n\tlet g;\n\tlet b;\n\t/* eslint-disable max-statements-per-line,no-multi-spaces */\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v;  g = n;  b = wh; break;\n\t\tcase 1: r = n;  g = v;  b = wh; break;\n\t\tcase 2: r = wh; g = v;  b = n; break;\n\t\tcase 3: r = wh; g = n;  b = v; break;\n\t\tcase 4: r = n;  g = wh; b = v; break;\n\t\tcase 5: r = v;  g = wh; b = n; break;\n\t}\n\t/* eslint-enable max-statements-per-line,no-multi-spaces */\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tconst c = cmyk[0] / 100;\n\tconst m = cmyk[1] / 100;\n\tconst y = cmyk[2] / 100;\n\tconst k = cmyk[3] / 100;\n\n\tconst r = 1 - Math.min(1, c * (1 - k) + k);\n\tconst g = 1 - Math.min(1, m * (1 - k) + k);\n\tconst b = 1 - Math.min(1, y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb = function (xyz) {\n\tconst x = xyz[0] / 100;\n\tconst y = xyz[1] / 100;\n\tconst z = xyz[2] / 100;\n\tlet r;\n\tlet g;\n\tlet b;\n\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// Assume sRGB\n\tr = r > 0.0031308\n\t\t? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet x;\n\tlet y;\n\tlet z;\n\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tconst y2 = y ** 3;\n\tconst x2 = x ** 3;\n\tconst z2 = z ** 3;\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet h;\n\n\tconst hr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst c = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab = function (lch) {\n\tconst l = lch[0];\n\tconst c = lch[1];\n\tconst h = lch[2];\n\n\tconst hr = h / 360 * 2 * Math.PI;\n\tconst a = c * Math.cos(hr);\n\tconst b = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function (args, saturation = null) {\n\tconst [r, g, b] = args;\n\tlet value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization\n\n\tvalue = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tlet ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// Optimization here; we already know the value and don't need to get\n\t// it converted for us.\n\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256 = function (args) {\n\tconst r = args[0];\n\tconst g = args[1];\n\tconst b = args[2];\n\n\t// We use the extended greyscale palette here, with the exception of\n\t// black and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tconst ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb = function (args) {\n\tlet color = args % 10;\n\n\t// Handle greyscale\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tconst mult = (~~(args > 50) + 1) * 0.5;\n\tconst r = ((color & 1) * mult) * 255;\n\tconst g = (((color >> 1) & 1) * mult) * 255;\n\tconst b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// Handle greyscale\n\tif (args >= 232) {\n\t\tconst c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs -= 16;\n\n\tlet rem;\n\tconst r = Math.floor(args / 36) / 5 * 255;\n\tconst g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tconst b = (rem % 6) / 5 * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hex = function (args) {\n\tconst integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tconst match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tlet colorString = match[0];\n\n\tif (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(char => {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tconst integer = parseInt(colorString, 16);\n\tconst r = (integer >> 16) & 0xFF;\n\tconst g = (integer >> 8) & 0xFF;\n\tconst b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst max = Math.max(Math.max(r, g), b);\n\tconst min = Math.min(Math.min(r, g), b);\n\tconst chroma = (max - min);\n\tlet grayscale;\n\tlet hue;\n\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function (hsl) {\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\n\tconst c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));\n\n\tlet f = 0;\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\n\tconst c = s * v;\n\tlet f = 0;\n\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f * 100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tconst h = hcg[0] / 360;\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\n\tconst pure = [0, 0, 0];\n\tconst hi = (h % 1) * 6;\n\tconst v = hi % 1;\n\tconst w = 1 - v;\n\tlet mg = 0;\n\n\t/* eslint-disable max-statements-per-line */\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\t/* eslint-enable max-statements-per-line */\n\n\tmg = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst v = c + g * (1.0 - c);\n\tlet f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst l = g * (1.0 - c) + 0.5 * c;\n\tlet s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s * 100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\tconst v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tconst w = hwb[1] / 100;\n\tconst b = hwb[2] / 100;\n\tconst v = 1 - b;\n\tconst c = v - w;\n\tlet g = 0;\n\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\n\nconvert.gray.hsl = function (args) {\n\treturn [0, 0, args[0]];\n};\n\nconvert.gray.hsv = convert.gray.hsl;\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function (gray) {\n\tconst val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tconst integer = (val << 16) + (val << 8) + val;\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function (rgb) {\n\tconst val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n", "const conversions = require('./conversions');\n\n/*\n\tThis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n\tconst graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tconst models = Object.keys(conversions);\n\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tconst graph = buildGraph();\n\tconst queue = [fromModel]; // Unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tconst current = queue.pop();\n\t\tconst adjacents = Object.keys(conversions[current]);\n\n\t\tfor (let len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tconst adjacent = adjacents[i];\n\t\t\tconst node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tconst path = [graph[toModel].parent, toModel];\n\tlet fn = conversions[graph[toModel].parent][toModel];\n\n\tlet cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tconst graph = deriveBFS(fromModel);\n\tconst conversion = {};\n\n\tconst models = Object.keys(graph);\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tconst toModel = models[i];\n\t\tconst node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// No possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n", "const conversions = require('./conversions');\nconst route = require('./route');\n\nconst convert = {};\n\nconst models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\tconst result = fn(args);\n\n\t\t// We're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (let len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(fromModel => {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tconst routes = route(fromModel);\n\tconst routeModels = Object.keys(routes);\n\n\trouteModels.forEach(toModel => {\n\t\tconst fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n", "const colorString = require('color-string');\nconst convert = require('color-convert');\n\nconst skippedModels = [\n\t// To be honest, I don't really feel like keyword belongs in color convert, but eh.\n\t'keyword',\n\n\t// Gray conflicts with some method names, and has its own method defined.\n\t'gray',\n\n\t// Shouldn't really be in color-convert either...\n\t'hex',\n];\n\nconst hashedModelKeys = {};\nfor (const model of Object.keys(convert)) {\n\thashedModelKeys[[...convert[model].labels].sort().join('')] = model;\n}\n\nconst limiters = {};\n\nfunction Color(object, model) {\n\tif (!(this instanceof Color)) {\n\t\treturn new Color(object, model);\n\t}\n\n\tif (model && model in skippedModels) {\n\t\tmodel = null;\n\t}\n\n\tif (model && !(model in convert)) {\n\t\tthrow new Error('Unknown model: ' + model);\n\t}\n\n\tlet i;\n\tlet channels;\n\n\tif (object == null) { // eslint-disable-line no-eq-null,eqeqeq\n\t\tthis.model = 'rgb';\n\t\tthis.color = [0, 0, 0];\n\t\tthis.valpha = 1;\n\t} else if (object instanceof Color) {\n\t\tthis.model = object.model;\n\t\tthis.color = [...object.color];\n\t\tthis.valpha = object.valpha;\n\t} else if (typeof object === 'string') {\n\t\tconst result = colorString.get(object);\n\t\tif (result === null) {\n\t\t\tthrow new Error('Unable to parse color from string: ' + object);\n\t\t}\n\n\t\tthis.model = result.model;\n\t\tchannels = convert[this.model].channels;\n\t\tthis.color = result.value.slice(0, channels);\n\t\tthis.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;\n\t} else if (object.length > 0) {\n\t\tthis.model = model || 'rgb';\n\t\tchannels = convert[this.model].channels;\n\t\tconst newArray = Array.prototype.slice.call(object, 0, channels);\n\t\tthis.color = zeroArray(newArray, channels);\n\t\tthis.valpha = typeof object[channels] === 'number' ? object[channels] : 1;\n\t} else if (typeof object === 'number') {\n\t\t// This is always RGB - can be converted later on.\n\t\tthis.model = 'rgb';\n\t\tthis.color = [\n\t\t\t(object >> 16) & 0xFF,\n\t\t\t(object >> 8) & 0xFF,\n\t\t\tobject & 0xFF,\n\t\t];\n\t\tthis.valpha = 1;\n\t} else {\n\t\tthis.valpha = 1;\n\n\t\tconst keys = Object.keys(object);\n\t\tif ('alpha' in object) {\n\t\t\tkeys.splice(keys.indexOf('alpha'), 1);\n\t\t\tthis.valpha = typeof object.alpha === 'number' ? object.alpha : 0;\n\t\t}\n\n\t\tconst hashedKeys = keys.sort().join('');\n\t\tif (!(hashedKeys in hashedModelKeys)) {\n\t\t\tthrow new Error('Unable to parse color from object: ' + JSON.stringify(object));\n\t\t}\n\n\t\tthis.model = hashedModelKeys[hashedKeys];\n\n\t\tconst {labels} = convert[this.model];\n\t\tconst color = [];\n\t\tfor (i = 0; i < labels.length; i++) {\n\t\t\tcolor.push(object[labels[i]]);\n\t\t}\n\n\t\tthis.color = zeroArray(color);\n\t}\n\n\t// Perform limitations (clamping, etc.)\n\tif (limiters[this.model]) {\n\t\tchannels = convert[this.model].channels;\n\t\tfor (i = 0; i < channels; i++) {\n\t\t\tconst limit = limiters[this.model][i];\n\t\t\tif (limit) {\n\t\t\t\tthis.color[i] = limit(this.color[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.valpha = Math.max(0, Math.min(1, this.valpha));\n\n\tif (Object.freeze) {\n\t\tObject.freeze(this);\n\t}\n}\n\nColor.prototype = {\n\ttoString() {\n\t\treturn this.string();\n\t},\n\n\ttoJSON() {\n\t\treturn this[this.model]();\n\t},\n\n\tstring(places) {\n\t\tlet self = this.model in colorString.to ? this : this.rgb();\n\t\tself = self.round(typeof places === 'number' ? places : 1);\n\t\tconst args = self.valpha === 1 ? self.color : [...self.color, this.valpha];\n\t\treturn colorString.to[self.model](args);\n\t},\n\n\tpercentString(places) {\n\t\tconst self = this.rgb().round(typeof places === 'number' ? places : 1);\n\t\tconst args = self.valpha === 1 ? self.color : [...self.color, this.valpha];\n\t\treturn colorString.to.rgb.percent(args);\n\t},\n\n\tarray() {\n\t\treturn this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];\n\t},\n\n\tobject() {\n\t\tconst result = {};\n\t\tconst {channels} = convert[this.model];\n\t\tconst {labels} = convert[this.model];\n\n\t\tfor (let i = 0; i < channels; i++) {\n\t\t\tresult[labels[i]] = this.color[i];\n\t\t}\n\n\t\tif (this.valpha !== 1) {\n\t\t\tresult.alpha = this.valpha;\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tunitArray() {\n\t\tconst rgb = this.rgb().color;\n\t\trgb[0] /= 255;\n\t\trgb[1] /= 255;\n\t\trgb[2] /= 255;\n\n\t\tif (this.valpha !== 1) {\n\t\t\trgb.push(this.valpha);\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tunitObject() {\n\t\tconst rgb = this.rgb().object();\n\t\trgb.r /= 255;\n\t\trgb.g /= 255;\n\t\trgb.b /= 255;\n\n\t\tif (this.valpha !== 1) {\n\t\t\trgb.alpha = this.valpha;\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tround(places) {\n\t\tplaces = Math.max(places || 0, 0);\n\t\treturn new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);\n\t},\n\n\talpha(value) {\n\t\tif (value !== undefined) {\n\t\t\treturn new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);\n\t\t}\n\n\t\treturn this.valpha;\n\t},\n\n\t// Rgb\n\tred: getset('rgb', 0, maxfn(255)),\n\tgreen: getset('rgb', 1, maxfn(255)),\n\tblue: getset('rgb', 2, maxfn(255)),\n\n\thue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, value => ((value % 360) + 360) % 360),\n\n\tsaturationl: getset('hsl', 1, maxfn(100)),\n\tlightness: getset('hsl', 2, maxfn(100)),\n\n\tsaturationv: getset('hsv', 1, maxfn(100)),\n\tvalue: getset('hsv', 2, maxfn(100)),\n\n\tchroma: getset('hcg', 1, maxfn(100)),\n\tgray: getset('hcg', 2, maxfn(100)),\n\n\twhite: getset('hwb', 1, maxfn(100)),\n\twblack: getset('hwb', 2, maxfn(100)),\n\n\tcyan: getset('cmyk', 0, maxfn(100)),\n\tmagenta: getset('cmyk', 1, maxfn(100)),\n\tyellow: getset('cmyk', 2, maxfn(100)),\n\tblack: getset('cmyk', 3, maxfn(100)),\n\n\tx: getset('xyz', 0, maxfn(95.047)),\n\ty: getset('xyz', 1, maxfn(100)),\n\tz: getset('xyz', 2, maxfn(108.833)),\n\n\tl: getset('lab', 0, maxfn(100)),\n\ta: getset('lab', 1),\n\tb: getset('lab', 2),\n\n\tkeyword(value) {\n\t\tif (value !== undefined) {\n\t\t\treturn new Color(value);\n\t\t}\n\n\t\treturn convert[this.model].keyword(this.color);\n\t},\n\n\thex(value) {\n\t\tif (value !== undefined) {\n\t\t\treturn new Color(value);\n\t\t}\n\n\t\treturn colorString.to.hex(this.rgb().round().color);\n\t},\n\n\thexa(value) {\n\t\tif (value !== undefined) {\n\t\t\treturn new Color(value);\n\t\t}\n\n\t\tconst rgbArray = this.rgb().round().color;\n\n\t\tlet alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();\n\t\tif (alphaHex.length === 1) {\n\t\t\talphaHex = '0' + alphaHex;\n\t\t}\n\n\t\treturn colorString.to.hex(rgbArray) + alphaHex;\n\t},\n\n\trgbNumber() {\n\t\tconst rgb = this.rgb().color;\n\t\treturn ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);\n\t},\n\n\tluminosity() {\n\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\tconst rgb = this.rgb().color;\n\n\t\tconst lum = [];\n\t\tfor (const [i, element] of rgb.entries()) {\n\t\t\tconst chan = element / 255;\n\t\t\tlum[i] = (chan <= 0.04045) ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;\n\t\t}\n\n\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t},\n\n\tcontrast(color2) {\n\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\tconst lum1 = this.luminosity();\n\t\tconst lum2 = color2.luminosity();\n\n\t\tif (lum1 > lum2) {\n\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\n\t\t}\n\n\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t},\n\n\tlevel(color2) {\n\t\t// https://www.w3.org/TR/WCAG/#contrast-enhanced\n\t\tconst contrastRatio = this.contrast(color2);\n\t\tif (contrastRatio >= 7) {\n\t\t\treturn 'AAA';\n\t\t}\n\n\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\n\t},\n\n\tisDark() {\n\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\tconst rgb = this.rgb().color;\n\t\tconst yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 10000;\n\t\treturn yiq < 128;\n\t},\n\n\tisLight() {\n\t\treturn !this.isDark();\n\t},\n\n\tnegate() {\n\t\tconst rgb = this.rgb();\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\trgb.color[i] = 255 - rgb.color[i];\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tlighten(ratio) {\n\t\tconst hsl = this.hsl();\n\t\thsl.color[2] += hsl.color[2] * ratio;\n\t\treturn hsl;\n\t},\n\n\tdarken(ratio) {\n\t\tconst hsl = this.hsl();\n\t\thsl.color[2] -= hsl.color[2] * ratio;\n\t\treturn hsl;\n\t},\n\n\tsaturate(ratio) {\n\t\tconst hsl = this.hsl();\n\t\thsl.color[1] += hsl.color[1] * ratio;\n\t\treturn hsl;\n\t},\n\n\tdesaturate(ratio) {\n\t\tconst hsl = this.hsl();\n\t\thsl.color[1] -= hsl.color[1] * ratio;\n\t\treturn hsl;\n\t},\n\n\twhiten(ratio) {\n\t\tconst hwb = this.hwb();\n\t\thwb.color[1] += hwb.color[1] * ratio;\n\t\treturn hwb;\n\t},\n\n\tblacken(ratio) {\n\t\tconst hwb = this.hwb();\n\t\thwb.color[2] += hwb.color[2] * ratio;\n\t\treturn hwb;\n\t},\n\n\tgrayscale() {\n\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\tconst rgb = this.rgb().color;\n\t\tconst value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\treturn Color.rgb(value, value, value);\n\t},\n\n\tfade(ratio) {\n\t\treturn this.alpha(this.valpha - (this.valpha * ratio));\n\t},\n\n\topaquer(ratio) {\n\t\treturn this.alpha(this.valpha + (this.valpha * ratio));\n\t},\n\n\trotate(degrees) {\n\t\tconst hsl = this.hsl();\n\t\tlet hue = hsl.color[0];\n\t\thue = (hue + degrees) % 360;\n\t\thue = hue < 0 ? 360 + hue : hue;\n\t\thsl.color[0] = hue;\n\t\treturn hsl;\n\t},\n\n\tmix(mixinColor, weight) {\n\t\t// Ported from sass implementation in C\n\t\t// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n\t\tif (!mixinColor || !mixinColor.rgb) {\n\t\t\tthrow new Error('Argument to \"mix\" was not a Color instance, but rather an instance of ' + typeof mixinColor);\n\t\t}\n\n\t\tconst color1 = mixinColor.rgb();\n\t\tconst color2 = this.rgb();\n\t\tconst p = weight === undefined ? 0.5 : weight;\n\n\t\tconst w = 2 * p - 1;\n\t\tconst a = color1.alpha() - color2.alpha();\n\n\t\tconst w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2;\n\t\tconst w2 = 1 - w1;\n\n\t\treturn Color.rgb(\n\t\t\tw1 * color1.red() + w2 * color2.red(),\n\t\t\tw1 * color1.green() + w2 * color2.green(),\n\t\t\tw1 * color1.blue() + w2 * color2.blue(),\n\t\t\tcolor1.alpha() * p + color2.alpha() * (1 - p));\n\t},\n};\n\n// Model conversion methods and static constructors\nfor (const model of Object.keys(convert)) {\n\tif (skippedModels.includes(model)) {\n\t\tcontinue;\n\t}\n\n\tconst {channels} = convert[model];\n\n\t// Conversion methods\n\tColor.prototype[model] = function (...args) {\n\t\tif (this.model === model) {\n\t\t\treturn new Color(this);\n\t\t}\n\n\t\tif (args.length > 0) {\n\t\t\treturn new Color(args, model);\n\t\t}\n\n\t\treturn new Color([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);\n\t};\n\n\t// 'static' construction methods\n\tColor[model] = function (...args) {\n\t\tlet color = args[0];\n\t\tif (typeof color === 'number') {\n\t\t\tcolor = zeroArray(args, channels);\n\t\t}\n\n\t\treturn new Color(color, model);\n\t};\n}\n\nfunction roundTo(number, places) {\n\treturn Number(number.toFixed(places));\n}\n\nfunction roundToPlace(places) {\n\treturn function (number) {\n\t\treturn roundTo(number, places);\n\t};\n}\n\nfunction getset(model, channel, modifier) {\n\tmodel = Array.isArray(model) ? model : [model];\n\n\tfor (const m of model) {\n\t\t(limiters[m] || (limiters[m] = []))[channel] = modifier;\n\t}\n\n\tmodel = model[0];\n\n\treturn function (value) {\n\t\tlet result;\n\n\t\tif (value !== undefined) {\n\t\t\tif (modifier) {\n\t\t\t\tvalue = modifier(value);\n\t\t\t}\n\n\t\t\tresult = this[model]();\n\t\t\tresult.color[channel] = value;\n\t\t\treturn result;\n\t\t}\n\n\t\tresult = this[model]().color[channel];\n\t\tif (modifier) {\n\t\t\tresult = modifier(result);\n\t\t}\n\n\t\treturn result;\n\t};\n}\n\nfunction maxfn(max) {\n\treturn function (v) {\n\t\treturn Math.max(0, Math.min(max, v));\n\t};\n}\n\nfunction assertArray(value) {\n\treturn Array.isArray(value) ? value : [value];\n}\n\nfunction zeroArray(array, length) {\n\tfor (let i = 0; i < length; i++) {\n\t\tif (typeof array[i] !== 'number') {\n\t\t\tarray[i] = 0;\n\t\t}\n\t}\n\n\treturn array;\n}\n\nmodule.exports = Color;\n", "export * from \"./libs/printer\";\nexport * from \"./libs/prettier-plugin-latex\";\n\n// NOTE: The docstring comment must be the last item in the index.ts file!\n/**\n * ## What is this?\n *\n * A [Prettier](https://prettier.io/) plugin for formatting and pretty-printing LaTeX source code.\n *\n * ## When should I use this?\n *\n * If you want to construct a `Prettier` instance that has LaTeX parsing abilities.\n * \n * You should probably use the `prettier-plugin-latex` package instead of directly accessing this package.\n */\n", "var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/document/public.js\nvar public_exports = {};\n__export(public_exports, {\n  builders: () => builders,\n  printer: () => printer,\n  utils: () => utils\n});\n\n// src/document/constants.js\nvar DOC_TYPE_STRING = \"string\";\nvar DOC_TYPE_ARRAY = \"array\";\nvar DOC_TYPE_CURSOR = \"cursor\";\nvar DOC_TYPE_INDENT = \"indent\";\nvar DOC_TYPE_ALIGN = \"align\";\nvar DOC_TYPE_TRIM = \"trim\";\nvar DOC_TYPE_GROUP = \"group\";\nvar DOC_TYPE_FILL = \"fill\";\nvar DOC_TYPE_IF_BREAK = \"if-break\";\nvar DOC_TYPE_INDENT_IF_BREAK = \"indent-if-break\";\nvar DOC_TYPE_LINE_SUFFIX = \"line-suffix\";\nvar DOC_TYPE_LINE_SUFFIX_BOUNDARY = \"line-suffix-boundary\";\nvar DOC_TYPE_LINE = \"line\";\nvar DOC_TYPE_LABEL = \"label\";\nvar DOC_TYPE_BREAK_PARENT = \"break-parent\";\nvar VALID_OBJECT_DOC_TYPES = /* @__PURE__ */ new Set([\n  DOC_TYPE_CURSOR,\n  DOC_TYPE_INDENT,\n  DOC_TYPE_ALIGN,\n  DOC_TYPE_TRIM,\n  DOC_TYPE_GROUP,\n  DOC_TYPE_FILL,\n  DOC_TYPE_IF_BREAK,\n  DOC_TYPE_INDENT_IF_BREAK,\n  DOC_TYPE_LINE_SUFFIX,\n  DOC_TYPE_LINE_SUFFIX_BOUNDARY,\n  DOC_TYPE_LINE,\n  DOC_TYPE_LABEL,\n  DOC_TYPE_BREAK_PARENT\n]);\n\n// src/document/utils/get-doc-type.js\nfunction getDocType(doc) {\n  if (typeof doc === \"string\") {\n    return DOC_TYPE_STRING;\n  }\n  if (Array.isArray(doc)) {\n    return DOC_TYPE_ARRAY;\n  }\n  if (!doc) {\n    return;\n  }\n  const { type } = doc;\n  if (VALID_OBJECT_DOC_TYPES.has(type)) {\n    return type;\n  }\n}\nvar get_doc_type_default = getDocType;\n\n// src/document/invalid-doc-error.js\nvar disjunctionListFormat = (list) => new Intl.ListFormat(\"en-US\", { type: \"disjunction\" }).format(list);\nfunction getDocErrorMessage(doc) {\n  const type = doc === null ? \"null\" : typeof doc;\n  if (type !== \"string\" && type !== \"object\") {\n    return `Unexpected doc '${type}', \nExpected it to be 'string' or 'object'.`;\n  }\n  if (get_doc_type_default(doc)) {\n    throw new Error(\"doc is valid.\");\n  }\n  const objectType = Object.prototype.toString.call(doc);\n  if (objectType !== \"[object Object]\") {\n    return `Unexpected doc '${objectType}'.`;\n  }\n  const EXPECTED_TYPE_VALUES = disjunctionListFormat(\n    [...VALID_OBJECT_DOC_TYPES].map((type2) => `'${type2}'`)\n  );\n  return `Unexpected doc.type '${doc.type}'.\nExpected it to be ${EXPECTED_TYPE_VALUES}.`;\n}\nvar InvalidDocError = class extends Error {\n  name = \"InvalidDocError\";\n  constructor(doc) {\n    super(getDocErrorMessage(doc));\n    this.doc = doc;\n  }\n};\nvar invalid_doc_error_default = InvalidDocError;\n\n// src/document/utils/traverse-doc.js\nvar traverseDocOnExitStackMarker = {};\nfunction traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {\n  const docsStack = [doc];\n  while (docsStack.length > 0) {\n    const doc2 = docsStack.pop();\n    if (doc2 === traverseDocOnExitStackMarker) {\n      onExit(docsStack.pop());\n      continue;\n    }\n    if (onExit) {\n      docsStack.push(doc2, traverseDocOnExitStackMarker);\n    }\n    const docType = get_doc_type_default(doc2);\n    if (!docType) {\n      throw new invalid_doc_error_default(doc2);\n    }\n    if ((onEnter == null ? void 0 : onEnter(doc2)) === false) {\n      continue;\n    }\n    switch (docType) {\n      case DOC_TYPE_ARRAY:\n      case DOC_TYPE_FILL: {\n        const parts = docType === DOC_TYPE_ARRAY ? doc2 : doc2.parts;\n        for (let ic = parts.length, i = ic - 1; i >= 0; --i) {\n          docsStack.push(parts[i]);\n        }\n        break;\n      }\n      case DOC_TYPE_IF_BREAK:\n        docsStack.push(doc2.flatContents, doc2.breakContents);\n        break;\n      case DOC_TYPE_GROUP:\n        if (shouldTraverseConditionalGroups && doc2.expandedStates) {\n          for (let ic = doc2.expandedStates.length, i = ic - 1; i >= 0; --i) {\n            docsStack.push(doc2.expandedStates[i]);\n          }\n        } else {\n          docsStack.push(doc2.contents);\n        }\n        break;\n      case DOC_TYPE_ALIGN:\n      case DOC_TYPE_INDENT:\n      case DOC_TYPE_INDENT_IF_BREAK:\n      case DOC_TYPE_LABEL:\n      case DOC_TYPE_LINE_SUFFIX:\n        docsStack.push(doc2.contents);\n        break;\n      case DOC_TYPE_STRING:\n      case DOC_TYPE_CURSOR:\n      case DOC_TYPE_TRIM:\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n      case DOC_TYPE_LINE:\n      case DOC_TYPE_BREAK_PARENT:\n        break;\n      default:\n        throw new invalid_doc_error_default(doc2);\n    }\n  }\n}\nvar traverse_doc_default = traverseDoc;\n\n// src/document/utils/assert-doc.js\nvar noop = () => {\n};\nvar assertDoc = true ? noop : function(doc) {\n  traverse_doc_default(doc, (doc2) => {\n    if (checked.has(doc2)) {\n      return false;\n    }\n    if (typeof doc2 !== \"string\") {\n      checked.add(doc2);\n    }\n  });\n};\nvar assertDocArray = true ? noop : function(docs, optional = false) {\n  if (optional && !docs) {\n    return;\n  }\n  if (!Array.isArray(docs)) {\n    throw new TypeError(\"Unexpected doc array.\");\n  }\n  for (const doc of docs) {\n    assertDoc(doc);\n  }\n};\n\n// src/document/builders.js\nfunction indent(contents) {\n  assertDoc(contents);\n  return { type: DOC_TYPE_INDENT, contents };\n}\nfunction align(widthOrString, contents) {\n  assertDoc(contents);\n  return { type: DOC_TYPE_ALIGN, contents, n: widthOrString };\n}\nfunction group(contents, opts = {}) {\n  assertDoc(contents);\n  assertDocArray(\n    opts.expandedStates,\n    /* optional */\n    true\n  );\n  return {\n    type: DOC_TYPE_GROUP,\n    id: opts.id,\n    contents,\n    break: Boolean(opts.shouldBreak),\n    expandedStates: opts.expandedStates\n  };\n}\nfunction dedentToRoot(contents) {\n  return align(Number.NEGATIVE_INFINITY, contents);\n}\nfunction markAsRoot(contents) {\n  return align({ type: \"root\" }, contents);\n}\nfunction dedent(contents) {\n  return align(-1, contents);\n}\nfunction conditionalGroup(states, opts) {\n  return group(states[0], { ...opts, expandedStates: states });\n}\nfunction fill(parts) {\n  assertDocArray(parts);\n  return { type: DOC_TYPE_FILL, parts };\n}\nfunction ifBreak(breakContents, flatContents = \"\", opts = {}) {\n  assertDoc(breakContents);\n  if (flatContents !== \"\") {\n    assertDoc(flatContents);\n  }\n  return {\n    type: DOC_TYPE_IF_BREAK,\n    breakContents,\n    flatContents,\n    groupId: opts.groupId\n  };\n}\nfunction indentIfBreak(contents, opts) {\n  assertDoc(contents);\n  return {\n    type: DOC_TYPE_INDENT_IF_BREAK,\n    contents,\n    groupId: opts.groupId,\n    negate: opts.negate\n  };\n}\nfunction lineSuffix(contents) {\n  assertDoc(contents);\n  return { type: DOC_TYPE_LINE_SUFFIX, contents };\n}\nvar lineSuffixBoundary = { type: DOC_TYPE_LINE_SUFFIX_BOUNDARY };\nvar breakParent = { type: DOC_TYPE_BREAK_PARENT };\nvar trim = { type: DOC_TYPE_TRIM };\nvar hardlineWithoutBreakParent = { type: DOC_TYPE_LINE, hard: true };\nvar literallineWithoutBreakParent = {\n  type: DOC_TYPE_LINE,\n  hard: true,\n  literal: true\n};\nvar line = { type: DOC_TYPE_LINE };\nvar softline = { type: DOC_TYPE_LINE, soft: true };\nvar hardline = [hardlineWithoutBreakParent, breakParent];\nvar literalline = [literallineWithoutBreakParent, breakParent];\nvar cursor = { type: DOC_TYPE_CURSOR };\nfunction join(separator, docs) {\n  assertDoc(separator);\n  assertDocArray(docs);\n  const parts = [];\n  for (let i = 0; i < docs.length; i++) {\n    if (i !== 0) {\n      parts.push(separator);\n    }\n    parts.push(docs[i]);\n  }\n  return parts;\n}\nfunction addAlignmentToDoc(doc, size, tabWidth) {\n  assertDoc(doc);\n  let aligned = doc;\n  if (size > 0) {\n    for (let i = 0; i < Math.floor(size / tabWidth); ++i) {\n      aligned = indent(aligned);\n    }\n    aligned = align(size % tabWidth, aligned);\n    aligned = align(Number.NEGATIVE_INFINITY, aligned);\n  }\n  return aligned;\n}\nfunction label(label2, contents) {\n  assertDoc(contents);\n  return label2 ? { type: DOC_TYPE_LABEL, label: label2, contents } : contents;\n}\n\n// scripts/build/shims/at.js\nvar at = (isOptionalObject, object, index) => {\n  if (isOptionalObject && (object === void 0 || object === null)) {\n    return;\n  }\n  if (Array.isArray(object) || typeof object === \"string\") {\n    return object[index < 0 ? object.length + index : index];\n  }\n  return object.at(index);\n};\nvar at_default = at;\n\n// scripts/build/shims/string-replace-all.js\nvar stringReplaceAll = (isOptionalObject, original, pattern, replacement) => {\n  if (isOptionalObject && (original === void 0 || original === null)) {\n    return;\n  }\n  if (original.replaceAll) {\n    return original.replaceAll(pattern, replacement);\n  }\n  if (pattern.global) {\n    return original.replace(pattern, replacement);\n  }\n  return original.split(pattern).join(replacement);\n};\nvar string_replace_all_default = stringReplaceAll;\n\n// src/common/end-of-line.js\nfunction convertEndOfLineToChars(value) {\n  switch (value) {\n    case \"cr\":\n      return \"\\r\";\n    case \"crlf\":\n      return \"\\r\\n\";\n    default:\n      return \"\\n\";\n  }\n}\n\n// node_modules/emoji-regex/index.mjs\nvar emoji_regex_default = () => {\n  return /[#*0-9]\\uFE0F?\\u20E3|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26AA\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C8\\u26CF\\u26D1\\u26D3\\u26E9\\u26F0-\\u26F5\\u26F7\\u26F8\\u26FA\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2757\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B55\\u3030\\u303D\\u3297\\u3299]\\uFE0F?|[\\u261D\\u270C\\u270D](?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?|[\\u270A\\u270B](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u2693\\u26A1\\u26AB\\u26C5\\u26CE\\u26D4\\u26EA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2795-\\u2797\\u27B0\\u27BF\\u2B50]|\\u26F9(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\u2764\\uFE0F?(?:\\u200D(?:\\uD83D\\uDD25|\\uD83E\\uDE79))?|\\uD83C(?:[\\uDC04\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDE02\\uDE37\\uDF21\\uDF24-\\uDF2C\\uDF36\\uDF7D\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E\\uDF9F\\uDFCD\\uDFCE\\uDFD4-\\uDFDF\\uDFF5\\uDFF7]\\uFE0F?|[\\uDF85\\uDFC2\\uDFC7](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDFC3\\uDFC4\\uDFCA](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDFCB\\uDFCC](?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF84\\uDF86-\\uDF93\\uDFA0-\\uDFC1\\uDFC5\\uDFC6\\uDFC8\\uDFC9\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF8-\\uDFFF]|\\uDDE6\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF]|\\uDDE7\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF]|\\uDDE8\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF]|\\uDDE9\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF]|\\uDDEA\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA]|\\uDDEB\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7]|\\uDDEC\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE]|\\uDDED\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA]|\\uDDEE\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9]|\\uDDEF\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5]|\\uDDF0\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF]|\\uDDF1\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE]|\\uDDF2\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF]|\\uDDF3\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF]|\\uDDF4\\uD83C\\uDDF2|\\uDDF5\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE]|\\uDDF6\\uD83C\\uDDE6|\\uDDF7\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC]|\\uDDF8\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF]|\\uDDF9\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF]|\\uDDFA\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF]|\\uDDFB\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA]|\\uDDFC\\uD83C[\\uDDEB\\uDDF8]|\\uDDFD\\uD83C\\uDDF0|\\uDDFE\\uD83C[\\uDDEA\\uDDF9]|\\uDDFF\\uD83C[\\uDDE6\\uDDF2\\uDDFC]|\\uDFF3\\uFE0F?(?:\\u200D(?:\\u26A7\\uFE0F?|\\uD83C\\uDF08))?|\\uDFF4(?:\\u200D\\u2620\\uFE0F?|\\uDB40\\uDC67\\uDB40\\uDC62\\uDB40(?:\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73)\\uDB40\\uDC7F)?)|\\uD83D(?:[\\uDC08\\uDC26](?:\\u200D\\u2B1B)?|[\\uDC3F\\uDCFD\\uDD49\\uDD4A\\uDD6F\\uDD70\\uDD73\\uDD76-\\uDD79\\uDD87\\uDD8A-\\uDD8D\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA\\uDECB\\uDECD-\\uDECF\\uDEE0-\\uDEE5\\uDEE9\\uDEF0\\uDEF3]\\uFE0F?|[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDD74\\uDD90](?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDC00-\\uDC07\\uDC09-\\uDC14\\uDC16-\\uDC25\\uDC27-\\uDC3A\\uDC3C-\\uDC3E\\uDC40\\uDC44\\uDC45\\uDC51-\\uDC65\\uDC6A\\uDC79-\\uDC7B\\uDC7D-\\uDC80\\uDC84\\uDC88-\\uDC8E\\uDC90\\uDC92-\\uDCA9\\uDCAB-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDDA4\\uDDFB-\\uDE2D\\uDE2F-\\uDE34\\uDE37-\\uDE44\\uDE48-\\uDE4A\\uDE80-\\uDEA2\\uDEA4-\\uDEB3\\uDEB7-\\uDEBF\\uDEC1-\\uDEC5\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEDC-\\uDEDF\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB\\uDFF0]|\\uDC15(?:\\u200D\\uD83E\\uDDBA)?|\\uDC3B(?:\\u200D\\u2744\\uFE0F?)?|\\uDC41\\uFE0F?(?:\\u200D\\uD83D\\uDDE8\\uFE0F?)?|\\uDC68(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDC68\\uDC69]\\u200D\\uD83D(?:\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?)|[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?)|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFC-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB-\\uDFFE])))?))?|\\uDC69(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?[\\uDC68\\uDC69]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?|\\uDC69\\u200D\\uD83D(?:\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?))|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFC-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB-\\uDFFE])))?))?|\\uDC6F(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\uDD75(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\uDE2E(?:\\u200D\\uD83D\\uDCA8)?|\\uDE35(?:\\u200D\\uD83D\\uDCAB)?|\\uDE36(?:\\u200D\\uD83C\\uDF2B\\uFE0F?)?)|\\uD83E(?:[\\uDD0C\\uDD0F\\uDD18-\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5\\uDEC3-\\uDEC5\\uDEF0\\uDEF2-\\uDEF8](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDDDE\\uDDDF](?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDD0D\\uDD0E\\uDD10-\\uDD17\\uDD20-\\uDD25\\uDD27-\\uDD2F\\uDD3A\\uDD3F-\\uDD45\\uDD47-\\uDD76\\uDD78-\\uDDB4\\uDDB7\\uDDBA\\uDDBC-\\uDDCC\\uDDD0\\uDDE0-\\uDDFF\\uDE70-\\uDE7C\\uDE80-\\uDE88\\uDE90-\\uDEBD\\uDEBF-\\uDEC2\\uDECE-\\uDEDB\\uDEE0-\\uDEE8]|\\uDD3C(?:\\u200D[\\u2640\\u2642]\\uFE0F?|\\uD83C[\\uDFFB-\\uDFFF])?|\\uDDD1(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83E\\uDDD1))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFC-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFD-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFD\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFE]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?))?|\\uDEF1(?:\\uD83C(?:\\uDFFB(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFC-\\uDFFF])?|\\uDFFC(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])?|\\uDFFD(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])?|\\uDFFE(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])?|\\uDFFF(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB-\\uDFFE])?))?)/g;\n};\n\n// node_modules/eastasianwidth/eastasianwidth.js\nvar eastasianwidth_default = {\n  eastAsianWidth(character) {\n    var x = character.charCodeAt(0);\n    var y = character.length == 2 ? character.charCodeAt(1) : 0;\n    var codePoint = x;\n    if (55296 <= x && x <= 56319 && 56320 <= y && y <= 57343) {\n      x &= 1023;\n      y &= 1023;\n      codePoint = x << 10 | y;\n      codePoint += 65536;\n    }\n    if (12288 == codePoint || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510) {\n      return \"F\";\n    }\n    if (4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141) {\n      return \"W\";\n    }\n    return \"N\";\n  }\n};\n\n// src/utils/get-string-width.js\nvar notAsciiRegex = /[^\\x20-\\x7F]/;\nfunction getStringWidth(text) {\n  if (!text) {\n    return 0;\n  }\n  if (!notAsciiRegex.test(text)) {\n    return text.length;\n  }\n  text = text.replace(emoji_regex_default(), \"  \");\n  let width = 0;\n  for (const character of text) {\n    const codePoint = character.codePointAt(0);\n    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {\n      continue;\n    }\n    if (codePoint >= 768 && codePoint <= 879) {\n      continue;\n    }\n    const code = eastasianwidth_default.eastAsianWidth(character);\n    width += code === \"F\" || code === \"W\" ? 2 : 1;\n  }\n  return width;\n}\nvar get_string_width_default = getStringWidth;\n\n// src/document/utils.js\nvar getDocParts = (doc) => {\n  if (Array.isArray(doc)) {\n    return doc;\n  }\n  if (doc.type !== DOC_TYPE_FILL) {\n    throw new Error(`Expect doc to be 'array' or '${DOC_TYPE_FILL}'.`);\n  }\n  return doc.parts;\n};\nfunction mapDoc(doc, cb) {\n  if (typeof doc === \"string\") {\n    return cb(doc);\n  }\n  const mapped = /* @__PURE__ */ new Map();\n  return rec(doc);\n  function rec(doc2) {\n    if (mapped.has(doc2)) {\n      return mapped.get(doc2);\n    }\n    const result = process2(doc2);\n    mapped.set(doc2, result);\n    return result;\n  }\n  function process2(doc2) {\n    switch (get_doc_type_default(doc2)) {\n      case DOC_TYPE_ARRAY:\n        return cb(doc2.map(rec));\n      case DOC_TYPE_FILL:\n        return cb({\n          ...doc2,\n          parts: doc2.parts.map(rec)\n        });\n      case DOC_TYPE_IF_BREAK:\n        return cb({\n          ...doc2,\n          breakContents: rec(doc2.breakContents),\n          flatContents: rec(doc2.flatContents)\n        });\n      case DOC_TYPE_GROUP: {\n        let {\n          expandedStates,\n          contents\n        } = doc2;\n        if (expandedStates) {\n          expandedStates = expandedStates.map(rec);\n          contents = expandedStates[0];\n        } else {\n          contents = rec(contents);\n        }\n        return cb({\n          ...doc2,\n          contents,\n          expandedStates\n        });\n      }\n      case DOC_TYPE_ALIGN:\n      case DOC_TYPE_INDENT:\n      case DOC_TYPE_INDENT_IF_BREAK:\n      case DOC_TYPE_LABEL:\n      case DOC_TYPE_LINE_SUFFIX:\n        return cb({\n          ...doc2,\n          contents: rec(doc2.contents)\n        });\n      case DOC_TYPE_STRING:\n      case DOC_TYPE_CURSOR:\n      case DOC_TYPE_TRIM:\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n      case DOC_TYPE_LINE:\n      case DOC_TYPE_BREAK_PARENT:\n        return cb(doc2);\n      default:\n        throw new invalid_doc_error_default(doc2);\n    }\n  }\n}\nfunction findInDoc(doc, fn, defaultValue) {\n  let result = defaultValue;\n  let shouldSkipFurtherProcessing = false;\n  function findInDocOnEnterFn(doc2) {\n    if (shouldSkipFurtherProcessing) {\n      return false;\n    }\n    const maybeResult = fn(doc2);\n    if (maybeResult !== void 0) {\n      shouldSkipFurtherProcessing = true;\n      result = maybeResult;\n    }\n  }\n  traverse_doc_default(doc, findInDocOnEnterFn);\n  return result;\n}\nfunction willBreakFn(doc) {\n  if (doc.type === DOC_TYPE_GROUP && doc.break) {\n    return true;\n  }\n  if (doc.type === DOC_TYPE_LINE && doc.hard) {\n    return true;\n  }\n  if (doc.type === DOC_TYPE_BREAK_PARENT) {\n    return true;\n  }\n}\nfunction willBreak(doc) {\n  return findInDoc(doc, willBreakFn, false);\n}\nfunction breakParentGroup(groupStack) {\n  if (groupStack.length > 0) {\n    const parentGroup = at_default(\n      /* isOptionalObject*/\n      false,\n      groupStack,\n      -1\n    );\n    if (!parentGroup.expandedStates && !parentGroup.break) {\n      parentGroup.break = \"propagated\";\n    }\n  }\n  return null;\n}\nfunction propagateBreaks(doc) {\n  const alreadyVisitedSet = /* @__PURE__ */ new Set();\n  const groupStack = [];\n  function propagateBreaksOnEnterFn(doc2) {\n    if (doc2.type === DOC_TYPE_BREAK_PARENT) {\n      breakParentGroup(groupStack);\n    }\n    if (doc2.type === DOC_TYPE_GROUP) {\n      groupStack.push(doc2);\n      if (alreadyVisitedSet.has(doc2)) {\n        return false;\n      }\n      alreadyVisitedSet.add(doc2);\n    }\n  }\n  function propagateBreaksOnExitFn(doc2) {\n    if (doc2.type === DOC_TYPE_GROUP) {\n      const group2 = groupStack.pop();\n      if (group2.break) {\n        breakParentGroup(groupStack);\n      }\n    }\n  }\n  traverse_doc_default(\n    doc,\n    propagateBreaksOnEnterFn,\n    propagateBreaksOnExitFn,\n    /* shouldTraverseConditionalGroups */\n    true\n  );\n}\nfunction removeLinesFn(doc) {\n  if (doc.type === DOC_TYPE_LINE && !doc.hard) {\n    return doc.soft ? \"\" : \" \";\n  }\n  if (doc.type === DOC_TYPE_IF_BREAK) {\n    return doc.flatContents;\n  }\n  return doc;\n}\nfunction removeLines(doc) {\n  return mapDoc(doc, removeLinesFn);\n}\nfunction stripTrailingHardlineFromParts(parts) {\n  parts = [...parts];\n  while (parts.length >= 2 && at_default(\n    /* isOptionalObject*/\n    false,\n    parts,\n    -2\n  ).type === DOC_TYPE_LINE && at_default(\n    /* isOptionalObject*/\n    false,\n    parts,\n    -1\n  ).type === DOC_TYPE_BREAK_PARENT) {\n    parts.length -= 2;\n  }\n  if (parts.length > 0) {\n    const lastPart = stripTrailingHardlineFromDoc(at_default(\n      /* isOptionalObject*/\n      false,\n      parts,\n      -1\n    ));\n    parts[parts.length - 1] = lastPart;\n  }\n  return parts;\n}\nfunction stripTrailingHardlineFromDoc(doc) {\n  switch (get_doc_type_default(doc)) {\n    case DOC_TYPE_ALIGN:\n    case DOC_TYPE_INDENT:\n    case DOC_TYPE_INDENT_IF_BREAK:\n    case DOC_TYPE_GROUP:\n    case DOC_TYPE_LINE_SUFFIX:\n    case DOC_TYPE_LABEL: {\n      const contents = stripTrailingHardlineFromDoc(doc.contents);\n      return {\n        ...doc,\n        contents\n      };\n    }\n    case DOC_TYPE_IF_BREAK:\n      return {\n        ...doc,\n        breakContents: stripTrailingHardlineFromDoc(doc.breakContents),\n        flatContents: stripTrailingHardlineFromDoc(doc.flatContents)\n      };\n    case DOC_TYPE_FILL:\n      return {\n        ...doc,\n        parts: stripTrailingHardlineFromParts(doc.parts)\n      };\n    case DOC_TYPE_ARRAY:\n      return stripTrailingHardlineFromParts(doc);\n    case DOC_TYPE_STRING:\n      return doc.replace(/[\\n\\r]*$/, \"\");\n    case DOC_TYPE_CURSOR:\n    case DOC_TYPE_TRIM:\n    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n    case DOC_TYPE_LINE:\n    case DOC_TYPE_BREAK_PARENT:\n      break;\n    default:\n      throw new invalid_doc_error_default(doc);\n  }\n  return doc;\n}\nfunction stripTrailingHardline(doc) {\n  return stripTrailingHardlineFromDoc(cleanDoc(doc));\n}\nfunction cleanDocFn(doc) {\n  switch (get_doc_type_default(doc)) {\n    case DOC_TYPE_FILL:\n      if (doc.parts.every((part) => part === \"\")) {\n        return \"\";\n      }\n      break;\n    case DOC_TYPE_GROUP:\n      if (!doc.contents && !doc.id && !doc.break && !doc.expandedStates) {\n        return \"\";\n      }\n      if (doc.contents.type === DOC_TYPE_GROUP && doc.contents.id === doc.id && doc.contents.break === doc.break && doc.contents.expandedStates === doc.expandedStates) {\n        return doc.contents;\n      }\n      break;\n    case DOC_TYPE_ALIGN:\n    case DOC_TYPE_INDENT:\n    case DOC_TYPE_INDENT_IF_BREAK:\n    case DOC_TYPE_LINE_SUFFIX:\n      if (!doc.contents) {\n        return \"\";\n      }\n      break;\n    case DOC_TYPE_IF_BREAK:\n      if (!doc.flatContents && !doc.breakContents) {\n        return \"\";\n      }\n      break;\n    case DOC_TYPE_ARRAY: {\n      const parts = [];\n      for (const part of doc) {\n        if (!part) {\n          continue;\n        }\n        const [currentPart, ...restParts] = Array.isArray(part) ? part : [part];\n        if (typeof currentPart === \"string\" && typeof at_default(\n          /* isOptionalObject*/\n          false,\n          parts,\n          -1\n        ) === \"string\") {\n          parts[parts.length - 1] += currentPart;\n        } else {\n          parts.push(currentPart);\n        }\n        parts.push(...restParts);\n      }\n      if (parts.length === 0) {\n        return \"\";\n      }\n      if (parts.length === 1) {\n        return parts[0];\n      }\n      return parts;\n    }\n    case DOC_TYPE_STRING:\n    case DOC_TYPE_CURSOR:\n    case DOC_TYPE_TRIM:\n    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n    case DOC_TYPE_LINE:\n    case DOC_TYPE_LABEL:\n    case DOC_TYPE_BREAK_PARENT:\n      break;\n    default:\n      throw new invalid_doc_error_default(doc);\n  }\n  return doc;\n}\nfunction cleanDoc(doc) {\n  return mapDoc(doc, (currentDoc) => cleanDocFn(currentDoc));\n}\nfunction replaceEndOfLine(doc, replacement = literalline) {\n  return mapDoc(doc, (currentDoc) => typeof currentDoc === \"string\" ? join(replacement, currentDoc.split(\"\\n\")) : currentDoc);\n}\nfunction canBreakFn(doc) {\n  if (doc.type === DOC_TYPE_LINE) {\n    return true;\n  }\n}\nfunction canBreak(doc) {\n  return findInDoc(doc, canBreakFn, false);\n}\n\n// src/document/printer.js\nvar MODE_BREAK = Symbol(\"MODE_BREAK\");\nvar MODE_FLAT = Symbol(\"MODE_FLAT\");\nvar CURSOR_PLACEHOLDER = Symbol(\"cursor\");\nfunction rootIndent() {\n  return {\n    value: \"\",\n    length: 0,\n    queue: []\n  };\n}\nfunction makeIndent(ind, options) {\n  return generateInd(ind, {\n    type: \"indent\"\n  }, options);\n}\nfunction makeAlign(indent2, widthOrDoc, options) {\n  if (widthOrDoc === Number.NEGATIVE_INFINITY) {\n    return indent2.root || rootIndent();\n  }\n  if (widthOrDoc < 0) {\n    return generateInd(indent2, {\n      type: \"dedent\"\n    }, options);\n  }\n  if (!widthOrDoc) {\n    return indent2;\n  }\n  if (widthOrDoc.type === \"root\") {\n    return {\n      ...indent2,\n      root: indent2\n    };\n  }\n  const alignType = typeof widthOrDoc === \"string\" ? \"stringAlign\" : \"numberAlign\";\n  return generateInd(indent2, {\n    type: alignType,\n    n: widthOrDoc\n  }, options);\n}\nfunction generateInd(ind, newPart, options) {\n  const queue = newPart.type === \"dedent\" ? ind.queue.slice(0, -1) : [...ind.queue, newPart];\n  let value = \"\";\n  let length = 0;\n  let lastTabs = 0;\n  let lastSpaces = 0;\n  for (const part of queue) {\n    switch (part.type) {\n      case \"indent\":\n        flush();\n        if (options.useTabs) {\n          addTabs(1);\n        } else {\n          addSpaces(options.tabWidth);\n        }\n        break;\n      case \"stringAlign\":\n        flush();\n        value += part.n;\n        length += part.n.length;\n        break;\n      case \"numberAlign\":\n        lastTabs += 1;\n        lastSpaces += part.n;\n        break;\n      default:\n        throw new Error(`Unexpected type '${part.type}'`);\n    }\n  }\n  flushSpaces();\n  return {\n    ...ind,\n    value,\n    length,\n    queue\n  };\n  function addTabs(count) {\n    value += \"\t\".repeat(count);\n    length += options.tabWidth * count;\n  }\n  function addSpaces(count) {\n    value += \" \".repeat(count);\n    length += count;\n  }\n  function flush() {\n    if (options.useTabs) {\n      flushTabs();\n    } else {\n      flushSpaces();\n    }\n  }\n  function flushTabs() {\n    if (lastTabs > 0) {\n      addTabs(lastTabs);\n    }\n    resetLast();\n  }\n  function flushSpaces() {\n    if (lastSpaces > 0) {\n      addSpaces(lastSpaces);\n    }\n    resetLast();\n  }\n  function resetLast() {\n    lastTabs = 0;\n    lastSpaces = 0;\n  }\n}\nfunction trim2(out) {\n  let trimCount = 0;\n  let cursorCount = 0;\n  let outIndex = out.length;\n  outer:\n    while (outIndex--) {\n      const last = out[outIndex];\n      if (last === CURSOR_PLACEHOLDER) {\n        cursorCount++;\n        continue;\n      }\n      if (false) {\n        throw new Error(`Unexpected value in trim: '${typeof last}'`);\n      }\n      for (let charIndex = last.length - 1; charIndex >= 0; charIndex--) {\n        const char = last[charIndex];\n        if (char === \" \" || char === \"\t\") {\n          trimCount++;\n        } else {\n          out[outIndex] = last.slice(0, charIndex + 1);\n          break outer;\n        }\n      }\n    }\n  if (trimCount > 0 || cursorCount > 0) {\n    out.length = outIndex + 1;\n    while (cursorCount-- > 0) {\n      out.push(CURSOR_PLACEHOLDER);\n    }\n  }\n  return trimCount;\n}\nfunction fits(next, restCommands, width, hasLineSuffix, groupModeMap, mustBeFlat) {\n  if (width === Number.POSITIVE_INFINITY) {\n    return true;\n  }\n  let restIdx = restCommands.length;\n  const cmds = [next];\n  const out = [];\n  while (width >= 0) {\n    if (cmds.length === 0) {\n      if (restIdx === 0) {\n        return true;\n      }\n      cmds.push(restCommands[--restIdx]);\n      continue;\n    }\n    const {\n      mode,\n      doc\n    } = cmds.pop();\n    switch (get_doc_type_default(doc)) {\n      case DOC_TYPE_STRING:\n        out.push(doc);\n        width -= get_string_width_default(doc);\n        break;\n      case DOC_TYPE_ARRAY:\n      case DOC_TYPE_FILL: {\n        const parts = getDocParts(doc);\n        for (let i = parts.length - 1; i >= 0; i--) {\n          cmds.push({\n            mode,\n            doc: parts[i]\n          });\n        }\n        break;\n      }\n      case DOC_TYPE_INDENT:\n      case DOC_TYPE_ALIGN:\n      case DOC_TYPE_INDENT_IF_BREAK:\n      case DOC_TYPE_LABEL:\n        cmds.push({\n          mode,\n          doc: doc.contents\n        });\n        break;\n      case DOC_TYPE_TRIM:\n        width += trim2(out);\n        break;\n      case DOC_TYPE_GROUP: {\n        if (mustBeFlat && doc.break) {\n          return false;\n        }\n        const groupMode = doc.break ? MODE_BREAK : mode;\n        const contents = doc.expandedStates && groupMode === MODE_BREAK ? at_default(\n          /* isOptionalObject*/\n          false,\n          doc.expandedStates,\n          -1\n        ) : doc.contents;\n        cmds.push({\n          mode: groupMode,\n          doc: contents\n        });\n        break;\n      }\n      case DOC_TYPE_IF_BREAK: {\n        const groupMode = doc.groupId ? groupModeMap[doc.groupId] || MODE_FLAT : mode;\n        const contents = groupMode === MODE_BREAK ? doc.breakContents : doc.flatContents;\n        if (contents) {\n          cmds.push({\n            mode,\n            doc: contents\n          });\n        }\n        break;\n      }\n      case DOC_TYPE_LINE:\n        if (mode === MODE_BREAK || doc.hard) {\n          return true;\n        }\n        if (!doc.soft) {\n          out.push(\" \");\n          width--;\n        }\n        break;\n      case DOC_TYPE_LINE_SUFFIX:\n        hasLineSuffix = true;\n        break;\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n        if (hasLineSuffix) {\n          return false;\n        }\n        break;\n    }\n  }\n  return false;\n}\nfunction printDocToString(doc, options) {\n  const groupModeMap = {};\n  const width = options.printWidth;\n  const newLine = convertEndOfLineToChars(options.endOfLine);\n  let pos = 0;\n  const cmds = [{\n    ind: rootIndent(),\n    mode: MODE_BREAK,\n    doc\n  }];\n  const out = [];\n  let shouldRemeasure = false;\n  const lineSuffix2 = [];\n  let printedCursorCount = 0;\n  propagateBreaks(doc);\n  while (cmds.length > 0) {\n    const {\n      ind,\n      mode,\n      doc: doc2\n    } = cmds.pop();\n    switch (get_doc_type_default(doc2)) {\n      case DOC_TYPE_STRING: {\n        const formatted = newLine !== \"\\n\" ? string_replace_all_default(\n          /* isOptionalObject*/\n          false,\n          doc2,\n          \"\\n\",\n          newLine\n        ) : doc2;\n        out.push(formatted);\n        if (cmds.length > 0) {\n          pos += get_string_width_default(formatted);\n        }\n        break;\n      }\n      case DOC_TYPE_ARRAY:\n        for (let i = doc2.length - 1; i >= 0; i--) {\n          cmds.push({\n            ind,\n            mode,\n            doc: doc2[i]\n          });\n        }\n        break;\n      case DOC_TYPE_CURSOR:\n        if (printedCursorCount >= 2) {\n          throw new Error(\"There are too many 'cursor' in doc.\");\n        }\n        out.push(CURSOR_PLACEHOLDER);\n        printedCursorCount++;\n        break;\n      case DOC_TYPE_INDENT:\n        cmds.push({\n          ind: makeIndent(ind, options),\n          mode,\n          doc: doc2.contents\n        });\n        break;\n      case DOC_TYPE_ALIGN:\n        cmds.push({\n          ind: makeAlign(ind, doc2.n, options),\n          mode,\n          doc: doc2.contents\n        });\n        break;\n      case DOC_TYPE_TRIM:\n        pos -= trim2(out);\n        break;\n      case DOC_TYPE_GROUP:\n        switch (mode) {\n          case MODE_FLAT:\n            if (!shouldRemeasure) {\n              cmds.push({\n                ind,\n                mode: doc2.break ? MODE_BREAK : MODE_FLAT,\n                doc: doc2.contents\n              });\n              break;\n            }\n          case MODE_BREAK: {\n            shouldRemeasure = false;\n            const next = {\n              ind,\n              mode: MODE_FLAT,\n              doc: doc2.contents\n            };\n            const rem = width - pos;\n            const hasLineSuffix = lineSuffix2.length > 0;\n            if (!doc2.break && fits(next, cmds, rem, hasLineSuffix, groupModeMap)) {\n              cmds.push(next);\n            } else {\n              if (doc2.expandedStates) {\n                const mostExpanded = at_default(\n                  /* isOptionalObject*/\n                  false,\n                  doc2.expandedStates,\n                  -1\n                );\n                if (doc2.break) {\n                  cmds.push({\n                    ind,\n                    mode: MODE_BREAK,\n                    doc: mostExpanded\n                  });\n                  break;\n                } else {\n                  for (let i = 1; i < doc2.expandedStates.length + 1; i++) {\n                    if (i >= doc2.expandedStates.length) {\n                      cmds.push({\n                        ind,\n                        mode: MODE_BREAK,\n                        doc: mostExpanded\n                      });\n                      break;\n                    } else {\n                      const state = doc2.expandedStates[i];\n                      const cmd = {\n                        ind,\n                        mode: MODE_FLAT,\n                        doc: state\n                      };\n                      if (fits(cmd, cmds, rem, hasLineSuffix, groupModeMap)) {\n                        cmds.push(cmd);\n                        break;\n                      }\n                    }\n                  }\n                }\n              } else {\n                cmds.push({\n                  ind,\n                  mode: MODE_BREAK,\n                  doc: doc2.contents\n                });\n              }\n            }\n            break;\n          }\n        }\n        if (doc2.id) {\n          groupModeMap[doc2.id] = at_default(\n            /* isOptionalObject*/\n            false,\n            cmds,\n            -1\n          ).mode;\n        }\n        break;\n      case DOC_TYPE_FILL: {\n        const rem = width - pos;\n        const {\n          parts\n        } = doc2;\n        if (parts.length === 0) {\n          break;\n        }\n        const [content, whitespace] = parts;\n        const contentFlatCmd = {\n          ind,\n          mode: MODE_FLAT,\n          doc: content\n        };\n        const contentBreakCmd = {\n          ind,\n          mode: MODE_BREAK,\n          doc: content\n        };\n        const contentFits = fits(contentFlatCmd, [], rem, lineSuffix2.length > 0, groupModeMap, true);\n        if (parts.length === 1) {\n          if (contentFits) {\n            cmds.push(contentFlatCmd);\n          } else {\n            cmds.push(contentBreakCmd);\n          }\n          break;\n        }\n        const whitespaceFlatCmd = {\n          ind,\n          mode: MODE_FLAT,\n          doc: whitespace\n        };\n        const whitespaceBreakCmd = {\n          ind,\n          mode: MODE_BREAK,\n          doc: whitespace\n        };\n        if (parts.length === 2) {\n          if (contentFits) {\n            cmds.push(whitespaceFlatCmd, contentFlatCmd);\n          } else {\n            cmds.push(whitespaceBreakCmd, contentBreakCmd);\n          }\n          break;\n        }\n        parts.splice(0, 2);\n        const remainingCmd = {\n          ind,\n          mode,\n          doc: fill(parts)\n        };\n        const secondContent = parts[0];\n        const firstAndSecondContentFlatCmd = {\n          ind,\n          mode: MODE_FLAT,\n          doc: [content, whitespace, secondContent]\n        };\n        const firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], rem, lineSuffix2.length > 0, groupModeMap, true);\n        if (firstAndSecondContentFits) {\n          cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd);\n        } else if (contentFits) {\n          cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd);\n        } else {\n          cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);\n        }\n        break;\n      }\n      case DOC_TYPE_IF_BREAK:\n      case DOC_TYPE_INDENT_IF_BREAK: {\n        const groupMode = doc2.groupId ? groupModeMap[doc2.groupId] : mode;\n        if (groupMode === MODE_BREAK) {\n          const breakContents = doc2.type === DOC_TYPE_IF_BREAK ? doc2.breakContents : doc2.negate ? doc2.contents : indent(doc2.contents);\n          if (breakContents) {\n            cmds.push({\n              ind,\n              mode,\n              doc: breakContents\n            });\n          }\n        }\n        if (groupMode === MODE_FLAT) {\n          const flatContents = doc2.type === DOC_TYPE_IF_BREAK ? doc2.flatContents : doc2.negate ? indent(doc2.contents) : doc2.contents;\n          if (flatContents) {\n            cmds.push({\n              ind,\n              mode,\n              doc: flatContents\n            });\n          }\n        }\n        break;\n      }\n      case DOC_TYPE_LINE_SUFFIX:\n        lineSuffix2.push({\n          ind,\n          mode,\n          doc: doc2.contents\n        });\n        break;\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n        if (lineSuffix2.length > 0) {\n          cmds.push({\n            ind,\n            mode,\n            doc: hardlineWithoutBreakParent\n          });\n        }\n        break;\n      case DOC_TYPE_LINE:\n        switch (mode) {\n          case MODE_FLAT:\n            if (!doc2.hard) {\n              if (!doc2.soft) {\n                out.push(\" \");\n                pos += 1;\n              }\n              break;\n            } else {\n              shouldRemeasure = true;\n            }\n          case MODE_BREAK:\n            if (lineSuffix2.length > 0) {\n              cmds.push({\n                ind,\n                mode,\n                doc: doc2\n              }, ...lineSuffix2.reverse());\n              lineSuffix2.length = 0;\n              break;\n            }\n            if (doc2.literal) {\n              if (ind.root) {\n                out.push(newLine, ind.root.value);\n                pos = ind.root.length;\n              } else {\n                out.push(newLine);\n                pos = 0;\n              }\n            } else {\n              pos -= trim2(out);\n              out.push(newLine + ind.value);\n              pos = ind.length;\n            }\n            break;\n        }\n        break;\n      case DOC_TYPE_LABEL:\n        cmds.push({\n          ind,\n          mode,\n          doc: doc2.contents\n        });\n        break;\n      case DOC_TYPE_BREAK_PARENT:\n        break;\n      default:\n        throw new invalid_doc_error_default(doc2);\n    }\n    if (cmds.length === 0 && lineSuffix2.length > 0) {\n      cmds.push(...lineSuffix2.reverse());\n      lineSuffix2.length = 0;\n    }\n  }\n  const cursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER);\n  if (cursorPlaceholderIndex !== -1) {\n    const otherCursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER, cursorPlaceholderIndex + 1);\n    const beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");\n    const aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join(\"\");\n    const afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");\n    return {\n      formatted: beforeCursor + aroundCursor + afterCursor,\n      cursorNodeStart: beforeCursor.length,\n      cursorNodeText: aroundCursor\n    };\n  }\n  return {\n    formatted: out.join(\"\")\n  };\n}\n\n// src/document/public.js\nvar builders = {\n  join,\n  line,\n  softline,\n  hardline,\n  literalline,\n  group,\n  conditionalGroup,\n  fill,\n  lineSuffix,\n  lineSuffixBoundary,\n  cursor,\n  breakParent,\n  ifBreak,\n  trim,\n  indent,\n  indentIfBreak,\n  align,\n  addAlignmentToDoc,\n  markAsRoot,\n  dedentToRoot,\n  dedent,\n  hardlineWithoutBreakParent,\n  literallineWithoutBreakParent,\n  label,\n  // TODO: Remove this in v4\n  concat: (parts) => parts\n};\nvar printer = { printDocToString };\nvar utils = {\n  willBreak,\n  traverseDoc: traverse_doc_default,\n  findInDoc,\n  mapDoc,\n  removeLines,\n  stripTrailingHardline,\n  replaceEndOfLine,\n  canBreak\n};\n\n// with-default-export:src/document/public.js\nvar public_default = public_exports;\nexport {\n  builders,\n  public_default as default,\n  printer,\n  utils\n};\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\n\ntype Printable = Ast.Node | Ast.Argument | string;\ntype PrintToken = string | typeof linebreak;\n\nexport const linebreak = Symbol(\"linebreak\");\nconst ESCAPE = \"\\\\\";\n\n/**\n * Renders the AST to an array inserting `linebreak` where needed;\n * This array may be nested.\n *\n * @param {*} node\n */\nfunction _printRaw(node: Printable | Printable[]): PrintToken[] {\n    if (typeof node === \"string\") {\n        return [node];\n    }\n    if (Array.isArray(node)) {\n        return ([] as PrintToken[]).concat(\n            ...node.map((n: Printable) => _printRaw(n))\n        );\n    }\n    // tmp variables\n    let argsString, escape;\n    switch (node.type) {\n        case \"root\":\n            return _printRaw(node.content);\n        case \"argument\":\n            return [node.openMark, ..._printRaw(node.content), node.closeMark];\n        case \"comment\":\n            var suffix = node.suffixParbreak ? \"\" : linebreak;\n            // A comment is responsible for printing its own leading whitespace\n            var leadingWhitespace = \"\";\n            if (node.sameline && node.leadingWhitespace) {\n                leadingWhitespace = \" \";\n            }\n            if (node.sameline) {\n                return [\n                    leadingWhitespace,\n                    \"%\",\n                    ..._printRaw(node.content),\n                    suffix,\n                ];\n            }\n            return [linebreak, \"%\", ..._printRaw(node.content), suffix];\n        case \"environment\":\n        case \"mathenv\":\n        case \"verbatim\":\n            var env = _printRaw(node.env);\n            var envStart: PrintToken[] = [ESCAPE + \"begin{\", ...env, \"}\"];\n            var envEnd: PrintToken[] = [ESCAPE + \"end{\", ...env, \"}\"];\n            argsString =\n                (node as any).args == null ? [] : _printRaw((node as any).args);\n            return [\n                ...envStart,\n                ...argsString,\n                ..._printRaw(node.content),\n                ...envEnd,\n            ];\n        case \"displaymath\":\n            return [ESCAPE + \"[\", ..._printRaw(node.content), ESCAPE + \"]\"];\n        case \"group\":\n            return [\"{\", ..._printRaw(node.content), \"}\"];\n        case \"inlinemath\":\n            return [\"$\", ..._printRaw(node.content), \"$\"];\n        case \"macro\":\n            argsString = node.args == null ? [] : _printRaw(node.args);\n            escape = node.escapeToken == null ? ESCAPE : node.escapeToken;\n            return [escape, ..._printRaw(node.content), ...argsString];\n        case \"parbreak\":\n            return [linebreak, linebreak];\n        case \"string\":\n            return [node.content];\n        case \"verb\":\n            return [\n                ESCAPE,\n                node.env,\n                node.escape,\n                ..._printRaw(node.content),\n                node.escape,\n            ];\n        case \"whitespace\":\n            return [\" \"];\n\n        default:\n            console.warn(\n                \"Cannot find render for node \",\n                node,\n                `(of type ${typeof node})`\n            );\n            return [\"\" + node];\n    }\n}\n\n/**\n * Renders the AST to a string without any pretty printing.\n *\n * @param {*} node\n * @param {*} options - Setting `asArray` to `true` will return an array of strings and the symbol `linebreak`, so that printing can be customized.\n */\nexport function printRaw(\n    node: Printable | Printable[],\n    options?: { asArray: false }\n): string;\nexport function printRaw(\n    node: Printable | Printable[],\n    options: { asArray: true }\n): PrintToken[];\nexport function printRaw(node: Printable | Printable[], options?: object): any {\n    const asArray = options != null ? (options as any).asArray : false;\n    const printedTokens = _printRaw(node);\n    if (asArray) {\n        return printedTokens;\n    }\n    return printedTokens.map((x) => (x === linebreak ? \"\\n\" : x)).join(\"\");\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    EnvInfo,\n    MacroInfo,\n    MacroInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\n/**\n * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros\n * and generates a hash for quick lookup.\n */\nfunction createMacroMatcher<S extends string>(\n    macros: Ast.Macro[] | S[] | Record<S, unknown>\n) {\n    // We first make sure we have a record type with keys being the macro's contents\n    const macrosHash: Record<string, unknown> = Array.isArray(macros)\n        ? macros.length > 0\n            ? typeof macros[0] === \"string\"\n                ? Object.fromEntries(\n                      macros.map((macro) => {\n                          if (typeof macro !== \"string\") {\n                              throw new Error(\"Wrong branch of map function\");\n                          }\n                          return [macro, {}] as [string, MacroInfo];\n                      })\n                  )\n                : Object.fromEntries(\n                      macros.map((macro) => {\n                          if (typeof macro === \"string\") {\n                              throw new Error(\"Wrong branch of map function\");\n                          }\n                          if (macro.escapeToken != null) {\n                              return [\n                                  macro.content,\n                                  { escapeToken: macro.escapeToken },\n                              ] as [string, MacroInfo];\n                          }\n                          return [macro.content, {}] as [string, MacroInfo];\n                      })\n                  )\n            : {}\n        : macros;\n\n    return function matchAgainstMacros(node: any | Ast.Macro) {\n        if (node == null || node.type !== \"macro\") {\n            return false;\n        }\n        // At this point we have a macro type\n        const spec = macrosHash[node.content];\n        if (!spec) {\n            return false;\n        }\n\n        if (typeof spec === \"object\" && \"escapeToken\" in spec) {\n            return (\n                (spec as MacroInfoRecord).escapeToken == null ||\n                (spec as MacroInfoRecord).escapeToken === node.escapeToken\n            );\n        }\n        return true;\n    } as Ast.TypeGuard<Ast.Macro & { content: S }>;\n}\n\n/**\n * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros\n * and generates a hash for quick lookup.\n */\nfunction createEnvironmentMatcher(macros: string[] | Record<string, unknown>) {\n    // We first make sure we have a record type with keys being the macro's contents\n    const environmentsHash = Array.isArray(macros)\n        ? Object.fromEntries(\n              macros.map((str) => {\n                  return [str, {}] as [string, EnvInfo];\n              })\n          )\n        : macros;\n\n    return function matchAgainstEnvironments(node: any | Ast.Environment) {\n        if (!match.anyEnvironment(node)) {\n            return false;\n        }\n        // At this point we have an environment type\n        const envName = printRaw(node.env);\n        const spec = environmentsHash[envName];\n        if (!spec) {\n            return false;\n        }\n\n        return true;\n    } as Ast.TypeGuard<Ast.Environment>;\n}\n\n/**\n * Functions to match different types of nodes.\n */\nexport const match = {\n    macro(node: any, macroName?: string): node is Ast.Macro {\n        if (node == null) {\n            return false;\n        }\n        return (\n            node.type === \"macro\" &&\n            (macroName == null || node.content === macroName)\n        );\n    },\n    anyMacro(node: any): node is Ast.Macro {\n        return match.macro(node);\n    },\n    environment(node: any, envName?: string): node is Ast.Environment {\n        if (node == null) {\n            return false;\n        }\n        return (\n            (node.type === \"environment\" || node.type === \"mathenv\") &&\n            (envName == null || printRaw(node.env) === envName)\n        );\n    },\n    anyEnvironment(node: any): node is Ast.Environment {\n        return match.environment(node);\n    },\n    comment(node: any): node is Ast.Comment {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"comment\";\n    },\n    parbreak(node: any): node is Ast.Parbreak {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"parbreak\";\n    },\n    whitespace(node: any): node is Ast.Whitespace {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"whitespace\";\n    },\n    /**\n     * Matches whitespace or a comment with leading whitespace.\n     */\n    whitespaceLike(\n        node: any\n    ): node is Ast.Whitespace | (Ast.Comment & { leadingWhitespace: true }) {\n        if (node == null) {\n            return false;\n        }\n        return (\n            node.type === \"whitespace\" ||\n            (node.type === \"whitespace\" && node.leadingWhitespace === true)\n        );\n    },\n    string(node: any, value?: string): node is Ast.String {\n        if (node == null) {\n            return false;\n        }\n        return (\n            node.type === \"string\" && (value == null || node.content === value)\n        );\n    },\n    anyString(node: any): node is Ast.String {\n        return match.string(node);\n    },\n    group(node: any): node is Ast.Group {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"group\";\n    },\n    argument(node: any): node is Ast.Argument {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"argument\";\n    },\n    blankArgument(node: any): boolean {\n        if (!match.argument(node)) {\n            return false;\n        }\n        return (\n            node.openMark === \"\" &&\n            node.closeMark === \"\" &&\n            node.content.length === 0\n        );\n    },\n    math(node: any): node is Ast.DisplayMath | Ast.InlineMath {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"displaymath\" || node.type === \"inlinemath\";\n    },\n    createMacroMatcher,\n    createEnvironmentMatcher,\n};\n\nexport const {\n    anyEnvironment,\n    anyMacro,\n    anyString,\n    argument,\n    blankArgument,\n    comment,\n    environment,\n    group,\n    macro,\n    math,\n    parbreak,\n    string,\n    whitespace,\n} = match;\n", "import { builders } from \"prettier/doc\";\nimport type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { ReferenceMap } from \"../reference-map\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Computes the environment name, start/end, and args.\n * E.g., for \"\\begin{x}abc\\end{x}\", it returns\n * ```\n * {\n *  envName: \"x\",\n *  start: \"\\\\begin{x}\",\n *  end: \"\\\\end{x}\",\n * }\n * ```\n *\n * @param {*} node\n * @returns\n */\nexport function formatEnvSurround(node: Ast.Environment) {\n    const env = printRaw(node.env);\n\n    return {\n        envName: env,\n        start: ESCAPE + \"begin{\" + env + \"}\",\n        end: ESCAPE + \"end{\" + env + \"}\",\n    };\n}\n\n/**\n * Determine if `elm` is a line type (softline/hardline/etc). If `elm` is an\n * array or a concat, the first element is checked.\n */\nfunction isLineType(elm: Doc): boolean {\n    if (elm == null || typeof elm === \"string\") {\n        return false;\n    }\n    if (Array.isArray(elm)) {\n        return isLineType(elm[0]);\n    }\n    // Perhaps we can sneak by with Prettier v2 compatibility?\n    // @ts-ignore\n    if (elm.type === \"concat\") {\n        // @ts-ignore\n        return isLineType(elm.parts);\n    }\n    return elm.type === \"line\";\n}\n\n/**\n * Join an array with `softline`. However, if a `line` is\n * found, do not insert an additional softline. For example\n * `[a, b, c]` -> `[a, softline, b, softline, c]`\n *\n * but\n *\n * `[a, line, b, c]` -> `[a, line, b, softline, c]`\n *\n * @param {*} arr\n * @returns\n */\nexport function joinWithSoftline(arr: Doc[]) {\n    if (arr.length === 0 || arr.length === 1) {\n        return arr;\n    }\n    const ret = [arr[0]];\n    for (let i = 1; i < arr.length; i++) {\n        const prevNode = arr[i - 1];\n        const nextNode = arr[i];\n        if (!isLineType(prevNode) && !isLineType(nextNode)) {\n            ret.push(softline);\n        }\n        ret.push(nextNode);\n    }\n    return ret;\n}\n\nexport function getNodeInfo(\n    node: any,\n    options: PrettierTypes.Options & { referenceMap?: ReferenceMap }\n): {\n    renderInfo: Record<string, any>;\n    renderCache?: object;\n    previousNode?: Ast.Node;\n    nextNode?: Ast.Node;\n    referenceMap?: ReferenceMap;\n} {\n    if (!node) {\n        return { renderInfo: {} };\n    }\n    const renderInfo = node._renderInfo || {};\n    const previousNode =\n        options.referenceMap && options.referenceMap.getPreviousNode(node);\n    const nextNode =\n        options.referenceMap && options.referenceMap.getNextNode(node);\n    const renderCache =\n        options.referenceMap && options.referenceMap.getRenderCache(node);\n    // It's useful to know whether we're the start or end node in an array,\n    // so compute this information.\n    return {\n        renderInfo,\n        renderCache,\n        previousNode,\n        nextNode,\n        referenceMap: options.referenceMap,\n    };\n}\n\nexport const ESCAPE = \"\\\\\";\n\n// Commands to build the prettier syntax tree\nexport const {\n    group,\n    fill,\n    ifBreak,\n    line,\n    softline,\n    hardline,\n    lineSuffix,\n    lineSuffixBoundary,\n    breakParent,\n    indent,\n    markAsRoot,\n    join,\n} = builders;\n\n/**\n * Given an array of nodes and the corresponding printed versions, prepares\n * a final Doc array. This function does things like ensures there are `hardlines`\n * around environments and that there aren't excess hardlines at the start or end.\n * It also unwraps `inParMode` macro contents.\n *\n * @export\n * @param {Ast.Node[]} nodes\n * @param {Doc[]} docArray\n * @param {*} options\n * @returns {Doc[]}\n */\nexport function formatDocArray(\n    nodes: Ast.Node[],\n    docArray: Doc[],\n    options: any\n): Doc[] {\n    const ret: Doc[] = [];\n\n    for (let i = 0; i < nodes.length; i++) {\n        const rawNode = nodes[i];\n        const printedNode = docArray[i];\n        const { renderInfo, referenceMap, previousNode, nextNode } =\n            getNodeInfo(rawNode, options);\n        const renderCache =\n            referenceMap && referenceMap.getRenderCache(rawNode);\n\n        switch (rawNode.type) {\n            case \"comment\":\n                // Comments don't insert hardlines themselves; they depend on appropriate\n                // hardlines being inserted here.\n\n                // This comment printer inserts hardlines after comments, so do not insert\n                // a hardline before a comment if there is a comment right before.\n                if (\n                    !rawNode.sameline &&\n                    previousNode &&\n                    !match.comment(previousNode) &&\n                    !match.parbreak(previousNode)\n                ) {\n                    ret.push(hardline);\n                }\n                ret.push(printedNode);\n                if (nextNode && !rawNode.suffixParbreak) {\n                    ret.push(hardline);\n                }\n                break;\n            case \"environment\":\n            case \"displaymath\":\n            case \"mathenv\":\n                // Environments always start on a new line (unless they are the first\n                // item). Peek to see if there is a newline inserted already.\n                if (previousNode && previousNode?.type !== \"parbreak\") {\n                    if (ret[ret.length - 1] === line) {\n                        // A preceding `line` should be converted into a `hardline`.\n                        // Remove the line so a hardline can be added\n                        ret.pop();\n                    }\n                    if (ret[ret.length - 1] !== hardline) {\n                        ret.push(hardline);\n                    }\n                }\n                ret.push(printedNode);\n                // If an environment is followed by whitespace, replace it with a hardline\n                // instead\n                if (nextNode?.type === \"whitespace\") {\n                    ret.push(hardline);\n                    i++;\n                }\n\n                break;\n            case \"macro\":\n                if (renderInfo.breakBefore || renderInfo.breakAround) {\n                    // Commands like \\section{} should always be preceded by a hardline\n                    if (previousNode) {\n                        if (\n                            ret[ret.length - 1] === line ||\n                            ret[ret.length - 1] === hardline\n                        ) {\n                            // We may be replacing a hardline here for no reason. However,\n                            // if there is already a hardline, we don't want to continue\n                            // and accidentally add too many linebreaks\n                            ret.pop();\n                            ret.push(hardline);\n                        } else if (\n                            !match.comment(previousNode) &&\n                            !match.parbreak(previousNode)\n                        ) {\n                            ret.push(hardline);\n                        }\n                    }\n                }\n                // Macros marked as `inParMode` should be unwrapped\n                // unless they have a hanging indent, in which case the macro\n                // has already be wrapped in an `indent` block\n                if (\n                    renderInfo.inParMode &&\n                    !renderInfo.hangingIndent &&\n                    renderCache\n                ) {\n                    ret.push(\n                        (renderCache as any).content,\n                        ...((renderCache as any).rawArgs || [])\n                    );\n                } else {\n                    ret.push(printedNode);\n                }\n                if (renderInfo.breakAfter || renderInfo.breakAround) {\n                    // Commands like \\section{} should always be followed by a hardline\n                    if (nextNode) {\n                        if (match.whitespace(nextNode)) {\n                            ret.push(hardline);\n                            i++;\n                        } else if (match.parbreak(nextNode)) {\n                            // If the next node is a parbreak, it will insert its own newline\n                        } else if (!match.comment(nextNode)) {\n                            ret.push(hardline);\n                        }\n                    }\n                }\n                break;\n            case \"parbreak\":\n                ret.push(hardline, hardline);\n                break;\n            default:\n                ret.push(printedNode);\n                break;\n        }\n    }\n\n    return ret;\n}\n", "export function zip<T, U>(array1: T[], array2: U[]): [T, U][] {\n    const ret: [T, U][] = [];\n    const len = Math.min(array1.length, array2.length);\n    for (let i = 0; i < len; i++) {\n        ret.push([array1[i], array2[i]]);\n    }\n    return ret;\n}\n", "import type { Doc } from \"prettier\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport { getNodeInfo, fill, ESCAPE, indent, group } from \"./common\";\nimport { zip } from \"../zip\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\nexport function printMacro(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Macro;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    const content =\n        (node.escapeToken != null ? node.escapeToken : ESCAPE) + node.content;\n    const args = node.args ? path.map(print, \"args\" as any) : [];\n\n    // Some of the arguments want to be printed \"inline\".\n    // We loop through the arguments and unwrap the inline ones.\n    const rawArgs = [];\n    for (const [arg, printedArg] of zip(node.args || [], args)) {\n        const renderCache = referenceMap && referenceMap.getRenderCache(arg);\n        if (renderInfo.inParMode && renderCache) {\n            rawArgs.push(...(renderCache as any[]));\n        } else {\n            rawArgs.push(printedArg);\n        }\n    }\n\n    if (referenceMap) {\n        referenceMap.setRenderCache(node, { rawArgs, content });\n    }\n\n    if (renderInfo.hangingIndent) {\n        return indent(fill([content, ...rawArgs]));\n    }\n\n    return group([content, ...rawArgs]);\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * List all props of the current node that should be processed\n * in math mode or not in math mode. If math mode is not specified in the node's render\n * info, empty lists are returned.\n *\n * For example `\\text{foo}` will report that `args` should *not* be processed in math mode,\n * since it's contents should always be processed in text mode.\n */\nexport function listMathChildren(node: Ast.Ast): {\n    enter: string[];\n    leave: string[];\n} {\n    const NULL_RETURN = { enter: [], leave: [] };\n    if (Array.isArray(node)) {\n        return NULL_RETURN;\n    }\n    if (match.math(node)) {\n        // When we enter a math environment, our content is always\n        // considered math mode\n        return { enter: [\"content\"], leave: [] };\n    }\n\n    const renderInfo: { inMathMode?: boolean } = node._renderInfo || {};\n    if (renderInfo.inMathMode == null) {\n        return NULL_RETURN;\n    }\n    if (match.macro(node)) {\n        if (renderInfo.inMathMode === true) {\n            return { enter: [\"args\"], leave: [] };\n        } else if (renderInfo.inMathMode === false) {\n            return { enter: [], leave: [\"args\"] };\n        }\n    }\n    if (match.environment(node)) {\n        if (renderInfo.inMathMode === true) {\n            return { enter: [\"content\"], leave: [] };\n        } else {\n            return { enter: [], leave: [\"content\"] };\n        }\n    }\n    return NULL_RETURN;\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { listMathChildren } from \"./list-math-children\";\n\nexport type VisitorContext = {\n    /**\n     * Whether the node is being processed in math mode.\n     *\n     * This happens when the node is a director or indirect child\n     * of a math environment (e.g. `$abc$`), but not when an environment\n     * re-establishes text mode (e.g. `$\\text{abc}$`)\n     */\n    inMathMode?: boolean;\n    /**\n     * Whether the node has any ancestor that is processed in math mode.\n     */\n    hasMathModeAncestor?: boolean;\n};\n\ntype GetGuard<T> = T extends (x: any, ...y: any[]) => x is infer R ? R : never;\n/**\n * Gets the type that a type-guard function is guarding. If\n * the guard type cannot be determined, the input type is returned.\n */\ntype GuardTypeOf<T extends (x: any, ...y: any[]) => boolean> = GetGuard<T> extends never\n    ? T extends (x: infer A) => any\n        ? A\n        : never\n    : GetGuard<T>;\n\n/**\n * Extracts the guard type from the `test` function provided in a\n * `VisitOptions` argument.\n */\ntype GuardFromOptions<\n    Opts extends VisitOptions,\n    PossibleTypes = Ast.Ast\n> = Opts extends {\n    test: infer R;\n}\n    ? R extends (x: any, ...y: any[]) => boolean\n        ? // A guard like `typeof Array.isArray` will return `any[]` as the type.\n          // This type cannot be narrowed, so instead we use it to pick from\n          // the set of all possible types.\n          Extract<PossibleTypes, GuardTypeOf<R>>\n        : PossibleTypes\n    : PossibleTypes;\n\n/**\n * Narrow the type `T` based on the `VisitOptions` supplied. If `{includeArrays: false}`\n * is specified in the `VisitOptions`, then arrays are excluded from `T`.\n */\ntype NarrowArraysBasedOnOptions<T, Opts extends VisitOptions> = Opts extends {\n    includeArrays: infer A;\n}\n    ? A extends true\n        ? T\n        : Exclude<T, any[]>\n    : Exclude<T, any[]>;\n\n/**\n * Get the type of the parameter to the `Visitor` function based on the\n * `VisitOptions` that are supplied.\n */\ntype VisitorTypeFromOptions<Opts extends VisitOptions> =\n    NarrowArraysBasedOnOptions<GuardFromOptions<Opts>, Opts>;\n\n/**\n * Continue traversing as normal\n */\nexport const CONTINUE = Symbol(\"continue\");\n/**\n * Do not traverse this node\u2019s children\n */\nexport const SKIP = Symbol(\"skip\");\n/**\n * Stop traversing immediately\n */\nexport const EXIT = Symbol(\"exit\");\n\ntype Action = typeof CONTINUE | typeof SKIP | typeof EXIT;\ntype Index = number;\ntype ActionTuple = [Action] | [typeof SKIP, Index] | [typeof CONTINUE, Index];\n\n/**\n * A visitor takes a `node`, `key`, `index`, and ...\n *\n * @param key - The key of the parent that we were accessed through.\n */\ntype Visitor<T> = (\n    node: T,\n    info: VisitInfo\n) => null | undefined | Action | Index | ActionTuple | void;\ntype Visitors<T> = { enter?: Visitor<T>; leave?: Visitor<T> };\n\ntype VisitOptions = {\n    startingContext?: VisitorContext;\n    /**\n     * Type guard for types that are passed to the `visitor` function.\n     */\n    test?: (node: Ast.Ast, info: VisitInfo) => boolean;\n    /**\n     * Whether arrays will be sent to the `visitor` function. If falsy,\n     * only nodes will be past to `visitor`.\n     */\n    includeArrays?: boolean;\n};\n\nconst DEFAULT_CONTEXT: VisitorContext = {\n    inMathMode: false,\n    hasMathModeAncestor: false,\n};\n\nexport type VisitInfo = {\n    /**\n     * If the element was accessed via an attribute, the attribute key is specified.\n     */\n    readonly key: string | undefined;\n    /**\n     * If the element was accessed in an array, the index is specified.\n     */\n    readonly index: number | undefined;\n    /**\n     * A list of ancestor nodes, `[parent, grandparent, great-grandparent, ...]`\n     */\n    readonly parents: (Ast.Node | Ast.Argument)[];\n    /**\n     * If the element was accessed in an array, the array that it is part of.\n     */\n    readonly containingArray: (Ast.Node | Ast.Argument)[] | undefined;\n    /**\n     * The LaTeX context of the current match.\n     */\n    readonly context: VisitorContext;\n};\n\n/**\n * Visit children of tree which pass a test\n *\n * @param {Node} tree Abstract syntax tree to walk\n * @param {Visitor|Visitors} [visitor] Function to run for each node\n */\nexport function visit<Opts extends VisitOptions>(\n    tree: Ast.Ast,\n    visitor:\n        | Visitor<VisitorTypeFromOptions<Opts>>\n        | Visitors<VisitorTypeFromOptions<Opts>>,\n    options?: Opts\n) {\n    const {\n        startingContext = DEFAULT_CONTEXT,\n        test = () => true,\n        includeArrays = false,\n    } = options || {};\n    let enter: Visitor<VisitorTypeFromOptions<Opts>> | undefined;\n    let leave: Visitor<VisitorTypeFromOptions<Opts>> | undefined;\n\n    if (typeof visitor === \"function\") {\n        enter = visitor;\n    } else if (visitor && typeof visitor === \"object\") {\n        enter = visitor.enter;\n        leave = visitor.leave;\n    }\n\n    walk(tree, {\n        key: undefined,\n        index: undefined,\n        parents: [],\n        containingArray: undefined,\n        context: { ...startingContext },\n    });\n\n    /**\n     * @param {Node} node\n     * @param {string?} key\n     * @param {number?} index\n     * @param {Array.<Node>} parents\n     */\n    function walk(\n        node: Ast.Ast,\n        { key, index, parents, context, containingArray }: VisitInfo\n    ): ActionTuple {\n        const nodePassesTest = includeArrays\n            ? test(node, { key, index, parents, context, containingArray })\n            : !Array.isArray(node) &&\n              test(node, { key, index, parents, context, containingArray });\n\n        const result: ActionTuple =\n            enter && nodePassesTest\n                ? toResult(\n                      enter(node as any, {\n                          key,\n                          index,\n                          parents,\n                          context,\n                          containingArray,\n                      })\n                  )\n                : [CONTINUE];\n\n        if (result[0] === EXIT) {\n            return result;\n        }\n\n        if (result[0] === SKIP) {\n            return leave && nodePassesTest\n                ? toResult(\n                      leave(node as any, {\n                          key,\n                          index,\n                          parents,\n                          context,\n                          containingArray,\n                      })\n                  )\n                : result;\n        }\n\n        if (Array.isArray(node)) {\n            // The `value` array might be modified in place as we traverse it, so\n            // we use a traditional for loop.\n            for (let index = 0; index > -1 && index < node.length; index++) {\n                const item = node[index];\n                const result = walk(item, {\n                    key,\n                    index,\n                    parents,\n                    context,\n                    containingArray: node,\n                });\n                if (result[0] === EXIT) {\n                    return result;\n                }\n                if (typeof result[1] === \"number\") {\n                    // The for loop will increment i every pass. However,\n                    // if an index was returned, that's where we want to start next time.\n                    index = result[1] - 1;\n                }\n            }\n        } else {\n            // We don't want to recursively apply to the `content`\n            // of all types (e.g., comments and macros), so specify\n            // a blacklist.\n            let childProps: (\"content\" | \"args\")[] = [\"content\", \"args\"];\n            switch (node.type) {\n                case \"macro\":\n                    childProps = [\"args\"];\n                    break;\n                case \"comment\":\n                case \"string\":\n                case \"verb\":\n                case \"verbatim\":\n                    childProps = [];\n                    break;\n                default:\n                    break;\n            }\n\n            const mathModeProps = listMathChildren(node);\n            for (const key of childProps) {\n                const value = node[key as keyof typeof node] as\n                    | Ast.Ast\n                    | undefined;\n                const grandparents = [node].concat(parents);\n\n                if (value == null) {\n                    continue;\n                }\n\n                // We may switch in/out of math mode as we pass to node[key]\n                const newContext = { ...context };\n                if (mathModeProps.enter.includes(key)) {\n                    newContext.inMathMode = true;\n                    newContext.hasMathModeAncestor = true;\n                } else if (mathModeProps.leave.includes(key)) {\n                    newContext.inMathMode = false;\n                }\n\n                const result = walk(value, {\n                    key,\n                    index: undefined,\n                    parents: grandparents,\n                    context: newContext,\n                    containingArray: undefined,\n                });\n                if (result[0] === EXIT) {\n                    return result;\n                }\n            }\n        }\n\n        return leave && nodePassesTest\n            ? toResult(\n                  leave(node as any, {\n                      key,\n                      index,\n                      parents,\n                      context,\n                      containingArray,\n                  })\n              )\n            : result;\n    }\n}\n\n/**\n * Ensures a result is an `ActionTuple`s\n */\nfunction toResult(\n    value: null | undefined | void | Action | Index | ActionTuple\n): ActionTuple {\n    if (value == null) {\n        return [CONTINUE];\n    }\n\n    if (Array.isArray(value)) {\n        return value;\n    }\n\n    if (typeof value === \"number\") {\n        return [CONTINUE, value];\n    }\n\n    return [value];\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\n\n/**\n * Trims whitespace and parbreaks from the start and end\n * of an array. The number of trimmed nodes is returned.\n * Special care is taken to preserve comments, though any whitespace\n * before the first comment(s) or after the last comment(s) is trimmed.\n */\nexport function trim(nodes: Ast.Node[]): {\n    trimmedStart: number;\n    trimmedEnd: number;\n} {\n    if (!Array.isArray(nodes)) {\n        console.warn(\"Trying to trim a non-array ast\", nodes);\n        return nodes;\n    }\n\n    const { trimmedStart } = trimStart(nodes);\n    const { trimmedEnd } = trimEnd(nodes);\n\n    return { trimmedStart, trimmedEnd };\n}\n\n/**\n * Trim whitespace and parbreaks from the left of an array.\n */\nexport function trimStart(nodes: Ast.Node[]): { trimmedStart: number } {\n    const { start } = amountOfLeadingAndTrailingWhitespace(nodes);\n\n    nodes.splice(0, start);\n\n    // If there are comments at the start, they might have leading whitespace.\n    // This leading whitespace should be trimmed\n    for (const leadingToken of nodes) {\n        if (!match.comment(leadingToken)) {\n            break;\n        }\n        if (leadingToken.leadingWhitespace || leadingToken.sameline) {\n            leadingToken.leadingWhitespace = false;\n            // We remove the position information from this token to indicate that we've edited it\n            delete leadingToken.position;\n        }\n        // Special care must be taken. If the comment was on the same line as a\n        // parskip, it will no longer be on the same line after the trimming.\n        // Thus, we must modify the comment.\n        if (start > 0 && leadingToken.sameline) {\n            leadingToken.sameline = false;\n            delete leadingToken.position;\n        }\n    }\n\n    return { trimmedStart: start };\n}\n\n/**\n * Trim whitespace and parbreaks from the right of an array.\n */\nexport function trimEnd(nodes: Ast.Node[]): { trimmedEnd: number } {\n    const { end } = amountOfLeadingAndTrailingWhitespace(nodes);\n\n    nodes.splice(nodes.length - end, end);\n\n    // Trim off any spaces belonging to trailing comments\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        const trailingToken = nodes[i];\n        if (!match.comment(trailingToken)) {\n            break;\n        }\n\n        // Any parbreaks have been trimmed, so there is no suffix parbreak here!\n        delete trailingToken.suffixParbreak;\n\n        // We don't trim spaces before trailing same-line comments. This is a stylistic choice\n        // so that\n        // `foo %xxx` does not become `foo%xxx`.\n        // The latter is strictly \"correct\" for a trim function, but it is prettier to format\n        // code preserving the space before the sameline comment\n        if (\n            match.comment(trailingToken) &&\n            trailingToken.leadingWhitespace &&\n            !trailingToken.sameline\n        ) {\n            trailingToken.leadingWhitespace = false;\n            delete trailingToken.position;\n        }\n    }\n\n    return { trimmedEnd: end };\n}\n\n/**\n * Returns the number of whitespace/parbreak nodes at the start and end of an array.\n */\nfunction amountOfLeadingAndTrailingWhitespace(ast: Ast.Node[]): {\n    start: number;\n    end: number;\n} {\n    let start = 0;\n    let end = 0;\n    for (const node of ast) {\n        if (match.whitespace(node) || match.parbreak(node)) {\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    if (start === ast.length) {\n        return { start, end: 0 };\n    }\n\n    // Find the padding on the right\n    for (let i = ast.length - 1; i >= 0; i--) {\n        const node = ast[i];\n        if (match.whitespace(node) || match.parbreak(node)) {\n            end++;\n        } else {\n            break;\n        }\n    }\n\n    return { start, end };\n}\n", "import type { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { trim, trimEnd, trimStart } from \"./trim\";\n\ntype PluginOptions = void;\n\n/**\n * Unified plugin to trim the whitespace from the start/end of any environments, including\n * math environments.\n */\nexport const unifiedLatexTrimEnvironmentContents: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexTrimEnvironmentContents() {\n    return (tree) => {\n        visit(tree, (node) => {\n            if (!(match.math(node) || match.anyEnvironment(node))) {\n                return;\n            }\n\n            // If the first thing in the environment is a sameline comment,\n            // we actually want to start trimming *after* it.\n            let firstNode = node.content[0];\n            if (match.comment(firstNode) && firstNode.sameline) {\n                firstNode.suffixParbreak = false;\n                trimEnd(node.content);\n\n                // We play a nasty trick here. This call to `trimStart`\n                // will actually modify `node.content` if `node.content.slice(1)` starts\n                // with a comment that has leading whitespace (it will remove that whitespace).\n                // However, it won't remove any elements from `node.content`; we need\n                // to do that ourselves.\n                const { trimmedStart } = trimStart(node.content.slice(1));\n                node.content.splice(1, trimmedStart);\n            } else {\n                trim(node.content);\n            }\n        });\n    };\n};\n", "import type { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { trim } from \"./trim\";\n\ntype PluginOptions = void;\n\n/**\n * Unified plugin to trim the whitespace from the start/end of the root element.\n */\nexport const unifiedLatexTrimRoot: Plugin<PluginOptions[], Ast.Root, Ast.Root> =\n    function unifiedLatexTrimRoot() {\n        return (tree) => {\n            trim(tree.content);\n        };\n    };\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Returns whether the array has whitespace at the start/end. Comments with `leadingWhitespace === true`\n * are counted as whitespace. Other comments are ignored.\n */\nexport function hasWhitespaceEquivalent(nodes: Ast.Node[]): {\n    start: boolean;\n    end: boolean;\n} {\n    let start = false;\n    let end = false;\n    for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (match.comment(node)) {\n            // A comment with leading whitespace will render with leading whitespace,\n            // so if we encounter one, we should consider ourselves to have leading whitespace.\n            if (node.leadingWhitespace) {\n                start = true;\n                break;\n            }\n            continue;\n        }\n        if (match.whitespace(node)) {\n            start = true;\n        }\n        break;\n    }\n    for (let j = nodes.length - 1; j >= 0; j--) {\n        const node = nodes[j];\n        if (match.comment(node)) {\n            if (node.leadingWhitespace) {\n                end = true;\n                break;\n            }\n            continue;\n        }\n        if (match.whitespace(node)) {\n            end = true;\n        }\n        break;\n    }\n    return { start, end };\n}\n", "type StringlikeArray = any[] & string;\n\n/**\n * Pegjs operates on strings. However, strings and arrays are very similar!\n * This function adds `charAt`, `charCodeAt`, and `substring` methods to\n * `array` so that `array` can then be fed to a Pegjs generated parser.\n *\n * @param {[object]} array\n * @returns {[object]}\n */\nexport function decorateArrayForPegjs(array: any[]): StringlikeArray {\n    (array as any).charAt = function (i: number) {\n        return this[i];\n    };\n    // We don't have a hope of imitating `charCodeAt`, so\n    // make it something that won't interfere\n    (array as any).charCodeAt = () => 0;\n    (array as any).substring = function (i: number, j: number) {\n        return this.slice(i, j);\n    };\n    // This function is called when reporting an error,\n    // so we convert back to a string.\n    (array as any).replace = function (a: string, b: string) {\n        const ret = JSON.stringify(this);\n        return ret.replace(a, b);\n    };\n    return array as StringlikeArray;\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Splits all multi-character strings into strings that are all single characters.\n */\nexport function splitStringsIntoSingleChars(nodes: Ast.Node[]): Ast.Node[] {\n    return nodes.flatMap((node) =>\n        match.anyString(node)\n            ? (Array.from(node.content).map((c) => ({\n                  type: \"string\",\n                  content: c,\n              })) as Ast.Node[])\n            : node\n    );\n}\n", "export default // Generated by Peggy 2.0.1.\n//\n// https://peggyjs.org/\n(function() {\n  \"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { document: peg$parsedocument, math: peg$parsemath };\n  var peg$startRuleFunction = peg$parsedocument;\n\n  var peg$c0 = \"%\";\n  var peg$c1 = \".\";\n  var peg$c2 = \"verb*\";\n  var peg$c3 = \"verb\";\n  var peg$c4 = \"[\";\n  var peg$c5 = \"]\";\n  var peg$c6 = \"lstinline\";\n  var peg$c7 = \"mintinline\";\n  var peg$c8 = \"mint\";\n  var peg$c9 = \"minted\";\n  var peg$c10 = \"verbatim*\";\n  var peg$c11 = \"verbatim\";\n  var peg$c12 = \"filecontents*\";\n  var peg$c13 = \"filecontents\";\n  var peg$c14 = \"comment\";\n  var peg$c15 = \"lstlisting\";\n  var peg$c16 = \"(\";\n  var peg$c17 = \")\";\n  var peg$c18 = \"begin\";\n  var peg$c19 = \"end\";\n  var peg$c20 = \"equation*\";\n  var peg$c21 = \"equation\";\n  var peg$c22 = \"align*\";\n  var peg$c23 = \"align\";\n  var peg$c24 = \"alignat*\";\n  var peg$c25 = \"alignat\";\n  var peg$c26 = \"gather*\";\n  var peg$c27 = \"gather\";\n  var peg$c28 = \"multline*\";\n  var peg$c29 = \"multline\";\n  var peg$c30 = \"flalign*\";\n  var peg$c31 = \"flalign\";\n  var peg$c32 = \"split\";\n  var peg$c33 = \"math\";\n  var peg$c34 = \"displaymath\";\n  var peg$c35 = \"\\\\\";\n  var peg$c36 = \"{\";\n  var peg$c37 = \"}\";\n  var peg$c38 = \"$\";\n  var peg$c39 = \"&\";\n  var peg$c40 = \"\\r\";\n  var peg$c41 = \"\\n\";\n  var peg$c42 = \"\\r\\n\";\n  var peg$c43 = \"#\";\n  var peg$c44 = \"^\";\n  var peg$c45 = \"_\";\n  var peg$c46 = \"\\0\";\n\n  var peg$r0 = /^[^ \\t\\n\\r]/;\n  var peg$r1 = /^[ \\t]/;\n  var peg$r2 = /^[a-zA-Z]/;\n  var peg$r3 = /^[0-9]/;\n  var peg$r4 = /^[.,;:\\-*\\/()!?=+<>[\\]`'\"~]/;\n\n  var peg$e0 = peg$otherExpectation(\"document\");\n  var peg$e1 = peg$otherExpectation(\"math\");\n  var peg$e2 = peg$otherExpectation(\"token\");\n  var peg$e3 = peg$anyExpectation();\n  var peg$e4 = peg$otherExpectation(\"parbreak\");\n  var peg$e5 = peg$otherExpectation(\"math token\");\n  var peg$e6 = peg$otherExpectation(\"nonchar token\");\n  var peg$e7 = peg$literalExpectation(\"%\", false);\n  var peg$e8 = peg$otherExpectation(\"whitespace\");\n  var peg$e9 = peg$otherExpectation(\"number\");\n  var peg$e10 = peg$literalExpectation(\".\", false);\n  var peg$e11 = peg$otherExpectation(\"special macro\");\n  var peg$e12 = peg$literalExpectation(\"verb*\", false);\n  var peg$e13 = peg$literalExpectation(\"verb\", false);\n  var peg$e14 = peg$literalExpectation(\"[\", false);\n  var peg$e15 = peg$literalExpectation(\"]\", false);\n  var peg$e16 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], true, false);\n  var peg$e17 = peg$otherExpectation(\"verbatim listings\");\n  var peg$e18 = peg$literalExpectation(\"lstinline\", false);\n  var peg$e19 = peg$otherExpectation(\"verbatim minted\");\n  var peg$e20 = peg$literalExpectation(\"mintinline\", false);\n  var peg$e21 = peg$literalExpectation(\"mint\", false);\n  var peg$e22 = peg$otherExpectation(\"verbatim minted environment\");\n  var peg$e23 = peg$literalExpectation(\"minted\", false);\n  var peg$e24 = peg$otherExpectation(\"verbatim environment\");\n  var peg$e25 = peg$literalExpectation(\"verbatim*\", false);\n  var peg$e26 = peg$literalExpectation(\"verbatim\", false);\n  var peg$e27 = peg$literalExpectation(\"filecontents*\", false);\n  var peg$e28 = peg$literalExpectation(\"filecontents\", false);\n  var peg$e29 = peg$literalExpectation(\"comment\", false);\n  var peg$e30 = peg$literalExpectation(\"lstlisting\", false);\n  var peg$e31 = peg$otherExpectation(\"macro\");\n  var peg$e32 = peg$otherExpectation(\"group\");\n  var peg$e33 = peg$otherExpectation(\"environment\");\n  var peg$e34 = peg$otherExpectation(\"math environment\");\n  var peg$e35 = peg$otherExpectation(\"math group\");\n  var peg$e36 = peg$literalExpectation(\"(\", false);\n  var peg$e37 = peg$literalExpectation(\")\", false);\n  var peg$e38 = peg$literalExpectation(\"begin\", false);\n  var peg$e39 = peg$literalExpectation(\"end\", false);\n  var peg$e40 = peg$literalExpectation(\"equation*\", false);\n  var peg$e41 = peg$literalExpectation(\"equation\", false);\n  var peg$e42 = peg$literalExpectation(\"align*\", false);\n  var peg$e43 = peg$literalExpectation(\"align\", false);\n  var peg$e44 = peg$literalExpectation(\"alignat*\", false);\n  var peg$e45 = peg$literalExpectation(\"alignat\", false);\n  var peg$e46 = peg$literalExpectation(\"gather*\", false);\n  var peg$e47 = peg$literalExpectation(\"gather\", false);\n  var peg$e48 = peg$literalExpectation(\"multline*\", false);\n  var peg$e49 = peg$literalExpectation(\"multline\", false);\n  var peg$e50 = peg$literalExpectation(\"flalign*\", false);\n  var peg$e51 = peg$literalExpectation(\"flalign\", false);\n  var peg$e52 = peg$literalExpectation(\"split\", false);\n  var peg$e53 = peg$literalExpectation(\"math\", false);\n  var peg$e54 = peg$literalExpectation(\"displaymath\", false);\n  var peg$e55 = peg$otherExpectation(\"escape\");\n  var peg$e56 = peg$literalExpectation(\"\\\\\", false);\n  var peg$e57 = peg$literalExpectation(\"{\", false);\n  var peg$e58 = peg$literalExpectation(\"}\", false);\n  var peg$e59 = peg$literalExpectation(\"$\", false);\n  var peg$e60 = peg$literalExpectation(\"&\", false);\n  var peg$e61 = peg$otherExpectation(\"newline\");\n  var peg$e62 = peg$literalExpectation(\"\\r\", false);\n  var peg$e63 = peg$literalExpectation(\"\\n\", false);\n  var peg$e64 = peg$literalExpectation(\"\\r\\n\", false);\n  var peg$e65 = peg$literalExpectation(\"#\", false);\n  var peg$e66 = peg$literalExpectation(\"^\", false);\n  var peg$e67 = peg$literalExpectation(\"_\", false);\n  var peg$e68 = peg$literalExpectation(\"\\0\", false);\n  var peg$e69 = peg$classExpectation([\" \", \"\\t\"], false, false);\n  var peg$e70 = peg$otherExpectation(\"letter\");\n  var peg$e71 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false);\n  var peg$e72 = peg$otherExpectation(\"digit\");\n  var peg$e73 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n  var peg$e74 = peg$otherExpectation(\"punctuation\");\n  var peg$e75 = peg$classExpectation([\".\", \",\", \";\", \":\", \"-\", \"*\", \"/\", \"(\", \")\", \"!\", \"?\", \"=\", \"+\", \"<\", \">\", \"[\", \"]\", \"`\", \"'\", \"\\\"\", \"~\"], false, false);\n  var peg$e76 = peg$otherExpectation(\"full comment\");\n  var peg$e77 = peg$otherExpectation(\"comment\");\n\n  var peg$f0 = function(content) {\n            return createNode(\"root\", { content: content.flatMap((x) => x) });\n        };\n  var peg$f1 = function(t) { return t; };\n  var peg$f2 = function(eq) {\n            return createNode(\"inlinemath\", { content: eq.flatMap((x) => x) });\n        };\n  var peg$f3 = function(s) { return createNode(\"string\", { content: s }); };\n  var peg$f4 = function(s) { return createNode(\"string\", { content: s }); };\n  var peg$f5 = function() { return createNode(\"parbreak\"); };\n  var peg$f6 = function(x) { return x; };\n  var peg$f7 = function(x) { return x; };\n  var peg$f8 = function() {\n            return createNode(\"macro\", { content: \"^\", escapeToken: \"\" });\n        };\n  var peg$f9 = function() {\n            return createNode(\"macro\", { content: \"_\", escapeToken: \"\" });\n        };\n  var peg$f10 = function(s) { return createNode(\"string\", { content: s }); };\n  var peg$f11 = function() {\n            return createNode(\"whitespace\");\n        };\n  var peg$f12 = function(a, b) { return a.join(\"\") + \".\" + b.join(\"\"); };\n  var peg$f13 = function(b) { return \".\" + b.join(\"\"); };\n  var peg$f14 = function(a) { return a.join(\"\") + \".\"; };\n  var peg$f15 = function(s) { return createNode(\"string\", { content: s }); };\n  var peg$f16 = function(env, e, end) { return end == e; };\n  var peg$f17 = function(env, e, x) { return x; };\n  var peg$f18 = function(env, e, x, end) { return end == e; };\n  var peg$f19 = function(env, e, x) {\n            return createNode(\"verb\", {\n                env: env,\n                escape: e,\n                content: x.join(\"\"),\n            });\n        };\n  var peg$f20 = function(x) { return x; };\n  var peg$f21 = function(x) {\n            return createNode(\"displaymath\", { content: x.flatMap((x) => x) });\n        };\n  var peg$f22 = function(x) { return x; };\n  var peg$f23 = function(x) {\n            return createNode(\"inlinemath\", { content: x.flatMap((x) => x) });\n        };\n  var peg$f24 = function(x) { return x; };\n  var peg$f25 = function(x) {\n            return createNode(\"displaymath\", { content: x.flatMap((x) => x) });\n        };\n  var peg$f26 = function(end) {\n                                return (\n                                    end.type === \"string\" && end.content === \"]\"\n                                );\n                            };\n  var peg$f27 = function(x) { return x; };\n  var peg$f28 = function(o) {\n            return [\n                createNode(\"string\", { content: \"[\" }),\n                ...o,\n                createNode(\"string\", { content: \"]\" }),\n            ];\n        };\n  var peg$f29 = function(x) { return x; };\n  var peg$f30 = function(v) {\n            return createNode(\"group\", {\n                content: createNode(\"string\", { content: v.join(\"\") }),\n            });\n        };\n  var peg$f31 = function(d, end) { return end == d; };\n  var peg$f32 = function(d, x) { return x; };\n  var peg$f33 = function(d, v, end) { return end == d; };\n  var peg$f34 = function(d, v) {\n            return [\n                createNode(\"string\", { content: d }),\n                createNode(\"string\", { content: v.join(\"\") }),\n                createNode(\"string\", { content: d }),\n            ];\n        };\n  var peg$f35 = function(macro, option, verbatim) {\n            return [\n                createNode(\"macro\", { content: macro }),\n                ...(option || []),\n                ...[].concat(verbatim),\n            ];\n        };\n  var peg$f36 = function(macro, option, language, verbatim) {\n            return [\n                createNode(\"macro\", { content: macro }),\n                ...(option || []),\n                language,\n                ...[].concat(verbatim),\n            ];\n        };\n  var peg$f37 = function(env, lang, end_env) { return compare_env({ content: [env] }, end_env); };\n  var peg$f38 = function(env, lang, x) { return x; };\n  var peg$f39 = function(env, lang, body) {\n            return createNode(\"verbatim\", {\n                env: `${env}{${lang.content.content}}`,\n                content: body.join(\"\"),\n            });\n        };\n  var peg$f40 = function(env, end_env) { return compare_env({ content: [env] }, end_env); };\n  var peg$f41 = function(env, x) { return x; };\n  var peg$f42 = function(env, body) {\n            return createNode(\"verbatim\", {\n                env: env,\n                content: body.join(\"\"),\n            });\n        };\n  var peg$f43 = function(n) { return n.join(\"\"); };\n  var peg$f44 = function(n) { return n; };\n  var peg$f45 = function(m) {\n            return createNode(\"macro\", { content: m });\n        };\n  var peg$f46 = function(c) { return c; };\n  var peg$f47 = function(x) {\n            return createNode(\"group\", { content: x.flatMap((x) => x) });\n        };\n  var peg$f48 = function(g) { return text().slice(1, -1); };\n  var peg$f49 = function(env, env_comment, end_env) { return compare_env(env, end_env); };\n  var peg$f50 = function(env, env_comment, x) { return x; };\n  var peg$f51 = function(env, env_comment, body) {\n            body = body.flatMap((x) => x);\n            return createNode(\"environment\", {\n                env,\n                content: env_comment ? [env_comment, ...body] : body,\n            });\n        };\n  var peg$f52 = function(env, env_comment, end_env) { return compare_env({ content: [env] }, end_env); };\n  var peg$f53 = function(env, env_comment, x) { return x; };\n  var peg$f54 = function(env, env_comment, body) {\n            body = body.flatMap((x) => x);\n            return createNode(\"mathenv\", {\n                env: env,\n                content: env_comment ? [env_comment, ...body] : body,\n            });\n        };\n  var peg$f55 = function(c) { return c; };\n  var peg$f56 = function(x) {\n            return createNode(\"group\", { content: x.flatMap((x) => x) });\n        };\n  var peg$f57 = function(e) { return createNode(\"string\", { content: e }); };\n  var peg$f58 = function() { return createNode(\"string\", { content: \"\\\\\" }); };\n  var peg$f59 = function(s) { return createNode(\"string\", { content: s }); };\n  var peg$f60 = function(s) { return createNode(\"string\", { content: s }); };\n  var peg$f61 = function(s) { return createNode(\"string\", { content: s }); };\n  var peg$f62 = function(s) { return createNode(\"string\", { content: s }); };\n  var peg$f63 = function(s) { return createNode(\"string\", { content: s }); };\n  var peg$f64 = function(s) { return createNode(\"string\", { content: s }); };\n  var peg$f65 = function(s) { return createNode(\"string\", { content: s }); };\n  var peg$f66 = function() { return \" \"; };\n  var peg$f67 = function(p) {\n            return createNode(\"string\", { content: p });\n        };\n  var peg$f68 = function(leading_sp, comment) {\n            return createNode(\"comment\", {\n                ...comment,\n                sameline: false,\n                leadingWhitespace: leading_sp.length > 0,\n            });\n        };\n  var peg$f69 = function(spaces, x) {\n            return createNode(\"comment\", {\n                ...x,\n                sameline: true,\n                leadingWhitespace: spaces.length > 0,\n            });\n        };\n  var peg$f70 = function(c) { return c; };\n  var peg$f71 = function(c) {\n            return { content: c.join(\"\"), suffixParbreak: true };\n        };\n  var peg$f72 = function(c) { return c; };\n  var peg$f73 = function(c) { return { content: c.join(\"\") }; };\n  var peg$f74 = function() {\n            var loc = location();\n            return loc.start.column === 1;\n        };\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = 0;\n  var peg$maxFailExpected = [];\n  var peg$silentFails = 0;\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsedocument() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsetoken();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsetoken();\n    }\n    peg$savedPos = s0;\n    s1 = peg$f0(s1);\n    s0 = s1;\n    peg$silentFails--;\n    s1 = peg$FAILED;\n    if (peg$silentFails === 0) { peg$fail(peg$e0); }\n\n    return s0;\n  }\n\n  function peg$parsemath() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = [];\n    s1 = peg$parsemath_token();\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = peg$parsemath_token();\n    }\n    peg$silentFails--;\n    s1 = peg$FAILED;\n    if (peg$silentFails === 0) { peg$fail(peg$e1); }\n\n    return s0;\n  }\n\n  function peg$parsetoken() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$parsespecial_macro();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsemacro();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsefull_comment();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsegroup();\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsemath_shift();\n            if (s1 !== peg$FAILED) {\n              s2 = [];\n              s3 = peg$currPos;\n              s4 = peg$currPos;\n              peg$silentFails++;\n              s5 = peg$parsemath_shift();\n              peg$silentFails--;\n              if (s5 === peg$FAILED) {\n                s4 = undefined;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsemath_token();\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s3;\n                  s3 = peg$f1(s5);\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n              if (s3 !== peg$FAILED) {\n                while (s3 !== peg$FAILED) {\n                  s2.push(s3);\n                  s3 = peg$currPos;\n                  s4 = peg$currPos;\n                  peg$silentFails++;\n                  s5 = peg$parsemath_shift();\n                  peg$silentFails--;\n                  if (s5 === peg$FAILED) {\n                    s4 = undefined;\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                  if (s4 !== peg$FAILED) {\n                    s5 = peg$parsemath_token();\n                    if (s5 !== peg$FAILED) {\n                      peg$savedPos = s3;\n                      s3 = peg$f1(s5);\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                }\n              } else {\n                s2 = peg$FAILED;\n              }\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parsemath_shift();\n                if (s3 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s0 = peg$f2(s2);\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsealignment_tab();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parseparbreak();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsemacro_parameter();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parseignore();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parsenumber();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parsewhitespace();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parsepunctuation();\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$currPos;\n                            s1 = peg$currPos;\n                            s2 = [];\n                            s3 = peg$currPos;\n                            s4 = peg$currPos;\n                            peg$silentFails++;\n                            s5 = peg$parsenonchar_token();\n                            peg$silentFails--;\n                            if (s5 === peg$FAILED) {\n                              s4 = undefined;\n                            } else {\n                              peg$currPos = s4;\n                              s4 = peg$FAILED;\n                            }\n                            if (s4 !== peg$FAILED) {\n                              if (input.length > peg$currPos) {\n                                s5 = input.charAt(peg$currPos);\n                                peg$currPos++;\n                              } else {\n                                s5 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$e3); }\n                              }\n                              if (s5 !== peg$FAILED) {\n                                s4 = [s4, s5];\n                                s3 = s4;\n                              } else {\n                                peg$currPos = s3;\n                                s3 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s3;\n                              s3 = peg$FAILED;\n                            }\n                            if (s3 !== peg$FAILED) {\n                              while (s3 !== peg$FAILED) {\n                                s2.push(s3);\n                                s3 = peg$currPos;\n                                s4 = peg$currPos;\n                                peg$silentFails++;\n                                s5 = peg$parsenonchar_token();\n                                peg$silentFails--;\n                                if (s5 === peg$FAILED) {\n                                  s4 = undefined;\n                                } else {\n                                  peg$currPos = s4;\n                                  s4 = peg$FAILED;\n                                }\n                                if (s4 !== peg$FAILED) {\n                                  if (input.length > peg$currPos) {\n                                    s5 = input.charAt(peg$currPos);\n                                    peg$currPos++;\n                                  } else {\n                                    s5 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$e3); }\n                                  }\n                                  if (s5 !== peg$FAILED) {\n                                    s4 = [s4, s5];\n                                    s3 = s4;\n                                  } else {\n                                    peg$currPos = s3;\n                                    s3 = peg$FAILED;\n                                  }\n                                } else {\n                                  peg$currPos = s3;\n                                  s3 = peg$FAILED;\n                                }\n                              }\n                            } else {\n                              s2 = peg$FAILED;\n                            }\n                            if (s2 !== peg$FAILED) {\n                              s1 = input.substring(s1, peg$currPos);\n                            } else {\n                              s1 = s2;\n                            }\n                            if (s1 !== peg$FAILED) {\n                              peg$savedPos = s0;\n                              s1 = peg$f3(s1);\n                            }\n                            s0 = s1;\n                            if (s0 === peg$FAILED) {\n                              s0 = peg$parsebegin_group();\n                              if (s0 === peg$FAILED) {\n                                s0 = peg$parseend_group();\n                                if (s0 === peg$FAILED) {\n                                  s0 = peg$parsemath_shift();\n                                  if (s0 === peg$FAILED) {\n                                    s0 = peg$currPos;\n                                    if (input.length > peg$currPos) {\n                                      s1 = input.charAt(peg$currPos);\n                                      peg$currPos++;\n                                    } else {\n                                      s1 = peg$FAILED;\n                                      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n                                    }\n                                    if (s1 !== peg$FAILED) {\n                                      peg$savedPos = s0;\n                                      s1 = peg$f4(s1);\n                                    }\n                                    s0 = s1;\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseparbreak() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = [];\n    s3 = peg$parsesp();\n    while (s3 !== peg$FAILED) {\n      s2.push(s3);\n      s3 = peg$parsesp();\n    }\n    s3 = peg$parsenl();\n    if (s3 !== peg$FAILED) {\n      s4 = [];\n      s5 = peg$currPos;\n      s6 = [];\n      s7 = peg$parsesp();\n      while (s7 !== peg$FAILED) {\n        s6.push(s7);\n        s7 = peg$parsesp();\n      }\n      s7 = peg$parsenl();\n      if (s7 !== peg$FAILED) {\n        s6 = [s6, s7];\n        s5 = s6;\n      } else {\n        peg$currPos = s5;\n        s5 = peg$FAILED;\n      }\n      if (s5 !== peg$FAILED) {\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$currPos;\n          s6 = [];\n          s7 = peg$parsesp();\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            s7 = peg$parsesp();\n          }\n          s7 = peg$parsenl();\n          if (s7 !== peg$FAILED) {\n            s6 = [s6, s7];\n            s5 = s6;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n        }\n      } else {\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = [];\n        s6 = peg$parsesp();\n        while (s6 !== peg$FAILED) {\n          s5.push(s6);\n          s6 = peg$parsesp();\n        }\n        s6 = peg$currPos;\n        peg$silentFails++;\n        s7 = peg$parsecomment_start();\n        peg$silentFails--;\n        if (s7 === peg$FAILED) {\n          s6 = undefined;\n        } else {\n          peg$currPos = s6;\n          s6 = peg$FAILED;\n        }\n        if (s6 !== peg$FAILED) {\n          s2 = [s2, s3, s4, s5, s6];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsesp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsesp();\n      }\n      s3 = peg$parsenl();\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$currPos;\n        s6 = [];\n        s7 = peg$parsesp();\n        while (s7 !== peg$FAILED) {\n          s6.push(s7);\n          s7 = peg$parsesp();\n        }\n        s7 = peg$parsenl();\n        if (s7 !== peg$FAILED) {\n          s6 = [s6, s7];\n          s5 = s6;\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = [];\n            s7 = peg$parsesp();\n            while (s7 !== peg$FAILED) {\n              s6.push(s7);\n              s7 = peg$parsesp();\n            }\n            s7 = peg$parsenl();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f5();\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e4); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemath_token() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$parsespecial_macro();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsemacro();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsefull_comment();\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parsewhitespace();\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parsewhitespace();\n          }\n          s2 = peg$parsegroup();\n          if (s2 !== peg$FAILED) {\n            s3 = [];\n            s4 = peg$parsewhitespace();\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parsewhitespace();\n            }\n            peg$savedPos = s0;\n            s0 = peg$f6(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = [];\n            s2 = peg$parsewhitespace();\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n              s2 = peg$parsewhitespace();\n            }\n            s2 = peg$parsealignment_tab();\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n              s4 = peg$parsewhitespace();\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                s4 = peg$parsewhitespace();\n              }\n              peg$savedPos = s0;\n              s0 = peg$f7(s2);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsemacro_parameter();\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = [];\n                s2 = peg$parsewhitespace();\n                while (s2 !== peg$FAILED) {\n                  s1.push(s2);\n                  s2 = peg$parsewhitespace();\n                }\n                s2 = peg$parsesuperscript();\n                if (s2 !== peg$FAILED) {\n                  s3 = [];\n                  s4 = peg$parsewhitespace();\n                  while (s4 !== peg$FAILED) {\n                    s3.push(s4);\n                    s4 = peg$parsewhitespace();\n                  }\n                  peg$savedPos = s0;\n                  s0 = peg$f8();\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n                if (s0 === peg$FAILED) {\n                  s0 = peg$currPos;\n                  s1 = [];\n                  s2 = peg$parsewhitespace();\n                  while (s2 !== peg$FAILED) {\n                    s1.push(s2);\n                    s2 = peg$parsewhitespace();\n                  }\n                  s2 = peg$parsesubscript();\n                  if (s2 !== peg$FAILED) {\n                    s3 = [];\n                    s4 = peg$parsewhitespace();\n                    while (s4 !== peg$FAILED) {\n                      s3.push(s4);\n                      s4 = peg$parsewhitespace();\n                    }\n                    peg$savedPos = s0;\n                    s0 = peg$f9();\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parseignore();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parsewhitespace();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$currPos;\n                        if (input.length > peg$currPos) {\n                          s1 = input.charAt(peg$currPos);\n                          peg$currPos++;\n                        } else {\n                          s1 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$e3); }\n                        }\n                        if (s1 !== peg$FAILED) {\n                          peg$savedPos = s0;\n                          s1 = peg$f10(s1);\n                        }\n                        s0 = s1;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e5); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsenonchar_token() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parseescape();\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 37) {\n        s0 = peg$c0;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e7); }\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsebegin_group();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseend_group();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsemath_shift();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsealignment_tab();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsenl();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsemacro_parameter();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parseignore();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parsesp();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parsepunctuation();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parseEOF();\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e6); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsewhitespace() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsenl();\n    if (s2 !== peg$FAILED) {\n      s3 = [];\n      s4 = peg$parsesp();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parsesp();\n      }\n      s2 = [s2, s3];\n      s1 = s2;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsesp();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsesp();\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenl();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsecomment_start();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = undefined;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsesp();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsesp();\n            }\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsenl();\n            peg$silentFails--;\n            if (s7 === peg$FAILED) {\n              s6 = undefined;\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5, s6];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = [];\n        s2 = peg$parsesp();\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parsesp();\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f11();\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e8); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = [];\n    s3 = peg$parsenum();\n    if (s3 !== peg$FAILED) {\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsenum();\n      }\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e10); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsenum();\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsenum();\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s1 = peg$f12(s2, s4);\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s2 = peg$c1;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e10); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsenum();\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsenum();\n          }\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s1 = peg$f13(s3);\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = [];\n        s3 = peg$parsenum();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsenum();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s3 = peg$c1;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e10); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s1 = peg$f14(s2);\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f15(s1);\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e9); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsespecial_macro() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseescape();\n    if (s1 !== peg$FAILED) {\n      if (input.substr(peg$currPos, 5) === peg$c2) {\n        s2 = peg$c2;\n        peg$currPos += 5;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e12); }\n      }\n      if (s2 === peg$FAILED) {\n        if (input.substr(peg$currPos, 4) === peg$c3) {\n          s2 = peg$c3;\n          peg$currPos += 4;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e13); }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e3); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$currPos;\n          if (input.length > peg$currPos) {\n            s8 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e3); }\n          }\n          if (s8 !== peg$FAILED) {\n            peg$savedPos = peg$currPos;\n            s9 = peg$f16(s2, s3, s8);\n            if (s9) {\n              s9 = undefined;\n            } else {\n              s9 = peg$FAILED;\n            }\n            if (s9 !== peg$FAILED) {\n              s8 = [s8, s9];\n              s7 = s8;\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s7;\n            s7 = peg$FAILED;\n          }\n          peg$silentFails--;\n          if (s7 === peg$FAILED) {\n            s6 = undefined;\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s7 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s7 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e3); }\n            }\n            if (s7 !== peg$FAILED) {\n              peg$savedPos = s5;\n              s5 = peg$f17(s2, s3, s7);\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$currPos;\n            if (input.length > peg$currPos) {\n              s8 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s8 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e3); }\n            }\n            if (s8 !== peg$FAILED) {\n              peg$savedPos = peg$currPos;\n              s9 = peg$f16(s2, s3, s8);\n              if (s9) {\n                s9 = undefined;\n              } else {\n                s9 = peg$FAILED;\n              }\n              if (s9 !== peg$FAILED) {\n                s8 = [s8, s9];\n                s7 = s8;\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n            peg$silentFails--;\n            if (s7 === peg$FAILED) {\n              s6 = undefined;\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s7 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e3); }\n              }\n              if (s7 !== peg$FAILED) {\n                peg$savedPos = s5;\n                s5 = peg$f17(s2, s3, s7);\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          }\n          s5 = peg$currPos;\n          if (input.length > peg$currPos) {\n            s6 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e3); }\n          }\n          if (s6 !== peg$FAILED) {\n            peg$savedPos = peg$currPos;\n            s7 = peg$f18(s2, s3, s4, s6);\n            if (s7) {\n              s7 = undefined;\n            } else {\n              s7 = peg$FAILED;\n            }\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f19(s2, s3, s4);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseverbatim_listings();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseverbatim_minted();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseverbatim_environment();\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsebegin_display_math();\n            if (s1 !== peg$FAILED) {\n              s2 = [];\n              s3 = peg$currPos;\n              s4 = peg$currPos;\n              peg$silentFails++;\n              s5 = peg$parseend_display_math();\n              peg$silentFails--;\n              if (s5 === peg$FAILED) {\n                s4 = undefined;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsemath_token();\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s3;\n                  s3 = peg$f20(s5);\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$currPos;\n                s4 = peg$currPos;\n                peg$silentFails++;\n                s5 = peg$parseend_display_math();\n                peg$silentFails--;\n                if (s5 === peg$FAILED) {\n                  s4 = undefined;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parsemath_token();\n                  if (s5 !== peg$FAILED) {\n                    peg$savedPos = s3;\n                    s3 = peg$f20(s5);\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              }\n              s3 = peg$parseend_display_math();\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f21(s2);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parsebegin_inline_math();\n              if (s1 !== peg$FAILED) {\n                s2 = [];\n                s3 = peg$currPos;\n                s4 = peg$currPos;\n                peg$silentFails++;\n                s5 = peg$parseend_inline_math();\n                peg$silentFails--;\n                if (s5 === peg$FAILED) {\n                  s4 = undefined;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parsemath_token();\n                  if (s5 !== peg$FAILED) {\n                    peg$savedPos = s3;\n                    s3 = peg$f22(s5);\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n                while (s3 !== peg$FAILED) {\n                  s2.push(s3);\n                  s3 = peg$currPos;\n                  s4 = peg$currPos;\n                  peg$silentFails++;\n                  s5 = peg$parseend_inline_math();\n                  peg$silentFails--;\n                  if (s5 === peg$FAILED) {\n                    s4 = undefined;\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                  if (s4 !== peg$FAILED) {\n                    s5 = peg$parsemath_token();\n                    if (s5 !== peg$FAILED) {\n                      peg$savedPos = s3;\n                      s3 = peg$f22(s5);\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                }\n                s3 = peg$parseend_inline_math();\n                if (s3 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s0 = peg$f23(s2);\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = peg$parsemath_shift();\n                if (s1 !== peg$FAILED) {\n                  s2 = peg$parsemath_shift();\n                  if (s2 !== peg$FAILED) {\n                    s3 = [];\n                    s4 = peg$currPos;\n                    s5 = peg$currPos;\n                    peg$silentFails++;\n                    s6 = peg$currPos;\n                    s7 = peg$parsemath_shift();\n                    if (s7 !== peg$FAILED) {\n                      s8 = peg$parsemath_shift();\n                      if (s8 !== peg$FAILED) {\n                        s7 = [s7, s8];\n                        s6 = s7;\n                      } else {\n                        peg$currPos = s6;\n                        s6 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$FAILED;\n                    }\n                    peg$silentFails--;\n                    if (s6 === peg$FAILED) {\n                      s5 = undefined;\n                    } else {\n                      peg$currPos = s5;\n                      s5 = peg$FAILED;\n                    }\n                    if (s5 !== peg$FAILED) {\n                      s6 = peg$parsemath_token();\n                      if (s6 !== peg$FAILED) {\n                        peg$savedPos = s4;\n                        s4 = peg$f24(s6);\n                      } else {\n                        peg$currPos = s4;\n                        s4 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s4;\n                      s4 = peg$FAILED;\n                    }\n                    while (s4 !== peg$FAILED) {\n                      s3.push(s4);\n                      s4 = peg$currPos;\n                      s5 = peg$currPos;\n                      peg$silentFails++;\n                      s6 = peg$currPos;\n                      s7 = peg$parsemath_shift();\n                      if (s7 !== peg$FAILED) {\n                        s8 = peg$parsemath_shift();\n                        if (s8 !== peg$FAILED) {\n                          s7 = [s7, s8];\n                          s6 = s7;\n                        } else {\n                          peg$currPos = s6;\n                          s6 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s6;\n                        s6 = peg$FAILED;\n                      }\n                      peg$silentFails--;\n                      if (s6 === peg$FAILED) {\n                        s5 = undefined;\n                      } else {\n                        peg$currPos = s5;\n                        s5 = peg$FAILED;\n                      }\n                      if (s5 !== peg$FAILED) {\n                        s6 = peg$parsemath_token();\n                        if (s6 !== peg$FAILED) {\n                          peg$savedPos = s4;\n                          s4 = peg$f24(s6);\n                        } else {\n                          peg$currPos = s4;\n                          s4 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s4;\n                        s4 = peg$FAILED;\n                      }\n                    }\n                    s4 = peg$parsemath_shift();\n                    if (s4 !== peg$FAILED) {\n                      s5 = peg$parsemath_shift();\n                      if (s5 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s0 = peg$f25(s3);\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsemath_environment();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parseenvironment();\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e11); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesquare_bracket_argument() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c4;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e14); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      s5 = peg$currPos;\n      s6 = peg$parsetoken();\n      if (s6 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s7 = peg$f26(s6);\n        if (s7) {\n          s7 = undefined;\n        } else {\n          s7 = peg$FAILED;\n        }\n        if (s7 !== peg$FAILED) {\n          s6 = [s6, s7];\n          s5 = s6;\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s5;\n        s5 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsetoken();\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s3 = peg$f27(s5);\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$currPos;\n        s6 = peg$parsetoken();\n        if (s6 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s7 = peg$f26(s6);\n          if (s7) {\n            s7 = undefined;\n          } else {\n            s7 = peg$FAILED;\n          }\n          if (s7 !== peg$FAILED) {\n            s6 = [s6, s7];\n            s5 = s6;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsetoken();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s3 = peg$f27(s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (input.charCodeAt(peg$currPos) === 93) {\n        s3 = peg$c5;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e15); }\n      }\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f28(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseverbatim_group() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsebegin_group();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      s5 = peg$parseend_group();\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e3); }\n        }\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s3 = peg$f29(s5);\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parseend_group();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e3); }\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s3 = peg$f29(s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      s3 = peg$parseend_group();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f30(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseverbatim_delimited_by_char() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    if (peg$r0.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e16); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      s5 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s6 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s6 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e3); }\n      }\n      if (s6 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s7 = peg$f31(s1, s6);\n        if (s7) {\n          s7 = undefined;\n        } else {\n          s7 = peg$FAILED;\n        }\n        if (s7 !== peg$FAILED) {\n          s6 = [s6, s7];\n          s5 = s6;\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s5;\n        s5 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e3); }\n        }\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s3 = peg$f32(s1, s5);\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s6 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e3); }\n        }\n        if (s6 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s7 = peg$f31(s1, s6);\n          if (s7) {\n            s7 = undefined;\n          } else {\n            s7 = peg$FAILED;\n          }\n          if (s7 !== peg$FAILED) {\n            s6 = [s6, s7];\n            s5 = s6;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e3); }\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s3 = peg$f32(s1, s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      s3 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s4 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e3); }\n      }\n      if (s4 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s5 = peg$f33(s1, s2, s4);\n        if (s5) {\n          s5 = undefined;\n        } else {\n          s5 = peg$FAILED;\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f34(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseverbatim_listings() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseescape();\n    if (s1 !== peg$FAILED) {\n      if (input.substr(peg$currPos, 9) === peg$c6) {\n        s2 = peg$c6;\n        peg$currPos += 9;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e18); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsesquare_bracket_argument();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        s4 = peg$parseverbatim_group();\n        if (s4 === peg$FAILED) {\n          s4 = peg$parseverbatim_delimited_by_char();\n        }\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f35(s2, s3, s4);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e17); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseverbatim_minted() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseescape();\n    if (s1 !== peg$FAILED) {\n      if (input.substr(peg$currPos, 10) === peg$c7) {\n        s2 = peg$c7;\n        peg$currPos += 10;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e20); }\n      }\n      if (s2 === peg$FAILED) {\n        if (input.substr(peg$currPos, 4) === peg$c8) {\n          s2 = peg$c8;\n          peg$currPos += 4;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e21); }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsesquare_bracket_argument();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        s4 = peg$parsegroup();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseverbatim_group();\n          if (s5 === peg$FAILED) {\n            s5 = peg$parseverbatim_delimited_by_char();\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f36(s2, s3, s4, s5);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e19); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseverbatim_minted_environment() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsebegin_env();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsebegin_group();\n      if (s2 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 6) === peg$c9) {\n          s3 = peg$c9;\n          peg$currPos += 6;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e23); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseend_group();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsegroup();\n            if (s5 !== peg$FAILED) {\n              s6 = [];\n              s7 = peg$currPos;\n              s8 = peg$currPos;\n              peg$silentFails++;\n              s9 = peg$currPos;\n              s10 = peg$parseend_env();\n              if (s10 !== peg$FAILED) {\n                s11 = peg$parsegroup();\n                if (s11 !== peg$FAILED) {\n                  peg$savedPos = peg$currPos;\n                  s12 = peg$f37(s3, s5, s11);\n                  if (s12) {\n                    s12 = undefined;\n                  } else {\n                    s12 = peg$FAILED;\n                  }\n                  if (s12 !== peg$FAILED) {\n                    s10 = [s10, s11, s12];\n                    s9 = s10;\n                  } else {\n                    peg$currPos = s9;\n                    s9 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s9;\n                  s9 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s9;\n                s9 = peg$FAILED;\n              }\n              peg$silentFails--;\n              if (s9 === peg$FAILED) {\n                s8 = undefined;\n              } else {\n                peg$currPos = s8;\n                s8 = peg$FAILED;\n              }\n              if (s8 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s9 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s9 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e3); }\n                }\n                if (s9 !== peg$FAILED) {\n                  peg$savedPos = s7;\n                  s7 = peg$f38(s3, s5, s9);\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n              while (s7 !== peg$FAILED) {\n                s6.push(s7);\n                s7 = peg$currPos;\n                s8 = peg$currPos;\n                peg$silentFails++;\n                s9 = peg$currPos;\n                s10 = peg$parseend_env();\n                if (s10 !== peg$FAILED) {\n                  s11 = peg$parsegroup();\n                  if (s11 !== peg$FAILED) {\n                    peg$savedPos = peg$currPos;\n                    s12 = peg$f37(s3, s5, s11);\n                    if (s12) {\n                      s12 = undefined;\n                    } else {\n                      s12 = peg$FAILED;\n                    }\n                    if (s12 !== peg$FAILED) {\n                      s10 = [s10, s11, s12];\n                      s9 = s10;\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s9;\n                    s9 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s9;\n                  s9 = peg$FAILED;\n                }\n                peg$silentFails--;\n                if (s9 === peg$FAILED) {\n                  s8 = undefined;\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n                if (s8 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s9 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s9 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e3); }\n                  }\n                  if (s9 !== peg$FAILED) {\n                    peg$savedPos = s7;\n                    s7 = peg$f38(s3, s5, s9);\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              }\n              s7 = peg$parseend_env();\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parsebegin_group();\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$parseverbatim_env_name();\n                  if (s9 !== peg$FAILED) {\n                    s10 = peg$parseend_group();\n                    if (s10 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s0 = peg$f39(s3, s5, s6);\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e22); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseverbatim_environment() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsebegin_env();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsebegin_group();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseverbatim_env_name();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseend_group();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$currPos;\n            s7 = peg$currPos;\n            peg$silentFails++;\n            s8 = peg$currPos;\n            s9 = peg$parseend_env();\n            if (s9 !== peg$FAILED) {\n              s10 = peg$parsegroup();\n              if (s10 !== peg$FAILED) {\n                peg$savedPos = peg$currPos;\n                s11 = peg$f40(s3, s10);\n                if (s11) {\n                  s11 = undefined;\n                } else {\n                  s11 = peg$FAILED;\n                }\n                if (s11 !== peg$FAILED) {\n                  s9 = [s9, s10, s11];\n                  s8 = s9;\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s8;\n                s8 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s8;\n              s8 = peg$FAILED;\n            }\n            peg$silentFails--;\n            if (s8 === peg$FAILED) {\n              s7 = undefined;\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n            if (s7 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s8 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s8 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e3); }\n              }\n              if (s8 !== peg$FAILED) {\n                peg$savedPos = s6;\n                s6 = peg$f41(s3, s8);\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$currPos;\n              s7 = peg$currPos;\n              peg$silentFails++;\n              s8 = peg$currPos;\n              s9 = peg$parseend_env();\n              if (s9 !== peg$FAILED) {\n                s10 = peg$parsegroup();\n                if (s10 !== peg$FAILED) {\n                  peg$savedPos = peg$currPos;\n                  s11 = peg$f40(s3, s10);\n                  if (s11) {\n                    s11 = undefined;\n                  } else {\n                    s11 = peg$FAILED;\n                  }\n                  if (s11 !== peg$FAILED) {\n                    s9 = [s9, s10, s11];\n                    s8 = s9;\n                  } else {\n                    peg$currPos = s8;\n                    s8 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s8;\n                s8 = peg$FAILED;\n              }\n              peg$silentFails--;\n              if (s8 === peg$FAILED) {\n                s7 = undefined;\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n              if (s7 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s8 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s8 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e3); }\n                }\n                if (s8 !== peg$FAILED) {\n                  peg$savedPos = s6;\n                  s6 = peg$f41(s3, s8);\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            }\n            s6 = peg$parseend_env();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsebegin_group();\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parseverbatim_env_name();\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$parseend_group();\n                  if (s9 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s0 = peg$f42(s3, s5);\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e24); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseverbatim_env_name() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c10) {\n      s0 = peg$c10;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e25); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 8) === peg$c11) {\n        s0 = peg$c11;\n        peg$currPos += 8;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e26); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 13) === peg$c12) {\n          s0 = peg$c12;\n          peg$currPos += 13;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e27); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 12) === peg$c13) {\n            s0 = peg$c13;\n            peg$currPos += 12;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e28); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 7) === peg$c14) {\n              s0 = peg$c14;\n              peg$currPos += 7;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e29); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 10) === peg$c15) {\n                s0 = peg$c15;\n                peg$currPos += 10;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e30); }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemacro() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parseescape();\n    if (s2 !== peg$FAILED) {\n      s3 = [];\n      s4 = peg$parsechar();\n      if (s4 !== peg$FAILED) {\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsechar();\n        }\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s1;\n        s1 = peg$f43(s3);\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parseescape();\n      if (s2 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e3); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s1 = peg$f44(s3);\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f45(s1);\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e31); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsegroup() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsebegin_group();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      s5 = peg$parseend_group();\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsetoken();\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s3 = peg$f46(s5);\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parseend_group();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsetoken();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s3 = peg$f46(s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      s3 = peg$parseend_group();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f47(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e32); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsegroup_contents_as_string() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parsegroup();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f48(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseenvironment() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsebegin_env();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsegroup_contents_as_string();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsesameline_comment();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        s4 = [];\n        s5 = peg$currPos;\n        s6 = peg$currPos;\n        peg$silentFails++;\n        s7 = peg$currPos;\n        s8 = peg$parseend_env();\n        if (s8 !== peg$FAILED) {\n          s9 = peg$parsegroup_contents_as_string();\n          if (s9 !== peg$FAILED) {\n            peg$savedPos = peg$currPos;\n            s10 = peg$f49(s2, s3, s9);\n            if (s10) {\n              s10 = undefined;\n            } else {\n              s10 = peg$FAILED;\n            }\n            if (s10 !== peg$FAILED) {\n              s8 = [s8, s9, s10];\n              s7 = s8;\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s7;\n            s7 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s7;\n          s7 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s7 === peg$FAILED) {\n          s6 = undefined;\n        } else {\n          peg$currPos = s6;\n          s6 = peg$FAILED;\n        }\n        if (s6 !== peg$FAILED) {\n          s7 = peg$parsetoken();\n          if (s7 !== peg$FAILED) {\n            peg$savedPos = s5;\n            s5 = peg$f50(s2, s3, s7);\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$currPos;\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$currPos;\n          s8 = peg$parseend_env();\n          if (s8 !== peg$FAILED) {\n            s9 = peg$parsegroup_contents_as_string();\n            if (s9 !== peg$FAILED) {\n              peg$savedPos = peg$currPos;\n              s10 = peg$f49(s2, s3, s9);\n              if (s10) {\n                s10 = undefined;\n              } else {\n                s10 = peg$FAILED;\n              }\n              if (s10 !== peg$FAILED) {\n                s8 = [s8, s9, s10];\n                s7 = s8;\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s7;\n            s7 = peg$FAILED;\n          }\n          peg$silentFails--;\n          if (s7 === peg$FAILED) {\n            s6 = undefined;\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsetoken();\n            if (s7 !== peg$FAILED) {\n              peg$savedPos = s5;\n              s5 = peg$f50(s2, s3, s7);\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n        }\n        s5 = peg$parseend_env();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsegroup_contents_as_string();\n          if (s6 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f51(s2, s3, s4);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e33); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemath_environment() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsebegin_env();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsebegin_group();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsemath_env_name();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseend_group();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesameline_comment();\n            if (s5 === peg$FAILED) {\n              s5 = null;\n            }\n            s6 = [];\n            s7 = peg$currPos;\n            s8 = peg$currPos;\n            peg$silentFails++;\n            s9 = peg$currPos;\n            s10 = peg$parseend_env();\n            if (s10 !== peg$FAILED) {\n              s11 = peg$parsegroup();\n              if (s11 !== peg$FAILED) {\n                peg$savedPos = peg$currPos;\n                s12 = peg$f52(s3, s5, s11);\n                if (s12) {\n                  s12 = undefined;\n                } else {\n                  s12 = peg$FAILED;\n                }\n                if (s12 !== peg$FAILED) {\n                  s10 = [s10, s11, s12];\n                  s9 = s10;\n                } else {\n                  peg$currPos = s9;\n                  s9 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s9;\n                s9 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s9;\n              s9 = peg$FAILED;\n            }\n            peg$silentFails--;\n            if (s9 === peg$FAILED) {\n              s8 = undefined;\n            } else {\n              peg$currPos = s8;\n              s8 = peg$FAILED;\n            }\n            if (s8 !== peg$FAILED) {\n              s9 = peg$parsemath_token();\n              if (s9 !== peg$FAILED) {\n                peg$savedPos = s7;\n                s7 = peg$f53(s3, s5, s9);\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n            while (s7 !== peg$FAILED) {\n              s6.push(s7);\n              s7 = peg$currPos;\n              s8 = peg$currPos;\n              peg$silentFails++;\n              s9 = peg$currPos;\n              s10 = peg$parseend_env();\n              if (s10 !== peg$FAILED) {\n                s11 = peg$parsegroup();\n                if (s11 !== peg$FAILED) {\n                  peg$savedPos = peg$currPos;\n                  s12 = peg$f52(s3, s5, s11);\n                  if (s12) {\n                    s12 = undefined;\n                  } else {\n                    s12 = peg$FAILED;\n                  }\n                  if (s12 !== peg$FAILED) {\n                    s10 = [s10, s11, s12];\n                    s9 = s10;\n                  } else {\n                    peg$currPos = s9;\n                    s9 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s9;\n                  s9 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s9;\n                s9 = peg$FAILED;\n              }\n              peg$silentFails--;\n              if (s9 === peg$FAILED) {\n                s8 = undefined;\n              } else {\n                peg$currPos = s8;\n                s8 = peg$FAILED;\n              }\n              if (s8 !== peg$FAILED) {\n                s9 = peg$parsemath_token();\n                if (s9 !== peg$FAILED) {\n                  peg$savedPos = s7;\n                  s7 = peg$f53(s3, s5, s9);\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            }\n            s7 = peg$parseend_env();\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parsebegin_group();\n              if (s8 !== peg$FAILED) {\n                s9 = peg$parsemath_env_name();\n                if (s9 !== peg$FAILED) {\n                  s10 = peg$parseend_group();\n                  if (s10 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s0 = peg$f54(s3, s5, s6);\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e34); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemath_group() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsebegin_group();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      s5 = peg$parseend_group();\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsemath_token();\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s3 = peg$f55(s5);\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parseend_group();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsemath_token();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s3 = peg$f55(s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      s3 = peg$parseend_group();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f56(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e35); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsebegin_display_math() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseescape();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s2 = peg$c4;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e14); }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseend_display_math() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseescape();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 93) {\n        s2 = peg$c5;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e15); }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsebegin_inline_math() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseescape();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s2 = peg$c16;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e36); }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseend_inline_math() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseescape();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 41) {\n        s2 = peg$c17;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e37); }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsebegin_env() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseescape();\n    if (s1 !== peg$FAILED) {\n      if (input.substr(peg$currPos, 5) === peg$c18) {\n        s2 = peg$c18;\n        peg$currPos += 5;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e38); }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseend_env() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseescape();\n    if (s1 !== peg$FAILED) {\n      if (input.substr(peg$currPos, 3) === peg$c19) {\n        s2 = peg$c19;\n        peg$currPos += 3;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e39); }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemath_env_name() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 9) === peg$c20) {\n      s1 = peg$c20;\n      peg$currPos += 9;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e40); }\n    }\n    if (s1 === peg$FAILED) {\n      if (input.substr(peg$currPos, 8) === peg$c21) {\n        s1 = peg$c21;\n        peg$currPos += 8;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e41); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.substr(peg$currPos, 6) === peg$c22) {\n          s1 = peg$c22;\n          peg$currPos += 6;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e42); }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.substr(peg$currPos, 5) === peg$c23) {\n            s1 = peg$c23;\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e43); }\n          }\n          if (s1 === peg$FAILED) {\n            if (input.substr(peg$currPos, 8) === peg$c24) {\n              s1 = peg$c24;\n              peg$currPos += 8;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e44); }\n            }\n            if (s1 === peg$FAILED) {\n              if (input.substr(peg$currPos, 7) === peg$c25) {\n                s1 = peg$c25;\n                peg$currPos += 7;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e45); }\n              }\n              if (s1 === peg$FAILED) {\n                if (input.substr(peg$currPos, 7) === peg$c26) {\n                  s1 = peg$c26;\n                  peg$currPos += 7;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e46); }\n                }\n                if (s1 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 6) === peg$c27) {\n                    s1 = peg$c27;\n                    peg$currPos += 6;\n                  } else {\n                    s1 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e47); }\n                  }\n                  if (s1 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 9) === peg$c28) {\n                      s1 = peg$c28;\n                      peg$currPos += 9;\n                    } else {\n                      s1 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$e48); }\n                    }\n                    if (s1 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 8) === peg$c29) {\n                        s1 = peg$c29;\n                        peg$currPos += 8;\n                      } else {\n                        s1 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$e49); }\n                      }\n                      if (s1 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 8) === peg$c30) {\n                          s1 = peg$c30;\n                          peg$currPos += 8;\n                        } else {\n                          s1 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$e50); }\n                        }\n                        if (s1 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 7) === peg$c31) {\n                            s1 = peg$c31;\n                            peg$currPos += 7;\n                          } else {\n                            s1 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$e51); }\n                          }\n                          if (s1 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 5) === peg$c32) {\n                              s1 = peg$c32;\n                              peg$currPos += 5;\n                            } else {\n                              s1 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$e52); }\n                            }\n                            if (s1 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 4) === peg$c33) {\n                                s1 = peg$c33;\n                                peg$currPos += 4;\n                              } else {\n                                s1 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$e53); }\n                              }\n                              if (s1 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 11) === peg$c34) {\n                                  s1 = peg$c34;\n                                  peg$currPos += 11;\n                                } else {\n                                  s1 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$e54); }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f57(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseescape() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 92) {\n      s1 = peg$c35;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e56); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f58();\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e55); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsebegin_group() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s1 = peg$c36;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e57); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f59(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseend_group() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 125) {\n      s1 = peg$c37;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e58); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f60(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsemath_shift() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 36) {\n      s1 = peg$c38;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e59); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f61(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsealignment_tab() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 38) {\n      s1 = peg$c39;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e60); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f62(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsenl() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 13) {\n      s2 = peg$c40;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e62); }\n    }\n    peg$silentFails--;\n    if (s2 === peg$FAILED) {\n      s1 = undefined;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 10) {\n        s2 = peg$c41;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e63); }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 13) {\n        s0 = peg$c40;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e62); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c42) {\n          s0 = peg$c42;\n          peg$currPos += 2;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e64); }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e61); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemacro_parameter() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s1 = peg$c43;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e65); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f63(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesuperscript() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 94) {\n      s1 = peg$c44;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e66); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f64(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesubscript() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 95) {\n      s1 = peg$c45;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e67); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f65(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseignore() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 0) {\n      s0 = peg$c46;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e68); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesp() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$r1.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e69); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$r1.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e69); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f66();\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e8); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsechar() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (peg$r2.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e71); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e70); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsenum() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (peg$r3.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e73); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e72); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsepunctuation() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (peg$r4.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e75); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f67(s1);\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e74); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomment_start() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 37) {\n      s0 = peg$c0;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e7); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefull_comment() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parseownline_comment();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsesameline_comment();\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e76); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseownline_comment() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = [];\n    s3 = peg$parsesp();\n    while (s3 !== peg$FAILED) {\n      s2.push(s3);\n      s3 = peg$parsesp();\n    }\n    s3 = peg$parsenl();\n    if (s3 !== peg$FAILED) {\n      s2 = [s2, s3];\n      s1 = s2;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    s2 = peg$parseleading_sp();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsecomment();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f68(s2, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesameline_comment() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsesp();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsesp();\n    }\n    s2 = peg$parsecomment();\n    if (s2 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f69(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomment() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsecomment_start();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      s5 = peg$parsenl();\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e3); }\n        }\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s3 = peg$f70(s5);\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parsenl();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e3); }\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s3 = peg$f70(s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      s3 = peg$currPos;\n      peg$silentFails++;\n      s4 = peg$parseparbreak();\n      peg$silentFails--;\n      if (s4 !== peg$FAILED) {\n        peg$currPos = s3;\n        s3 = undefined;\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f71(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsecomment_start();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parsenl();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e3); }\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s3 = peg$f72(s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsenl();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = undefined;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e3); }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s3 = peg$f72(s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        s3 = peg$currPos;\n        s4 = peg$parsenl();\n        if (s4 !== peg$FAILED) {\n          s5 = [];\n          s6 = peg$parsesp();\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            s6 = peg$parsesp();\n          }\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsecomment_start();\n          peg$silentFails--;\n          if (s7 === peg$FAILED) {\n            s6 = undefined;\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            s4 = [s4, s5, s6];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsenl();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parseEOF();\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f73(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e77); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseleading_sp() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsestart_of_line();\n    if (s2 !== peg$FAILED) {\n      s3 = [];\n      s4 = peg$parsesp();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parsesp();\n      }\n      s2 = [s2, s3];\n      s1 = s2;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestart_of_line() {\n    var s0;\n\n    peg$savedPos = peg$currPos;\n    s0 = peg$f74();\n    if (s0) {\n      s0 = undefined;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOF() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    peg$silentFails++;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    peg$silentFails--;\n    if (s1 === peg$FAILED) {\n      s0 = undefined;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n\n    function toString(e) {\n        if (typeof e === \"string\") {\n            return e;\n        }\n        if (typeof e.content === \"string\") {\n            return e.content;\n        }\n        if (e && e.type === \"whitespace\") {\n            return \" \";\n        }\n        return e;\n    }\n\n    function compare_env(g1, g2) {\n        const g1Name =\n            typeof g1 === \"string\" ? g1 : g1.content.map(toString).join(\"\");\n        const g2Name =\n            typeof g2 === \"string\" ? g2 : g2.content.map(toString).join(\"\");\n        return g1Name === g2Name;\n    }\n\n    function createNode(type, extra = {}) {\n        return { type, ...extra, position: location() };\n    }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n})()\n", "export default // Generated by Peggy 2.0.1.\n//\n// https://peggyjs.org/\n(function() {\n  \"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { body: peg$parsebody };\n  var peg$startRuleFunction = peg$parsebody;\n\n\n\n  var peg$e0 = peg$anyExpectation();\n\n  var peg$f0 = function() { return []; };\n  var peg$f1 = function(x) { return { cells: [], colSeps: [], ...x }; };\n  var peg$f2 = function(rowItems, rowSep, trailingComment) {\n            return { ...rowItems, rowSep, trailingComment };\n        };\n  var peg$f3 = function(rowItems, trailingComment) {\n            return { ...rowItems, rowSep: null, trailingComment };\n        };\n  var peg$f4 = function(x) { return x; };\n  var peg$f5 = function(x) {\n            return {\n                cells: [],\n                colSeps: [],\n                rowSep: null,\n                trailingComment: x,\n            };\n        };\n  var peg$f6 = function(x) {\n            return x;\n        };\n  var peg$f7 = function(colSep, cell) { return { colSep, cell }; };\n  var peg$f8 = function(colSep) { return { colSep }; };\n  var peg$f9 = function(a, b) { return processRow(a, b); };\n  var peg$f10 = function(b) { return processRow(null, b); };\n  var peg$f11 = function(tok) { return options.isSameLineComment(tok); };\n  var peg$f12 = function(tok) { return tok; };\n  var peg$f13 = function(tok) { return options.isOwnLineComment(tok); };\n  var peg$f14 = function(tok) { return tok; };\n  var peg$f15 = function(tok) { return options.isWhitespace(tok); };\n  var peg$f16 = function(tok) { return tok; };\n  var peg$f17 = function(tok) { return options.isRowSep(tok); };\n  var peg$f18 = function(tok) { return tok; };\n  var peg$f19 = function(tok) { return options.isColSep(tok); };\n  var peg$f20 = function(tok) { return tok; };\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = 0;\n  var peg$maxFailExpected = [];\n  var peg$silentFails = 0;\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsebody() {\n    var s0, s1;\n\n    s0 = [];\n    s1 = peg$parsecomment_only_line();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parserow_with_end();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parserow_without_end();\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        s1 = peg$parsecomment_only_line();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parserow_with_end();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parserow_without_end();\n          }\n        }\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseEOL();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f0();\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parserow_with_end() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parserow_items();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    peg$savedPos = s1;\n    s2 = peg$f1(s2);\n    s1 = s2;\n    s2 = peg$parserow_sep();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsetrailing_comment();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f2(s1, s2, s3);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parserow_without_end() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parserow_items();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsetrailing_comment();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f3(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsetrailing_comment() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewhitespace();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsewhitespace();\n    }\n    s2 = peg$parsesame_line_comment();\n    if (s2 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f4(s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomment_only_line() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewhitespace();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsewhitespace();\n    }\n    s2 = peg$parseown_line_comment();\n    if (s2 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f5(s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsetoken() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    s2 = peg$parserow_sep();\n    if (s2 === peg$FAILED) {\n      s2 = peg$parsecol_sep();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsetrailing_comment();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseown_line_comment();\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s2 === peg$FAILED) {\n      s1 = undefined;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.length > peg$currPos) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e0); }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f6(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecell() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsetoken();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsetoken();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseseparated_cell() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecol_sep();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecell();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f7(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsecol_sep();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f8(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parserow_items() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecell();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseseparated_cell();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseseparated_cell();\n      }\n      peg$savedPos = s0;\n      s0 = peg$f9(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseseparated_cell();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseseparated_cell();\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f10(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesame_line_comment() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f11(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f12(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseown_line_comment() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f13(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f14(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsewhitespace() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f15(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f16(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parserow_sep() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f17(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f18(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecol_sep() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f19(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f20(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOL() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    peg$silentFails++;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    peg$silentFails--;\n    if (s1 === peg$FAILED) {\n      s0 = undefined;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n\n    function processRow(leadCell, otherCells) {\n        const cells = [leadCell || []];\n        const seps = [];\n        for (const x of otherCells) {\n            cells.push(x.cell || []);\n            seps.push(x.colSep);\n        }\n        return { cells, colSeps: seps };\n    }\n\n    //\n    // These are compatability functions used when running in the browser\n    //\n    // Check if the `options` object has the functions that we need.\n    // If not, try to add them\n    if (!options.isWhitespace) {\n        try {\n            Object.assign(\n                options,\n                createMatchers([\"\\\\\", \"hline\", \"cr\"], [\"&\"])\n            );\n        } catch (e) {\n            console.warn(\"Error when initializing parser\", e);\n        }\n    }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n})()\n", "export default // Generated by Peggy 2.0.1.\n//\n// https://peggyjs.org/\n(function() {\n  \"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { args_spec_list: peg$parseargs_spec_list };\n  var peg$startRuleFunction = peg$parseargs_spec_list;\n\n  var peg$c0 = \"+\";\n  var peg$c1 = \"v\";\n  var peg$c2 = \"b\";\n  var peg$c3 = \"!\";\n  var peg$c4 = \"D\";\n  var peg$c5 = \"d\";\n  var peg$c6 = \"s\";\n  var peg$c7 = \"O\";\n  var peg$c8 = \"o\";\n  var peg$c9 = \"e\";\n  var peg$c10 = \"E\";\n  var peg$c11 = \"t\";\n  var peg$c12 = \"R\";\n  var peg$c13 = \"r\";\n  var peg$c14 = \"u\";\n  var peg$c15 = \"m\";\n  var peg$c16 = \"{\";\n  var peg$c17 = \"}\";\n  var peg$c18 = \" \";\n  var peg$c19 = \"\\n\";\n  var peg$c20 = \"\\r\";\n\n  var peg$r0 = /^[{ ]/;\n\n  var peg$e0 = peg$literalExpectation(\"+\", false);\n  var peg$e1 = peg$literalExpectation(\"v\", false);\n  var peg$e2 = peg$anyExpectation();\n  var peg$e3 = peg$literalExpectation(\"b\", false);\n  var peg$e4 = peg$literalExpectation(\"!\", false);\n  var peg$e5 = peg$literalExpectation(\"D\", false);\n  var peg$e6 = peg$literalExpectation(\"d\", false);\n  var peg$e7 = peg$literalExpectation(\"s\", false);\n  var peg$e8 = peg$literalExpectation(\"O\", false);\n  var peg$e9 = peg$literalExpectation(\"o\", false);\n  var peg$e10 = peg$literalExpectation(\"e\", false);\n  var peg$e11 = peg$literalExpectation(\"E\", false);\n  var peg$e12 = peg$literalExpectation(\"t\", false);\n  var peg$e13 = peg$literalExpectation(\"R\", false);\n  var peg$e14 = peg$literalExpectation(\"r\", false);\n  var peg$e15 = peg$literalExpectation(\"u\", false);\n  var peg$e16 = peg$classExpectation([\"{\", \" \"], false, false);\n  var peg$e17 = peg$literalExpectation(\"m\", false);\n  var peg$e18 = peg$literalExpectation(\"{\", false);\n  var peg$e19 = peg$literalExpectation(\"}\", false);\n  var peg$e20 = peg$literalExpectation(\" \", false);\n  var peg$e21 = peg$literalExpectation(\"\\n\", false);\n  var peg$e22 = peg$literalExpectation(\"\\r\", false);\n\n  var peg$f0 = function(x) { return x; };\n  var peg$f1 = function(spec) { return spec; };\n  var peg$f2 = function(spec) {\n            return spec;\n        };\n  var peg$f3 = function(openBrace) {\n            return createNode(\"verbatim\", { openBrace, closeBrace: openBrace });\n        };\n  var peg$f4 = function() { return createNode(\"body\"); };\n  var peg$f5 = function(leading_bang, spec) {\n            return leading_bang ? { ...spec, noLeadingWhitespace: true } : spec;\n        };\n  var peg$f6 = function(braceSpec, defaultArg) {\n            return createNode(\"optional\", { ...braceSpec, defaultArg });\n        };\n  var peg$f7 = function(braceSpec) { return createNode(\"optional\", braceSpec); };\n  var peg$f8 = function() { return createNode(\"optionalStar\"); };\n  var peg$f9 = function(g) { return createNode(\"optional\", { defaultArg: g }); };\n  var peg$f10 = function() { return createNode(\"optional\"); };\n  var peg$f11 = function(args) {\n            return createNode(\"embellishment\", {\n                embellishmentTokens: args.content,\n            });\n        };\n  var peg$f12 = function(args, g) {\n            return createNode(\"embellishment\", {\n                embellishmentTokens: args.content,\n                defaultArg: g,\n            });\n        };\n  var peg$f13 = function(tok) { return createNode(\"optionalToken\", { token: tok }); };\n  var peg$f14 = function(braceSpec, defaultArg) {\n            return createNode(\"mandatory\", { ...braceSpec, defaultArg });\n        };\n  var peg$f15 = function(braceSpec) { return createNode(\"mandatory\", braceSpec); };\n  var peg$f16 = function(stopTokens) {\n            return createNode(\"until\", { stopTokens });\n        };\n  var peg$f17 = function(x) { return [x]; };\n  var peg$f18 = function(g) { return g.content; };\n  var peg$f19 = function() { return createNode(\"mandatory\"); };\n  var peg$f20 = function(openBrace, closeBrace) {\n            return { openBrace, closeBrace };\n        };\n  var peg$f21 = function(content) {\n            return { type: \"group\", content: content };\n        };\n  var peg$f22 = function() { return \"\"; };\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = 0;\n  var peg$maxFailExpected = [];\n  var peg$silentFails = 0;\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parseargs_spec_list() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$currPos;\n    s3 = peg$parsewhitespace();\n    s4 = peg$parsearg_spec();\n    if (s4 !== peg$FAILED) {\n      peg$savedPos = s2;\n      s2 = peg$f0(s4);\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$currPos;\n      s3 = peg$parsewhitespace();\n      s4 = peg$parsearg_spec();\n      if (s4 !== peg$FAILED) {\n        peg$savedPos = s2;\n        s2 = peg$f0(s4);\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n    }\n    s2 = peg$parsewhitespace();\n    peg$savedPos = s0;\n    s0 = peg$f1(s1);\n\n    return s0;\n  }\n\n  function peg$parsearg_spec() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 43) {\n      s1 = peg$c0;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    s2 = peg$parseoptional();\n    if (s2 === peg$FAILED) {\n      s2 = peg$parsemandatory();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseverbatim();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parserequired();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsebody();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parseuntil();\n            }\n          }\n        }\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f2(s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseverbatim() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 118) {\n      s1 = peg$c1;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e1); }\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.length > peg$currPos) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e2); }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f3(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsebody() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 98) {\n      s1 = peg$c2;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f4();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseoptional() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 33) {\n      s1 = peg$c3;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e4); }\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    s2 = peg$parseoptional_star();\n    if (s2 === peg$FAILED) {\n      s2 = peg$parseoptional_standard();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseoptional_delimited();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseoptional_embellishment();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseoptional_token();\n          }\n        }\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f5(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseoptional_delimited() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 68) {\n      s1 = peg$c4;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e5); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsebrace_spec();\n      s3 = peg$parsebraced_group();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f6(s2, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 100) {\n        s1 = peg$c5;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e6); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsebrace_spec();\n        peg$savedPos = s0;\n        s0 = peg$f7(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseoptional_star() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 115) {\n      s1 = peg$c6;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e7); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f8();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseoptional_standard() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 79) {\n      s1 = peg$c7;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e8); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsebraced_group();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f9(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 111) {\n        s1 = peg$c8;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e9); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f10();\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseoptional_embellishment() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 101) {\n      s1 = peg$c9;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e10); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsebraced_group();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f11(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 69) {\n        s1 = peg$c10;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e11); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsebraced_group();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsebraced_group();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f12(s2, s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseoptional_token() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 116) {\n      s1 = peg$c11;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e12); }\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.length > peg$currPos) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e2); }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f13(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parserequired() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 82) {\n      s1 = peg$c12;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e13); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsebrace_spec();\n      s3 = peg$parsebraced_group();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f14(s2, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 114) {\n        s1 = peg$c13;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e14); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsebrace_spec();\n        peg$savedPos = s0;\n        s0 = peg$f15(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseuntil() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 117) {\n      s1 = peg$c14;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e15); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseuntil_stop_token();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f16(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseuntil_stop_token() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    if (peg$r0.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e16); }\n    }\n    peg$silentFails--;\n    if (s2 === peg$FAILED) {\n      s1 = undefined;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.length > peg$currPos) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e2); }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f17(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsebraced_group();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f18(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemandatory() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 109) {\n      s1 = peg$c15;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e17); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f19();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsebrace_spec() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    s3 = peg$currPos;\n    peg$silentFails++;\n    s4 = peg$parsewhitespace_token();\n    peg$silentFails--;\n    if (s4 === peg$FAILED) {\n      s3 = undefined;\n    } else {\n      peg$currPos = s3;\n      s3 = peg$FAILED;\n    }\n    if (s3 !== peg$FAILED) {\n      if (input.length > peg$currPos) {\n        s4 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e2); }\n      }\n      if (s4 !== peg$FAILED) {\n        s3 = [s3, s4];\n        s2 = s3;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    s1 = input.substring(s1, peg$currPos);\n    s2 = peg$currPos;\n    s3 = peg$currPos;\n    s4 = peg$currPos;\n    peg$silentFails++;\n    s5 = peg$parsewhitespace_token();\n    peg$silentFails--;\n    if (s5 === peg$FAILED) {\n      s4 = undefined;\n    } else {\n      peg$currPos = s4;\n      s4 = peg$FAILED;\n    }\n    if (s4 !== peg$FAILED) {\n      if (input.length > peg$currPos) {\n        s5 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e2); }\n      }\n      if (s5 !== peg$FAILED) {\n        s4 = [s4, s5];\n        s3 = s4;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s3;\n      s3 = peg$FAILED;\n    }\n    if (s3 === peg$FAILED) {\n      s3 = null;\n    }\n    s2 = input.substring(s2, peg$currPos);\n    peg$savedPos = s0;\n    s0 = peg$f20(s1, s2);\n\n    return s0;\n  }\n\n  function peg$parsebraced_group() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s1 = peg$c16;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e18); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      s5 = peg$currPos;\n      peg$silentFails++;\n      if (input.charCodeAt(peg$currPos) === 125) {\n        s6 = peg$c17;\n        peg$currPos++;\n      } else {\n        s6 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e19); }\n      }\n      peg$silentFails--;\n      if (s6 === peg$FAILED) {\n        s5 = undefined;\n      } else {\n        peg$currPos = s5;\n        s5 = peg$FAILED;\n      }\n      if (s5 !== peg$FAILED) {\n        s6 = peg$currPos;\n        peg$silentFails++;\n        s7 = peg$parsebraced_group();\n        peg$silentFails--;\n        if (s7 === peg$FAILED) {\n          s6 = undefined;\n        } else {\n          peg$currPos = s6;\n          s6 = peg$FAILED;\n        }\n        if (s6 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s7 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e2); }\n          }\n          if (s7 !== peg$FAILED) {\n            s5 = [s5, s6, s7];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s3 = input.substring(s3, peg$currPos);\n      } else {\n        s3 = s4;\n      }\n      if (s3 === peg$FAILED) {\n        s3 = peg$parsebraced_group();\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        s5 = peg$currPos;\n        peg$silentFails++;\n        if (input.charCodeAt(peg$currPos) === 125) {\n          s6 = peg$c17;\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e19); }\n        }\n        peg$silentFails--;\n        if (s6 === peg$FAILED) {\n          s5 = undefined;\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsebraced_group();\n          peg$silentFails--;\n          if (s7 === peg$FAILED) {\n            s6 = undefined;\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s7 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s7 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e2); }\n            }\n            if (s7 !== peg$FAILED) {\n              s5 = [s5, s6, s7];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = input.substring(s3, peg$currPos);\n        } else {\n          s3 = s4;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsebraced_group();\n        }\n      }\n      if (input.charCodeAt(peg$currPos) === 125) {\n        s3 = peg$c17;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e19); }\n      }\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f21(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsewhitespace() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewhitespace_token();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsewhitespace_token();\n    }\n    peg$savedPos = s0;\n    s1 = peg$f22();\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsewhitespace_token() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 32) {\n      s0 = peg$c18;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e20); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 10) {\n        s0 = peg$c19;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e21); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 13) {\n          s0 = peg$c20;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e22); }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n\n    const DEFAULT_OPTIONS = {\n        optional: { openBrace: \"[\", closeBrace: \"]\" },\n        mandatory: { openBrace: \"{\", closeBrace: \"}\" },\n    };\n    function createNode(type, options) {\n        const computedOptions = DEFAULT_OPTIONS[type] || {};\n        return { type, ...computedOptions, ...options };\n    }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n})()\n", "export default // Generated by Peggy 2.0.1.\n//\n// https://peggyjs.org/\n(function() {\n  \"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { body: peg$parsebody };\n  var peg$startRuleFunction = peg$parsebody;\n\n\n\n  var peg$e0 = peg$anyExpectation();\n\n  var peg$f0 = function() { return []; };\n  var peg$f1 = function(rowItems, trailingComment) {\n            return {\n                itemParts: [],\n                ...rowItems,\n                trailingComment,\n                trailingComma: true,\n            };\n        };\n  var peg$f2 = function(rowItems, trailingComment) {\n            return { ...rowItems, trailingComment };\n        };\n  var peg$f3 = function(a, b) { return processItem(a, b); };\n  var peg$f4 = function(b) { return processItem(null, b); };\n  var peg$f5 = function(cell) { return { cell }; };\n  var peg$f6 = function() { return {}; };\n  var peg$f7 = function(part) { return part; };\n  var peg$f8 = function(x) { return x; };\n  var peg$f9 = function(space, x) {\n            return {\n                trailingComment: x,\n                leadingParbreak: space.parbreak > 0,\n            };\n        };\n  var peg$f10 = function(list) {\n            return {\n                whitespace: list.filter((x) => options.isWhitespace(x)).length,\n                parbreak: list.filter((x) => options.isParbreak(x)).length,\n            };\n        };\n  var peg$f11 = function() { return !options.allowParenGroups; };\n  var peg$f12 = function(tok) { return options.isSameLineComment(tok); };\n  var peg$f13 = function(tok) { return tok; };\n  var peg$f14 = function(tok) { return options.isOwnLineComment(tok); };\n  var peg$f15 = function(tok) { return tok; };\n  var peg$f16 = function(tok) { return options.isWhitespace(tok); };\n  var peg$f17 = function(tok) { return tok; };\n  var peg$f18 = function(tok) { return options.isParbreak(tok); };\n  var peg$f19 = function(tok) { return tok; };\n  var peg$f20 = function(tok) { return options.isComma(tok); };\n  var peg$f21 = function(tok) { return tok; };\n  var peg$f22 = function(tok) { return options.isEquals(tok); };\n  var peg$f23 = function(tok) { return tok; };\n  var peg$f24 = function(tok) { return options.isChar(tok, \"(\"); };\n  var peg$f25 = function(tok) { return tok; };\n  var peg$f26 = function(tok) { return options.isChar(tok, \")\"); };\n  var peg$f27 = function(tok) { return tok; };\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = 0;\n  var peg$maxFailExpected = [];\n  var peg$silentFails = 0;\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsebody() {\n    var s0, s1, s2;\n\n    s0 = [];\n    s1 = peg$parsecomment_only_line();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseitem_with_end();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseitem_without_end();\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        s1 = peg$parsecomment_only_line();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseitem_with_end();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parseitem_without_end();\n          }\n        }\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsewhitespace();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsewhitespace();\n      }\n      s2 = peg$parseEOL();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f0();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseitem_with_end() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    s0 = peg$currPos;\n    s1 = peg$parsewhitespace_or_parbreaks();\n    s2 = peg$parserow_items();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    s3 = peg$parsewhitespace_or_parbreaks();\n    s4 = peg$parseitem_sep();\n    if (s4 !== peg$FAILED) {\n      s5 = [];\n      s6 = peg$parsewhitespace();\n      while (s6 !== peg$FAILED) {\n        s5.push(s6);\n        s6 = peg$parsewhitespace();\n      }\n      s6 = peg$parsetrailing_comment();\n      if (s6 === peg$FAILED) {\n        s6 = null;\n      }\n      s7 = [];\n      s8 = peg$parsewhitespace();\n      while (s8 !== peg$FAILED) {\n        s7.push(s8);\n        s8 = peg$parsewhitespace();\n      }\n      peg$savedPos = s0;\n      s0 = peg$f1(s2, s6);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseitem_without_end() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsewhitespace_or_parbreaks();\n    s2 = peg$parserow_items();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsetrailing_comment();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f2(s2, s3);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parserow_items() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseitem_part();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseseparated_part();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseseparated_part();\n      }\n      peg$savedPos = s0;\n      s0 = peg$f3(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseseparated_part();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseseparated_part();\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseseparated_part() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseparbreak();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parseparbreak();\n    }\n    s2 = peg$parseequals();\n    if (s2 !== peg$FAILED) {\n      s3 = [];\n      s4 = peg$parseparbreak();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parseparbreak();\n      }\n      s4 = peg$parseitem_part();\n      if (s4 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f5(s4);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseparbreak();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseparbreak();\n      }\n      s2 = peg$parseequals();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f6();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseitem_part() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewhitespace();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsewhitespace();\n    }\n    s2 = peg$currPos;\n    s3 = [];\n    s4 = peg$parsenon_whitespace_non_parbreak_token();\n    if (s4 === peg$FAILED) {\n      s4 = peg$currPos;\n      s5 = peg$parsewhitespace();\n      if (s5 === peg$FAILED) {\n        s5 = peg$parseparbreak();\n      }\n      if (s5 !== peg$FAILED) {\n        s6 = peg$currPos;\n        peg$silentFails++;\n        s7 = peg$currPos;\n        s8 = [];\n        s9 = peg$parsewhitespace();\n        if (s9 === peg$FAILED) {\n          s9 = peg$parseparbreak();\n        }\n        while (s9 !== peg$FAILED) {\n          s8.push(s9);\n          s9 = peg$parsewhitespace();\n          if (s9 === peg$FAILED) {\n            s9 = peg$parseparbreak();\n          }\n        }\n        s9 = peg$parsenon_whitespace_non_parbreak_token();\n        if (s9 !== peg$FAILED) {\n          s8 = [s8, s9];\n          s7 = s8;\n        } else {\n          peg$currPos = s7;\n          s7 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s7 !== peg$FAILED) {\n          peg$currPos = s6;\n          s6 = undefined;\n        } else {\n          s6 = peg$FAILED;\n        }\n        if (s6 !== peg$FAILED) {\n          s5 = [s5, s6];\n          s4 = s5;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n    }\n    if (s4 !== peg$FAILED) {\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parsenon_whitespace_non_parbreak_token();\n        if (s4 === peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsewhitespace();\n          if (s5 === peg$FAILED) {\n            s5 = peg$parseparbreak();\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$currPos;\n            s8 = [];\n            s9 = peg$parsewhitespace();\n            if (s9 === peg$FAILED) {\n              s9 = peg$parseparbreak();\n            }\n            while (s9 !== peg$FAILED) {\n              s8.push(s9);\n              s9 = peg$parsewhitespace();\n              if (s9 === peg$FAILED) {\n                s9 = peg$parseparbreak();\n              }\n            }\n            s9 = peg$parsenon_whitespace_non_parbreak_token();\n            if (s9 !== peg$FAILED) {\n              s8 = [s8, s9];\n              s7 = s8;\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = undefined;\n            } else {\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        }\n      }\n    } else {\n      s3 = peg$FAILED;\n    }\n    if (s3 !== peg$FAILED) {\n      s2 = input.substring(s2, peg$currPos);\n    } else {\n      s2 = s3;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = [];\n      s4 = peg$parsewhitespace();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parsewhitespace();\n      }\n      peg$savedPos = s0;\n      s0 = peg$f7(s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsetrailing_comment() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewhitespace();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsewhitespace();\n    }\n    s2 = peg$parsesame_line_comment();\n    if (s2 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f8(s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomment_only_line() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsewhitespace_or_parbreaks();\n    s2 = peg$parseown_line_comment();\n    if (s2 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f9(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsetoken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    peg$silentFails++;\n    s3 = peg$parsenon_token();\n    peg$silentFails--;\n    if (s3 === peg$FAILED) {\n      s2 = undefined;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      if (input.length > peg$currPos) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e0); }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenon_whitespace_non_parbreak_token() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    peg$silentFails++;\n    s3 = peg$parsewhitespace();\n    if (s3 === peg$FAILED) {\n      s3 = peg$parseparbreak();\n    }\n    peg$silentFails--;\n    if (s3 === peg$FAILED) {\n      s2 = undefined;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseparen_block();\n      if (s3 === peg$FAILED) {\n        s3 = peg$parsetoken();\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenon_token() {\n    var s0;\n\n    s0 = peg$parseitem_sep();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseequals();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsetrailing_comment();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseown_line_comment();\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsewhitespace_or_parbreaks() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewhitespace();\n    if (s2 === peg$FAILED) {\n      s2 = peg$parseparbreak();\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsewhitespace();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseparbreak();\n      }\n    }\n    peg$savedPos = s0;\n    s1 = peg$f10(s1);\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseparen_block() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    s0 = peg$currPos;\n    peg$savedPos = peg$currPos;\n    s1 = peg$f11();\n    if (s1) {\n      s1 = peg$FAILED;\n    } else {\n      s1 = undefined;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      s4 = peg$parseopen_paren();\n      if (s4 !== peg$FAILED) {\n        s5 = [];\n        s6 = peg$currPos;\n        s7 = peg$currPos;\n        peg$silentFails++;\n        s8 = peg$parseclose_paren();\n        peg$silentFails--;\n        if (s8 === peg$FAILED) {\n          s7 = undefined;\n        } else {\n          peg$currPos = s7;\n          s7 = peg$FAILED;\n        }\n        if (s7 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s8 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e0); }\n          }\n          if (s8 !== peg$FAILED) {\n            s7 = [s7, s8];\n            s6 = s7;\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s6;\n          s6 = peg$FAILED;\n        }\n        while (s6 !== peg$FAILED) {\n          s5.push(s6);\n          s6 = peg$currPos;\n          s7 = peg$currPos;\n          peg$silentFails++;\n          s8 = peg$parseclose_paren();\n          peg$silentFails--;\n          if (s8 === peg$FAILED) {\n            s7 = undefined;\n          } else {\n            peg$currPos = s7;\n            s7 = peg$FAILED;\n          }\n          if (s7 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s8 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s8 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e0); }\n            }\n            if (s8 !== peg$FAILED) {\n              s7 = [s7, s8];\n              s6 = s7;\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n        }\n        s6 = peg$parseclose_paren();\n        if (s6 !== peg$FAILED) {\n          s4 = [s4, s5, s6];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesame_line_comment() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f12(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f13(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseown_line_comment() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f14(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f15(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsewhitespace() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f16(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f17(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseparbreak() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f18(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f19(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseitem_sep() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f20(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f21(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseequals() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f22(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f23(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseopen_paren() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f24(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f25(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseclose_paren() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f26(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f27(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOL() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    peg$silentFails++;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    peg$silentFails--;\n    if (s1 === peg$FAILED) {\n      s0 = undefined;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n\n    function processItem(leadCell, otherCells) {\n        const cells = [leadCell || []];\n        for (const x of otherCells) {\n            cells.push(x.cell || []);\n        }\n        return { itemParts: cells };\n    }\n\n    //\n    // These are compatability functions used when running in the browser\n    //\n    // Check if the `options` object has the functions that we need.\n    // If not, try to add them\n    if (!options.isWhitespace) {\n        try {\n            Object.assign(options, {\n                isChar: (node, char) =>\n                    node.type === \"string\" && node.content === char,\n                isComma(node) {\n                    return node.type === \"string\" && node.content === \",\";\n                },\n                isEquals(node) {\n                    return node.type === \"string\" && node.content === \"=\";\n                },\n                isParbreak(node) {\n                    return node.type === \"parbreak\";\n                },\n                isWhitespace(node) {\n                    return node.type === \"whitespace\";\n                },\n                isSameLineComment: (node) =>\n                    node.type === \"comment\" && node.sameline,\n                isOwnLineComment: (node) =>\n                    node.type === \"comment\" && !node.sameline,\n                isComment: (node) => node.type === \"comment\",\n                allowParenGroups: true,\n            });\n        } catch (e) {\n            console.warn(\"Error when initializing parser\", e);\n        }\n    }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n})()\n", "export default // Generated by Peggy 2.0.1.\n//\n// https://peggyjs.org/\n(function() {\n  \"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { body: peg$parsebody };\n  var peg$startRuleFunction = peg$parsebody;\n\n\n\n  var peg$e0 = peg$anyExpectation();\n\n  var peg$f0 = function(e) {\n            // We may have inserted nested arrays.\n            // Flatten everything before we're done and remove any\n            // resitual `null`s\n            return [].concat(...e).filter((n) => !!n);\n        };\n  var peg$f1 = function() { return []; };\n  var peg$f2 = function(tok) { return options.isHash(tok); };\n  var peg$f3 = function(tok) { return tok; };\n  var peg$f4 = function(tok) { return options.isNumber(tok); };\n  var peg$f5 = function(tok) { return tok; };\n  var peg$f6 = function() { return { type: \"string\", content: \"#\" }; };\n  var peg$f7 = function(num) {\n            const split = options.splitNumber(num);\n            return [{ type: \"hash_number\", number: split.number }, split.rest];\n        };\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = 0;\n  var peg$maxFailExpected = [];\n  var peg$silentFails = 0;\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsebody() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsedouble_hash();\n    if (s2 === peg$FAILED) {\n      s2 = peg$parsehash_number();\n      if (s2 === peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e0); }\n        }\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsedouble_hash();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsehash_number();\n          if (s2 === peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s2 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e0); }\n            }\n          }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f0(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseEOL();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f1();\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsehash() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f2(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f3(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f4(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f5(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedouble_hash() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsehash();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsehash();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f6();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsehash_number() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsehash();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsenumber();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f7(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOL() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    peg$silentFails++;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    peg$silentFails--;\n    if (s1 === peg$FAILED) {\n      s0 = undefined;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n\n    //\n    // These are compatability functions used when running in the browser\n    //\n    // Check if the `options` object has the functions that we need.\n    // If not, try to add them\n    if (!options.isHash) {\n        try {\n            Object.assign(options, {\n                isHash: (node) =>\n                    node.type === \"string\" && node.content === \"#\",\n                isNumber: (node) =>\n                    node.type === \"string\" && 0 < +node.content.charAt(0),\n                splitNumber: (node) => {\n                    const number = +node.content.charAt(0);\n                    if (node.content.length > 1) {\n                        return {\n                            number,\n                            rest: {\n                                type: \"string\",\n                                content: node.content.slice(1),\n                            },\n                        };\n                    }\n                    return { number };\n                },\n            });\n        } catch (e) {\n            console.warn(\"Error when initializing parser\", e);\n        }\n    }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n})()\n", "export default // Generated by Peggy 2.0.1.\n//\n// https://peggyjs.org/\n(function() {\n  \"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { body: peg$parsebody };\n  var peg$startRuleFunction = peg$parsebody;\n\n\n\n  var peg$e0 = peg$anyExpectation();\n\n  var peg$f0 = function(e) {\n            // We may have inserted nested arrays.\n            // Flatten everything before we're done and remove any\n            // resitual `null`s\n            return [].concat(...e).filter((n) => !!n);\n        };\n  var peg$f1 = function() { return []; };\n  var peg$f2 = function(toks) { return options.isRecognized(toks); };\n  var peg$f3 = function(toks) {\n            return options.isRecognized(toks);\n        };\n  var peg$f4 = function(tok1, tok2) {\n                const split = options.split(tok2);\n                return options.isRecognized([tok1, split[0]]);\n            };\n  var peg$f5 = function(tok1, tok2) {\n            const split = options.split(tok2);\n            return [options.isRecognized([tok1, split[0]]), split[1]];\n        };\n  var peg$f6 = function(tok1, tok2) { return options.isRecognized([tok1, tok2]); };\n  var peg$f7 = function(tok1, tok2) {\n            return options.isRecognized([tok1, tok2]);\n        };\n  var peg$f8 = function(toks) { return options.isRecognized(toks); };\n  var peg$f9 = function(toks) {\n            return options.isRecognized(toks);\n        };\n  var peg$f10 = function(tok) { return options.isRecognized([tok]); };\n  var peg$f11 = function(tok) {\n            return options.isRecognized([tok]);\n        };\n  var peg$f12 = function(tok) { return options.isMacro(tok); };\n  var peg$f13 = function(tok) { return tok; };\n  var peg$f14 = function(tok) { return options.isWhitespace(tok); };\n  var peg$f15 = function(tok) { return tok; };\n  var peg$f16 = function(tok) { return options.isSplitable(tok); };\n  var peg$f17 = function(tok) { return tok; };\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = 0;\n  var peg$maxFailExpected = [];\n  var peg$silentFails = 0;\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsebody() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsetriple_ligature();\n    if (s2 === peg$FAILED) {\n      s2 = peg$parsedouble_ligature();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsemono_ligature();\n        if (s2 === peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e0); }\n          }\n        }\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsetriple_ligature();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsedouble_ligature();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsemono_ligature();\n            if (s2 === peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s2 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e0); }\n              }\n            }\n          }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f0(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseEOL();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f1();\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsetriple_ligature() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s2 !== peg$FAILED) {\n      if (input.length > peg$currPos) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e0); }\n      }\n      if (s3 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e0); }\n        }\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f2(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f3(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedouble_ligature() {\n    var s0;\n\n    s0 = peg$parsedouble_macro_ligature();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsedouble_macro_ligature_extracted();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsedouble_char_ligature();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsedouble_macro_ligature_extracted() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parsemacro();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewhitespace();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewhitespace();\n      }\n      s3 = peg$parsesplitable();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s4 = peg$f4(s1, s3);\n        if (s4) {\n          s4 = undefined;\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f5(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedouble_macro_ligature() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parsemacro();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewhitespace();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewhitespace();\n      }\n      if (input.length > peg$currPos) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e0); }\n      }\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s4 = peg$f6(s1, s3);\n        if (s4) {\n          s4 = undefined;\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f7(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedouble_char_ligature() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s2 !== peg$FAILED) {\n      if (input.length > peg$currPos) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e0); }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f8(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f9(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemono_ligature() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f10(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f11(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemacro() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f12(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f13(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsewhitespace() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f14(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f15(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesplitable() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f16(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f17(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOL() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    peg$silentFails++;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    peg$silentFails--;\n    if (s1 === peg$FAILED) {\n      s0 = undefined;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n\n    //\n    // These are compatability functions used when running in the browser\n    //\n    // Check if the `options` object has the functions that we need.\n    // If not, try to add them\n    if (!options.isWhitespace) {\n        try {\n            Object.assign(options, {\n                isMacro: (node) => node.type === \"macro\",\n                isWhitespace: (node) => node.type === \"whitespace\",\n                isRecognized: (nodes) => {\n                    if (\n                        nodes.length == 2 &&\n                        nodes[0].content === \"^\" &&\n                        nodes[1].content === \"o\"\n                    ) {\n                        return { type: \"string\", content: \"\u00F4\" };\n                    }\n\n                    return null;\n                },\n                isSplitable: (node) =>\n                    node.type === \"string\" && node.content.length > 1,\n                split: (node) => [\n                    { type: \"string\", content: node.content.charAt(0) },\n                    { type: \"string\", content: node.content.slice(1) },\n                ],\n            });\n        } catch (e) {\n            console.warn(\"Error when initializing parser\", e);\n        }\n    }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n})()\n", "export default // Generated by Peggy 2.0.1.\n//\n// https://peggyjs.org/\n(function() {\n  \"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { start: peg$parsestart };\n  var peg$startRuleFunction = peg$parsestart;\n\n  var peg$c0 = \";\";\n  var peg$c1 = \",\";\n  var peg$c2 = \":\";\n  var peg$c3 = \"/\";\n  var peg$c4 = \">\";\n  var peg$c5 = \"!\";\n  var peg$c6 = \".\";\n  var peg$c7 = \"!![\";\n  var peg$c8 = \"]\";\n  var peg$c9 = \"!!\";\n  var peg$c10 = \"+\";\n  var peg$c11 = \"-\";\n\n  var peg$r0 = /^[a-zA-Z0-9]/;\n  var peg$r1 = /^[0-9]/;\n  var peg$r2 = /^[ \\t\\n\\r]/;\n  var peg$r3 = /^[0-9a-fA-F]/;\n\n  var peg$e0 = peg$anyExpectation();\n  var peg$e1 = peg$literalExpectation(\";\", false);\n  var peg$e2 = peg$literalExpectation(\",\", false);\n  var peg$e3 = peg$otherExpectation(\"model list\");\n  var peg$e4 = peg$literalExpectation(\":\", false);\n  var peg$e5 = peg$literalExpectation(\"/\", false);\n  var peg$e6 = peg$otherExpectation(\"model\");\n  var peg$e7 = peg$otherExpectation(\"color spec list\");\n  var peg$e8 = peg$otherExpectation(\"color spec\");\n  var peg$e9 = peg$otherExpectation(\"color\");\n  var peg$e10 = peg$otherExpectation(\"function expression\");\n  var peg$e11 = peg$literalExpectation(\">\", false);\n  var peg$e12 = peg$otherExpectation(\"function\");\n  var peg$e13 = peg$otherExpectation(\"extended expression\");\n  var peg$e14 = peg$otherExpectation(\"core model\");\n  var peg$e15 = peg$otherExpectation(\"expr\");\n  var peg$e16 = peg$literalExpectation(\"!\", false);\n  var peg$e17 = peg$otherExpectation(\"mix expr\");\n  var peg$e18 = peg$otherExpectation(\"name\");\n  var peg$e19 = peg$literalExpectation(\".\", false);\n  var peg$e20 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"]], false, false);\n  var peg$e21 = peg$otherExpectation(\"postfix\");\n  var peg$e22 = peg$literalExpectation(\"!![\", false);\n  var peg$e23 = peg$literalExpectation(\"]\", false);\n  var peg$e24 = peg$literalExpectation(\"!!\", false);\n  var peg$e25 = peg$otherExpectation(\"prefix\");\n  var peg$e26 = peg$otherExpectation(\"plus\");\n  var peg$e27 = peg$literalExpectation(\"+\", false);\n  var peg$e28 = peg$otherExpectation(\"minus\");\n  var peg$e29 = peg$literalExpectation(\"-\", false);\n  var peg$e30 = peg$otherExpectation(\"num\");\n  var peg$e31 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n  var peg$e32 = peg$otherExpectation(\"positive float\");\n  var peg$e33 = peg$otherExpectation(\"divisor\");\n  var peg$e34 = peg$otherExpectation(\"int\");\n  var peg$e35 = peg$otherExpectation(\"whitespace\");\n  var peg$e36 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false);\n  var peg$e37 = peg$classExpectation([[\"0\", \"9\"], [\"a\", \"f\"], [\"A\", \"F\"]], false, false);\n\n  var peg$f0 = function(m) { return m; };\n  var peg$f1 = function(m) { return m; };\n  var peg$f2 = function(m) { return m; };\n  var peg$f3 = function(m) { return m; };\n  var peg$f4 = function(m) { return m; };\n  var peg$f5 = function(a) { return { type: \"invalid_spec\", content: a }; };\n  var peg$f6 = function(f, c) { return c; };\n  var peg$f7 = function(f, r) {\n            return { type: \"color_set\", content: [f].concat(r) };\n        };\n  var peg$f8 = function(n, s) {\n            return { type: \"color_set_item\", name: n, spec_list: s };\n        };\n  var peg$f9 = function(c, m) {\n            return { type: \"model_list\", contents: m, core_model: c };\n        };\n  var peg$f10 = function(m) {\n            return { type: \"model_list\", contents: m, core_model: null };\n        };\n  var peg$f11 = function(m, a) { return a; };\n  var peg$f12 = function(m, r) { return [m].concat(r); };\n  var peg$f13 = function(s, a) { return a; };\n  var peg$f14 = function(s, r) {\n            return { type: \"spec_list\", content: [s].concat(r) };\n        };\n  var peg$f15 = function(c) {\n            return { type: \"hex_spec\", content: [c] };\n        };\n  var peg$f16 = function(c, d) { return d; };\n  var peg$f17 = function(c, d) { return d; };\n  var peg$f18 = function(c, r) {\n            return { type: \"num_spec\", content: r ? [c].concat(r) : [c] };\n        };\n  var peg$f19 = function(c, fs) {\n            return { type: \"color\", color: c, functions: fs };\n        };\n  var peg$f20 = function(f, n) { return n; };\n  var peg$f21 = function(f, args) {\n            return { type: \"function\", name: f, args };\n        };\n  var peg$f22 = function(core, d, e, es) {\n            return {\n                type: \"extended_expr\",\n                core_model: core,\n                div: d,\n                expressions: [e].concat(es),\n            };\n        };\n  var peg$f23 = function(core, e, es) {\n            return {\n                type: \"extended_expr\",\n                core_model: core,\n                div: null,\n                expressions: [e].concat(es),\n            };\n        };\n  var peg$f24 = function(e, d) {\n            return { type: \"weighted_expr\", color: e, weight: d };\n        };\n  var peg$f25 = function(e) { return e; };\n  var peg$f26 = function(p, n, e, po) {\n            return {\n                type: \"expr\",\n                prefix: p,\n                name: n,\n                mix_expr: e,\n                postfix: po,\n            };\n        };\n  var peg$f27 = function(p, n) {\n            return { type: \"complete_mix\", mix_percent: p, name: n };\n        };\n  var peg$f28 = function(p) { return { type: \"partial_mix\", mix_percent: p }; };\n  var peg$f29 = function(c, p) { return c.concat(p || []); };\n  var peg$f30 = function(n) { return { type: \"postfix\", num: n }; };\n  var peg$f31 = function(p) { return { type: \"postfix\", plusses: p }; };\n  var peg$f32 = function(n) { return parseInt(n, 10); };\n  var peg$f33 = function(n) { return parseFloat(n); };\n  var peg$f34 = function(n) { return n; };\n  var peg$f35 = function(n) { return -n; };\n  var peg$f36 = function(m, n) { return m ? -n : n; };\n  var peg$f37 = function(h) { return h.toUpperCase(); };\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = 0;\n  var peg$maxFailExpected = [];\n  var peg$silentFails = 0;\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsestart() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsespec();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseEOL();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f0(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsespec_list();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseEOL();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f1(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsecolor();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseEOL();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f2(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsemodel_list();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseEOL();\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f3(s1);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsecolor_set_spec();\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parseEOL();\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f4(s1);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$currPos;\n              s2 = [];\n              if (input.length > peg$currPos) {\n                s3 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e0); }\n              }\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                if (input.length > peg$currPos) {\n                  s3 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e0); }\n                }\n              }\n              s1 = input.substring(s1, peg$currPos);\n              peg$savedPos = s0;\n              s1 = peg$f5(s1);\n              s0 = s1;\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecolor_set_spec() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecolor_set_item();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 59) {\n        s4 = peg$c0;\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e1); }\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecolor_set_item();\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s3 = peg$f6(s1, s5);\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 59) {\n          s4 = peg$c0;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e1); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecolor_set_item();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s3 = peg$f6(s1, s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f7(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecolor_set_item() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsename();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 44) {\n        s2 = peg$c1;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e2); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespec_list();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f8(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemodel_list() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsecore_model();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s2 = peg$c2;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e4); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsemodel_list_tail();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f9(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsemodel_list_tail();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f10(s1);\n      }\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemodel_list_tail() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsemodel();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s4 = peg$c3;\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e5); }\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsemodel();\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s3 = peg$f11(s1, s5);\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s4 = peg$c3;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e5); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsemodel();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s3 = peg$f11(s1, s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f12(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemodel() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parsecore_model();\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e6); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsespec_list() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsespec();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s4 = peg$c3;\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e5); }\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsespec();\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s3 = peg$f13(s1, s5);\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s4 = peg$c3;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e5); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsespec();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s3 = peg$f13(s1, s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f14(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e7); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsespec() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    s3 = peg$parsehex();\n    if (s3 !== peg$FAILED) {\n      s4 = peg$parsehex();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsehex();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsehex();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsehex();\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parsehex();\n              if (s8 !== peg$FAILED) {\n                s3 = [s3, s4, s5, s6, s7, s8];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f15(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsedec();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s4 = peg$c1;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e2); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsedec();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s3 = peg$f16(s1, s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s4 = peg$c1;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e2); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsedec();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s3 = peg$f16(s1, s5);\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 === peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          s4 = peg$parsesp();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsedec();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s3 = peg$f17(s1, s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n              s4 = peg$parsesp();\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsedec();\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s3;\n                  s3 = peg$f17(s1, s5);\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n          } else {\n            s2 = peg$FAILED;\n          }\n        }\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        peg$savedPos = s0;\n        s0 = peg$f18(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e8); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecolor() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsecolor_expr();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsefunc_expr();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefunc_expr();\n      }\n      peg$savedPos = s0;\n      s0 = peg$f19(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e9); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecolor_expr() {\n    var s0;\n\n    s0 = peg$parseext_expr();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseexpr();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsename();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefunc_expr() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 62) {\n      s1 = peg$c4;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e11); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsefunction();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s5 = peg$c1;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e2); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parseint();\n          if (s6 !== peg$FAILED) {\n            peg$savedPos = s4;\n            s4 = peg$f20(s2, s6);\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c1;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e2); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseint();\n            if (s6 !== peg$FAILED) {\n              peg$savedPos = s4;\n              s4 = peg$f20(s2, s6);\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        }\n        peg$savedPos = s0;\n        s0 = peg$f21(s2, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e10); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefunction() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parsename();\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e12); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseext_expr() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsecore_model();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 44) {\n        s2 = peg$c1;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e2); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsediv();\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 58) {\n            s4 = peg$c2;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e4); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseweighted_expr();\n            if (s5 !== peg$FAILED) {\n              s6 = [];\n              s7 = peg$parseadditional_weighted_expr();\n              while (s7 !== peg$FAILED) {\n                s6.push(s7);\n                s7 = peg$parseadditional_weighted_expr();\n              }\n              peg$savedPos = s0;\n              s0 = peg$f22(s1, s3, s5, s6);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsecore_model();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s2 = peg$c2;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e4); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseweighted_expr();\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$parseadditional_weighted_expr();\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$parseadditional_weighted_expr();\n            }\n            peg$savedPos = s0;\n            s0 = peg$f23(s1, s3, s4);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e13); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseweighted_expr() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseexpr();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 44) {\n        s2 = peg$c1;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e2); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsedec();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f24(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseadditional_weighted_expr() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 59) {\n      s1 = peg$c0;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e1); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseweighted_expr();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f25(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecore_model() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parsename();\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e14); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseexpr() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseprefix();\n    s2 = peg$parsename();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsemix_expr();\n      s4 = peg$parsepostfix();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f26(s1, s2, s3, s4);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e15); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomplete_mix() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 33) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e16); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepct();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 33) {\n          s3 = peg$c5;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e16); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsename();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f27(s2, s4);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsepartial_mix() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 33) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e16); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepct();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f28(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemix_expr() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsecomplete_mix();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsecomplete_mix();\n    }\n    s2 = peg$parsepartial_mix();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    peg$savedPos = s0;\n    s0 = peg$f29(s1, s2);\n    peg$silentFails--;\n    s1 = peg$FAILED;\n    if (peg$silentFails === 0) { peg$fail(peg$e17); }\n\n    return s0;\n  }\n\n  function peg$parsename() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s0 = peg$c6;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e19); }\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$r0.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e20); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$r0.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e20); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e18); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsepostfix() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 3) === peg$c7) {\n      s1 = peg$c7;\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e22); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsenum();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s3 = peg$c8;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e23); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f30(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c9) {\n        s1 = peg$c9;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e24); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = [];\n        s4 = peg$parseplus();\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parseplus();\n          }\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = input.substring(s2, peg$currPos);\n        } else {\n          s2 = s3;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f31(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e21); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseprefix() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parseminus();\n    if (s0 === peg$FAILED) {\n      s0 = null;\n    }\n    peg$silentFails--;\n    s1 = peg$FAILED;\n    if (peg$silentFails === 0) { peg$fail(peg$e25); }\n\n    return s0;\n  }\n\n  function peg$parseplus() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    if (input.charCodeAt(peg$currPos) === 43) {\n      s2 = peg$c10;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e27); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (input.charCodeAt(peg$currPos) === 43) {\n          s2 = peg$c10;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e27); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e26); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseminus() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    if (input.charCodeAt(peg$currPos) === 45) {\n      s2 = peg$c11;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e29); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s2 = peg$c11;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e29); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e28); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsenum() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = [];\n    if (peg$r1.test(input.charAt(peg$currPos))) {\n      s3 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s3 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e31); }\n    }\n    if (s3 !== peg$FAILED) {\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        if (peg$r1.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e31); }\n        }\n      }\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f32(s1);\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e30); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsepct() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    s3 = peg$currPos;\n    s4 = [];\n    if (peg$r1.test(input.charAt(peg$currPos))) {\n      s5 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s5 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e31); }\n    }\n    if (s5 !== peg$FAILED) {\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        if (peg$r1.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e31); }\n        }\n      }\n    } else {\n      s4 = peg$FAILED;\n    }\n    if (s4 !== peg$FAILED) {\n      s3 = input.substring(s3, peg$currPos);\n    } else {\n      s3 = s4;\n    }\n    if (s3 !== peg$FAILED) {\n      s4 = peg$currPos;\n      s5 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s6 = peg$c6;\n        peg$currPos++;\n      } else {\n        s6 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e19); }\n      }\n      if (s6 !== peg$FAILED) {\n        s7 = peg$currPos;\n        s8 = [];\n        if (peg$r1.test(input.charAt(peg$currPos))) {\n          s9 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s9 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e31); }\n        }\n        while (s9 !== peg$FAILED) {\n          s8.push(s9);\n          if (peg$r1.test(input.charAt(peg$currPos))) {\n            s9 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s9 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e31); }\n          }\n        }\n        s7 = input.substring(s7, peg$currPos);\n        s6 = [s6, s7];\n        s5 = s6;\n      } else {\n        peg$currPos = s5;\n        s5 = peg$FAILED;\n      }\n      if (s5 === peg$FAILED) {\n        s5 = null;\n      }\n      s4 = input.substring(s4, peg$currPos);\n      s3 = [s3, s4];\n      s2 = s3;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s3 = peg$c6;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e19); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$currPos;\n        s5 = [];\n        if (peg$r1.test(input.charAt(peg$currPos))) {\n          s6 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e31); }\n        }\n        if (s6 !== peg$FAILED) {\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            if (peg$r1.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e31); }\n            }\n          }\n        } else {\n          s5 = peg$FAILED;\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = input.substring(s4, peg$currPos);\n        } else {\n          s4 = s5;\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f33(s1);\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e32); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsediv() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parsepct();\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e33); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsedec() {\n    var s0, s1, s2;\n\n    s0 = peg$parsepct();\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s1 = peg$c10;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e27); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsepct();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f34(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s1 = peg$c11;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e29); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsepct();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f35(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseint() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseminus();\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    s2 = peg$parsenum();\n    if (s2 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f36(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e34); }\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = [];\n    if (peg$r2.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e36); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$r2.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e36); }\n      }\n    }\n    peg$silentFails--;\n    s1 = peg$FAILED;\n    if (peg$silentFails === 0) { peg$fail(peg$e35); }\n\n    return s0;\n  }\n\n  function peg$parsesp() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$r2.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e36); }\n    }\n    if (s1 !== peg$FAILED) {\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$r2.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e36); }\n        }\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsehex() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$r3.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e37); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f37(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseEOL() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    peg$silentFails++;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    peg$silentFails--;\n    if (s1 === peg$FAILED) {\n      s0 = undefined;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n})()\n", "export default // Generated by Peggy 2.0.1.\n//\n// https://peggyjs.org/\n(function() {\n  \"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { body: peg$parsebody };\n  var peg$startRuleFunction = peg$parsebody;\n\n\n\n  var peg$e0 = peg$otherExpectation(\"decl_start\");\n  var peg$e1 = peg$otherExpectation(\"decl_end\");\n  var peg$e2 = peg$otherExpectation(\"vert\");\n  var peg$e3 = peg$anyExpectation();\n  var peg$e4 = peg$otherExpectation(\"l\");\n  var peg$e5 = peg$otherExpectation(\"r\");\n  var peg$e6 = peg$otherExpectation(\"c\");\n  var peg$e7 = peg$otherExpectation(\"p\");\n  var peg$e8 = peg$otherExpectation(\"m\");\n  var peg$e9 = peg$otherExpectation(\"b\");\n  var peg$e10 = peg$otherExpectation(\"w\");\n  var peg$e11 = peg$otherExpectation(\"W\");\n  var peg$e12 = peg$otherExpectation(\"X\");\n  var peg$e13 = peg$otherExpectation(\"!\");\n  var peg$e14 = peg$otherExpectation(\"@\");\n  var peg$e15 = peg$otherExpectation(\"<\");\n  var peg$e16 = peg$otherExpectation(\">\");\n  var peg$e17 = peg$otherExpectation(\"group\");\n  var peg$e18 = peg$otherExpectation(\"whitespace\");\n\n  var peg$f0 = function(c) { return c; };\n  var peg$f1 = function(cols) { return cols; };\n  var peg$f2 = function() { return []; };\n  var peg$f3 = function(divs1, start, a, end, divs2) {\n            return {\n                type: \"column\",\n                pre_dividers: divs1,\n                post_dividers: divs2,\n                before_start_code: start,\n                before_end_code: end,\n                alignment: a,\n            };\n        };\n  var peg$f4 = function() {\n                    return {\n                        type: \"vert_divider\",\n                    };\n                };\n  var peg$f5 = function(b, g) {\n                    return {\n                        type: \"bang_divider\",\n                        content: g[0].content,\n                    };\n                };\n  var peg$f6 = function(g) {\n                    return {\n                        type: \"at_divider\",\n                        content: g[0].content,\n                    };\n                };\n  var peg$f7 = function(div) { return div; };\n  var peg$f8 = function(g) { return { type: \"decl_code\", code: g[0].content }; };\n  var peg$f9 = function(g) { return { type: \"decl_code\", code: g[0].content }; };\n  var peg$f10 = function() { return { type: \"alignment\", alignment: \"left\" }; };\n  var peg$f11 = function() { return { type: \"alignment\", alignment: \"center\" }; };\n  var peg$f12 = function() { return { type: \"alignment\", alignment: \"right\" }; };\n  var peg$f13 = function() { return { type: \"alignment\", alignment: \"X\" }; };\n  var peg$f14 = function() { return \"top\"; };\n  var peg$f15 = function() { return \"default\"; };\n  var peg$f16 = function() { return \"bottom\"; };\n  var peg$f17 = function(a, g) {\n            return {\n                type: \"alignment\",\n                alignment: \"parbox\",\n                baseline: a,\n                size: g[0].content,\n            };\n        };\n  var peg$f18 = function(g1, g2) {\n            return {\n                type: \"alignment\",\n                alignment: \"parbox\",\n                baseline: g1[0].content,\n                size: g2[0].content,\n            };\n        };\n  var peg$f19 = function(tok) { return options.matchChar(tok, \"|\"); };\n  var peg$f20 = function(tok) { return options.matchChar(tok, \"l\"); };\n  var peg$f21 = function(tok) { return options.matchChar(tok, \"r\"); };\n  var peg$f22 = function(tok) { return options.matchChar(tok, \"c\"); };\n  var peg$f23 = function(tok) { return options.matchChar(tok, \"p\"); };\n  var peg$f24 = function(tok) { return options.matchChar(tok, \"m\"); };\n  var peg$f25 = function(tok) { return options.matchChar(tok, \"b\"); };\n  var peg$f26 = function(tok) { return options.matchChar(tok, \"w\"); };\n  var peg$f27 = function(tok) { return options.matchChar(tok, \"W\"); };\n  var peg$f28 = function(tok) { return options.matchChar(tok, \"X\"); };\n  var peg$f29 = function(tok) { return options.matchChar(tok, \"!\"); };\n  var peg$f30 = function(tok) { return options.matchChar(tok, \"@\"); };\n  var peg$f31 = function(tok) { return options.matchChar(tok, \"<\"); };\n  var peg$f32 = function(tok) { return options.matchChar(tok, \">\"); };\n  var peg$f33 = function(tok) { return options.isGroup(tok); };\n  var peg$f34 = function(tok) { return options.isWhitespace(tok); };\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = 0;\n  var peg$maxFailExpected = [];\n  var peg$silentFails = 0;\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsebody() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$currPos;\n    s3 = peg$parsecolumn();\n    if (s3 !== peg$FAILED) {\n      s4 = [];\n      s5 = peg$parse_();\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = peg$parse_();\n      }\n      peg$savedPos = s2;\n      s2 = peg$f0(s3);\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$currPos;\n        s3 = peg$parsecolumn();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parse_();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parse_();\n          }\n          peg$savedPos = s2;\n          s2 = peg$f0(s3);\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f1(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseEOL();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f2();\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecolumn() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsecolumn_divider();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsecolumn_divider();\n    }\n    s2 = peg$parsedecl_start();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    s3 = peg$parsealignment();\n    if (s3 !== peg$FAILED) {\n      s4 = peg$parsedecl_end();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      s5 = [];\n      s6 = peg$parsecolumn_divider();\n      while (s6 !== peg$FAILED) {\n        s5.push(s6);\n        s6 = peg$parsecolumn_divider();\n      }\n      peg$savedPos = s0;\n      s0 = peg$f3(s1, s2, s3, s4, s5);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecolumn_divider() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parse_();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parse_();\n    }\n    s2 = peg$currPos;\n    s3 = peg$parsevert();\n    if (s3 !== peg$FAILED) {\n      peg$savedPos = s2;\n      s3 = peg$f4();\n    }\n    s2 = s3;\n    if (s2 === peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$parsebang();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsegroup();\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s2;\n          s2 = peg$f5(s3, s4);\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$parseat();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsegroup();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s2;\n            s2 = peg$f6(s4);\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = [];\n      s4 = peg$parse_();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parse_();\n      }\n      peg$savedPos = s0;\n      s0 = peg$f7(s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedecl_start() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsegreater();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsegroup();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f8(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsedecl_end() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseless();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsegroup();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f9(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e1); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsealignment() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsel();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f10();\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsec();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f11();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parser();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f12();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseX();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f13();\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$currPos;\n            s2 = peg$parsep();\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s1;\n              s2 = peg$f14();\n            }\n            s1 = s2;\n            if (s1 === peg$FAILED) {\n              s1 = peg$currPos;\n              s2 = peg$parsem();\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s1;\n                s2 = peg$f15();\n              }\n              s1 = s2;\n              if (s1 === peg$FAILED) {\n                s1 = peg$currPos;\n                s2 = peg$parseb();\n                if (s2 !== peg$FAILED) {\n                  peg$savedPos = s1;\n                  s2 = peg$f16();\n                }\n                s1 = s2;\n              }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = [];\n              s3 = peg$parse_();\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$parse_();\n              }\n              s3 = peg$parsegroup();\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f17(s1, s3);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parsew();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parseW();\n              }\n              if (s1 !== peg$FAILED) {\n                s2 = [];\n                s3 = peg$parse_();\n                while (s3 !== peg$FAILED) {\n                  s2.push(s3);\n                  s3 = peg$parse_();\n                }\n                s3 = peg$parsegroup();\n                if (s3 !== peg$FAILED) {\n                  s4 = [];\n                  s5 = peg$parse_();\n                  while (s5 !== peg$FAILED) {\n                    s4.push(s5);\n                    s5 = peg$parse_();\n                  }\n                  s5 = peg$parsegroup();\n                  if (s5 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s0 = peg$f18(s3, s5);\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsevert() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f19(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsel() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f20(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e4); }\n    }\n\n    return s0;\n  }\n\n  function peg$parser() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f21(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e5); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsec() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f22(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e6); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsep() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f23(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e7); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsem() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f24(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e8); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseb() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f25(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e9); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsew() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f26(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e10); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseW() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f27(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e11); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseX() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f28(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e12); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsebang() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f29(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e13); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseat() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f30(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e14); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseless() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f31(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e15); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsegreater() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f32(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e16); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsegroup() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f33(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e17); }\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f34(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e18); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOL() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    peg$silentFails++;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    peg$silentFails--;\n    if (s1 === peg$FAILED) {\n      s0 = undefined;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n\n    //\n    // These are compatability functions used when running in the browser\n    //\n    // Check if the `options` object has the functions that we need.\n    // If not, try to add them\n    if (!options.isHash) {\n        try {\n            Object.assign(options, {\n                matchChar: (node, char) =>\n                    node.type === \"string\" && node.content === char,\n                isGroup: (node) => node.type === \"group\",\n                isWhitespace: (node) => node.type === \"whitespace\",\n            });\n        } catch (e) {\n            console.warn(\"Error when initializing parser\", e);\n        }\n    }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n})()\n", "export default // Generated by Peggy 2.0.1.\n//\n// https://peggyjs.org/\n(function() {\n  \"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { body: peg$parsebody };\n  var peg$startRuleFunction = peg$parsebody;\n\n\n\n  var peg$e0 = peg$otherExpectation(\"partial item\");\n  var peg$e1 = peg$otherExpectation(\"item\");\n  var peg$e2 = peg$anyExpectation();\n  var peg$e3 = peg$otherExpectation(\"equation\");\n  var peg$e4 = peg$otherExpectation(\"trailing comment\");\n  var peg$e5 = peg$otherExpectation(\"comment only line\");\n  var peg$e6 = peg$otherExpectation(\"non-var token\");\n  var peg$e7 = peg$otherExpectation(\"token\");\n  var peg$e8 = peg$otherExpectation(\"same line comment\");\n  var peg$e9 = peg$otherExpectation(\"own line comment\");\n  var peg$e10 = peg$otherExpectation(\",\");\n  var peg$e11 = peg$otherExpectation(\"@\");\n  var peg$e12 = peg$otherExpectation(\"variable token\");\n  var peg$e13 = peg$otherExpectation(\"+/-\");\n  var peg$e14 = peg$otherExpectation(\"=\");\n\n  var peg$f0 = function(a, b) { return a.concat(b ? b : []); };\n  var peg$f1 = function() { return []; };\n  var peg$f2 = function(a, b, c) { return a.concat(b, c); };\n  var peg$f3 = function(op, a, b, c) {\n            return { type: \"item\", op, variable: b, content: a.concat(b, c) };\n        };\n  var peg$f4 = function(op, a) {\n            return { type: \"item\", op, variable: null, content: a };\n        };\n  var peg$f5 = function(line, sep, comment) {\n            return { ...line, sep: [].concat(sep), trailingComment: comment };\n        };\n  var peg$f6 = function(line, comment) {\n            return { ...line, trailingComment: comment };\n        };\n  var peg$f7 = function(eq, ann) {\n            return {\n                type: \"line\",\n                equation: eq,\n                annotation: ann,\n                sep: null,\n            };\n        };\n  var peg$f8 = function(at, ann) {\n            return at ? { type: \"annotation\", marker: at, content: ann } : null;\n        };\n  var peg$f9 = function(left, eq, right) {\n            return { type: \"equation\", left, right, equals: eq };\n        };\n  var peg$f10 = function(x) { return x; };\n  var peg$f11 = function(x) {\n            return {\n                type: \"line\",\n                trailingComment: x,\n            };\n        };\n  var peg$f12 = function(v, s) { return [v].concat(s ? s : []); };\n  var peg$f13 = function(t) { return t; };\n  var peg$f14 = function(x) { return x; };\n  var peg$f15 = function(x) { return x; };\n  var peg$f16 = function(tok) { return options.isSameLineComment(tok); };\n  var peg$f17 = function(tok) { return tok; };\n  var peg$f18 = function(tok) { return options.isOwnLineComment(tok); };\n  var peg$f19 = function(tok) { return tok; };\n  var peg$f20 = function(tok) { return options.isWhitespace(tok); };\n  var peg$f21 = function(tok) { return tok; };\n  var peg$f22 = function(tok) { return options.isSep(tok); };\n  var peg$f23 = function(tok) { return tok; };\n  var peg$f24 = function(tok) { return options.isAt(tok); };\n  var peg$f25 = function(tok) { return tok; };\n  var peg$f26 = function(tok) { return options.isVar(tok); };\n  var peg$f27 = function(tok) { return tok; };\n  var peg$f28 = function(tok) { return options.isOperation(tok); };\n  var peg$f29 = function(tok) { return tok; };\n  var peg$f30 = function(tok) { return options.isEquals(tok); };\n  var peg$f31 = function(tok) { return tok; };\n  var peg$f32 = function(tok) { return options.isSubscript(tok); };\n  var peg$f33 = function(tok) { return tok; };\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = 0;\n  var peg$maxFailExpected = [];\n  var peg$silentFails = 0;\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsebody() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsecomment_only_line();\n    if (s2 === peg$FAILED) {\n      s2 = peg$parseline_with_sep();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsepartial_line_with_comment();\n      }\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsecomment_only_line();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseline_with_sep();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsepartial_line_with_comment();\n        }\n      }\n    }\n    s2 = peg$parseline_without_sep();\n    if (s2 === peg$FAILED) {\n      s2 = peg$parseEOL();\n    }\n    if (s2 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f0(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseEOL();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f1();\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsepartial_item() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parse_();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parse_();\n    }\n    s2 = [];\n    s3 = peg$parsenon_var_token();\n    while (s3 !== peg$FAILED) {\n      s2.push(s3);\n      s3 = peg$parsenon_var_token();\n    }\n    s3 = [];\n    s4 = peg$parse_();\n    while (s4 !== peg$FAILED) {\n      s3.push(s4);\n      s4 = peg$parse_();\n    }\n    s4 = peg$parsevar();\n    if (s4 !== peg$FAILED) {\n      s5 = [];\n      s6 = peg$parse_();\n      while (s6 !== peg$FAILED) {\n        s5.push(s6);\n        s6 = peg$parse_();\n      }\n      s6 = [];\n      s7 = peg$parsetoken();\n      while (s7 !== peg$FAILED) {\n        s6.push(s7);\n        s7 = peg$parsetoken();\n      }\n      s7 = [];\n      s8 = peg$parse_();\n      while (s8 !== peg$FAILED) {\n        s7.push(s8);\n        s8 = peg$parse_();\n      }\n      peg$savedPos = s0;\n      s0 = peg$f2(s2, s4, s6);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseitem() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseoperation();\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    s2 = [];\n    s3 = peg$parse_();\n    while (s3 !== peg$FAILED) {\n      s2.push(s3);\n      s3 = peg$parse_();\n    }\n    s3 = [];\n    s4 = peg$parsenon_var_token();\n    while (s4 !== peg$FAILED) {\n      s3.push(s4);\n      s4 = peg$parsenon_var_token();\n    }\n    s4 = [];\n    s5 = peg$parse_();\n    while (s5 !== peg$FAILED) {\n      s4.push(s5);\n      s5 = peg$parse_();\n    }\n    s5 = peg$parsevar();\n    if (s5 !== peg$FAILED) {\n      s6 = [];\n      s7 = peg$parse_();\n      while (s7 !== peg$FAILED) {\n        s6.push(s7);\n        s7 = peg$parse_();\n      }\n      s7 = [];\n      s8 = peg$parsetoken();\n      while (s8 !== peg$FAILED) {\n        s7.push(s8);\n        s8 = peg$parsetoken();\n      }\n      s8 = [];\n      s9 = peg$parse_();\n      while (s9 !== peg$FAILED) {\n        s8.push(s9);\n        s9 = peg$parse_();\n      }\n      peg$savedPos = s0;\n      s0 = peg$f3(s1, s3, s5, s7);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseoperation();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      s2 = [];\n      s3 = peg$parse_();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parse_();\n      }\n      s3 = [];\n      s4 = peg$parsenon_var_token();\n      if (s4 !== peg$FAILED) {\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsenon_var_token();\n        }\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parse_();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parse_();\n        }\n        peg$savedPos = s0;\n        s0 = peg$f4(s1, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e1); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseline_with_sep() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseline_without_sep();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetrailing_comment();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        peg$savedPos = s0;\n        s0 = peg$f5(s1, s2, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsepartial_line_with_comment() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseline_without_sep();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsetrailing_comment();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f6(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseline_without_sep() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    if (input.length > peg$currPos) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n    peg$silentFails--;\n    if (s2 !== peg$FAILED) {\n      peg$currPos = s1;\n      s1 = undefined;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseequation();\n      s3 = peg$parseannotation();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f7(s2, s3);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseannotation() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseat();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsenon_sep_token();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsenon_sep_token();\n      }\n      peg$savedPos = s0;\n      s0 = peg$f8(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseequation() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseitem();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parseitem();\n    }\n    s2 = peg$parseequals();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    s3 = [];\n    s4 = peg$parsetoken();\n    if (s4 === peg$FAILED) {\n      s4 = peg$parseoperation();\n    }\n    while (s4 !== peg$FAILED) {\n      s3.push(s4);\n      s4 = peg$parsetoken();\n      if (s4 === peg$FAILED) {\n        s4 = peg$parseoperation();\n      }\n    }\n    peg$savedPos = s0;\n    s0 = peg$f9(s1, s2, s3);\n    peg$silentFails--;\n    s1 = peg$FAILED;\n    if (peg$silentFails === 0) { peg$fail(peg$e3); }\n\n    return s0;\n  }\n\n  function peg$parsetrailing_comment() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parse_();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parse_();\n    }\n    s2 = peg$parsesame_line_comment();\n    if (s2 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f10(s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e4); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomment_only_line() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parse_();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parse_();\n    }\n    s2 = peg$parseown_line_comment();\n    if (s2 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f11(s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e5); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsevar() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsevar_token();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parse_();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parse_();\n      }\n      s3 = peg$parsesubscript();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f12(s1, s3);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenon_var_token() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    s2 = peg$parsevar();\n    peg$silentFails--;\n    if (s2 === peg$FAILED) {\n      s1 = undefined;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsetoken();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f13(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e6); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsenon_sep_token() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    s2 = peg$parsesep();\n    if (s2 === peg$FAILED) {\n      s2 = peg$parsetrailing_comment();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseown_line_comment();\n      }\n    }\n    peg$silentFails--;\n    if (s2 === peg$FAILED) {\n      s1 = undefined;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.length > peg$currPos) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e2); }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f14(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsetoken() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    s2 = peg$parsesep();\n    if (s2 === peg$FAILED) {\n      s2 = peg$parseat();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseoperation();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseequals();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsetrailing_comment();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parseown_line_comment();\n            }\n          }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s2 === peg$FAILED) {\n      s1 = undefined;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.length > peg$currPos) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e2); }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f15(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e7); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesame_line_comment() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f16(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f17(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e8); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseown_line_comment() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f18(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f19(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e9); }\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f20(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f21(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesep() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f22(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f23(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e10); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseat() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f24(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f25(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e11); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsevar_token() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f26(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f27(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e12); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseoperation() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parse_();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parse_();\n    }\n    if (input.length > peg$currPos) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = [];\n      s4 = peg$parse_();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parse_();\n      }\n      peg$savedPos = peg$currPos;\n      s4 = peg$f28(s2);\n      if (s4) {\n        s4 = undefined;\n      } else {\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f29(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e13); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseequals() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f30(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f31(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e14); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesubscript() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f32(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f33(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOL() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    peg$silentFails++;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n    peg$silentFails--;\n    if (s1 === peg$FAILED) {\n      s0 = undefined;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n\n    //\n    // These are compatability functions used when running in the browser\n    //\n    // Check if the `options` object has the functions that we need.\n    // If not, try to add them\n    if (!options.isWhitespace) {\n        try {\n            Object.assign(options, {\n                isSep: (node) => node.type === \"string\" && node.content === \",\",\n                isVar: (node) =>\n                    node.type === \"string\" && node.content.match(/[a-zA-Z]/),\n                isOperation: (node) =>\n                    node.type === \"string\" && node.content.match(/[+-]/),\n                isEquals: (node) =>\n                    node.type === \"string\" && node.content === \"=\",\n                isAt: (node) => node.type === \"string\" && node.content === \"@\",\n                isSubscript: (node) => node.content === \"_\",\n                isWhitespace: (node) => node.type === \"whitespace\",\n                isSameLineComment: (node) =>\n                    node.type === \"comment\" && node.sameline,\n                isOwnLineComment: (node) =>\n                    node.type === \"comment\" && !node.sameline,\n            });\n        } catch (e) {\n            console.warn(\"Error when initializing parser\", e);\n        }\n    }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n})()\n", "export default // Generated by Peggy 2.0.1.\n//\n// https://peggyjs.org/\n(function() {\n  \"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { root: peg$parseroot };\n  var peg$startRuleFunction = peg$parseroot;\n\n  var peg$c0 = \"plus\";\n  var peg$c1 = \"minus\";\n  var peg$c2 = \"pt\";\n  var peg$c3 = \"mm\";\n  var peg$c4 = \"cm\";\n  var peg$c5 = \"in\";\n  var peg$c6 = \"ex\";\n  var peg$c7 = \"em\";\n  var peg$c8 = \"bp\";\n  var peg$c9 = \"pc\";\n  var peg$c10 = \"dd\";\n  var peg$c11 = \"cc\";\n  var peg$c12 = \"nd\";\n  var peg$c13 = \"nc\";\n  var peg$c14 = \"sp\";\n  var peg$c15 = \"filll\";\n  var peg$c16 = \"fill\";\n  var peg$c17 = \"fil\";\n  var peg$c18 = \".\";\n  var peg$c19 = \"+\";\n  var peg$c20 = \"-\";\n\n  var peg$r0 = /^[0-9]/;\n\n  var peg$e0 = peg$anyExpectation();\n  var peg$e1 = peg$literalExpectation(\"plus\", false);\n  var peg$e2 = peg$literalExpectation(\"minus\", false);\n  var peg$e3 = peg$literalExpectation(\"pt\", false);\n  var peg$e4 = peg$literalExpectation(\"mm\", false);\n  var peg$e5 = peg$literalExpectation(\"cm\", false);\n  var peg$e6 = peg$literalExpectation(\"in\", false);\n  var peg$e7 = peg$literalExpectation(\"ex\", false);\n  var peg$e8 = peg$literalExpectation(\"em\", false);\n  var peg$e9 = peg$literalExpectation(\"bp\", false);\n  var peg$e10 = peg$literalExpectation(\"pc\", false);\n  var peg$e11 = peg$literalExpectation(\"dd\", false);\n  var peg$e12 = peg$literalExpectation(\"cc\", false);\n  var peg$e13 = peg$literalExpectation(\"nd\", false);\n  var peg$e14 = peg$literalExpectation(\"nc\", false);\n  var peg$e15 = peg$literalExpectation(\"sp\", false);\n  var peg$e16 = peg$literalExpectation(\"filll\", false);\n  var peg$e17 = peg$literalExpectation(\"fill\", false);\n  var peg$e18 = peg$literalExpectation(\"fil\", false);\n  var peg$e19 = peg$otherExpectation(\"number\");\n  var peg$e20 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n  var peg$e21 = peg$literalExpectation(\".\", false);\n  var peg$e22 = peg$literalExpectation(\"+\", false);\n  var peg$e23 = peg$literalExpectation(\"-\", false);\n\n  var peg$f0 = function(b, st, sh) {\n                    // Only return the non-null glue items\n                    return {\n                        type: \"glue\",\n                        fixed: b,\n                        stretchable: st,\n                        shrinkable: sh,\n                        position: location(),\n                    };\n                };\n  var peg$f1 = function(glue) { return glue; };\n  var peg$f2 = function(n, u) { return { type: \"dim\", value: n, unit: u }; };\n  var peg$f3 = function(n, u) {\n            return { type: \"dim\", value: n, unit: u };\n        };\n  var peg$f4 = function(n, u) {\n            return { type: \"dim\", value: n, unit: u };\n        };\n  var peg$f5 = function(n) { return parseFloat(n); };\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = 0;\n  var peg$maxFailExpected = [];\n  var peg$silentFails = 0;\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parseroot() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsebase();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsestretchable();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      s4 = peg$parseshrinkable();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      peg$savedPos = s1;\n      s1 = peg$f0(s2, s3, s4);\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      if (input.length > peg$currPos) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e0); }\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        if (input.length > peg$currPos) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e0); }\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f1(s1);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsebase() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseunit();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f2(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestretchable() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 4) === peg$c0) {\n      s1 = peg$c0;\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e1); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsenumber();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parserubber_unit();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f3(s2, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseshrinkable() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c1) {\n      s1 = peg$c1;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsenumber();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parserubber_unit();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f4(s2, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseunit() {\n    var s0;\n\n    if (input.substr(peg$currPos, 2) === peg$c2) {\n      s0 = peg$c2;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c3) {\n        s0 = peg$c3;\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e4); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c4) {\n          s0 = peg$c4;\n          peg$currPos += 2;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e5); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c5) {\n            s0 = peg$c5;\n            peg$currPos += 2;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e6); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c6) {\n              s0 = peg$c6;\n              peg$currPos += 2;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e7); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c7) {\n                s0 = peg$c7;\n                peg$currPos += 2;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e8); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 2) === peg$c8) {\n                  s0 = peg$c8;\n                  peg$currPos += 2;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e9); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 2) === peg$c9) {\n                    s0 = peg$c9;\n                    peg$currPos += 2;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e10); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 2) === peg$c10) {\n                      s0 = peg$c10;\n                      peg$currPos += 2;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$e11); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 2) === peg$c11) {\n                        s0 = peg$c11;\n                        peg$currPos += 2;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$e12); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 2) === peg$c12) {\n                          s0 = peg$c12;\n                          peg$currPos += 2;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$e13); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 2) === peg$c13) {\n                            s0 = peg$c13;\n                            peg$currPos += 2;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$e14); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 2) === peg$c14) {\n                              s0 = peg$c14;\n                              peg$currPos += 2;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$e15); }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parserubber_unit() {\n    var s0;\n\n    s0 = peg$parseunit();\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 5) === peg$c15) {\n        s0 = peg$c15;\n        peg$currPos += 5;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e16); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 4) === peg$c16) {\n          s0 = peg$c16;\n          peg$currPos += 4;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e17); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 3) === peg$c17) {\n            s0 = peg$c17;\n            peg$currPos += 3;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e18); }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    s3 = peg$parsesign();\n    if (s3 === peg$FAILED) {\n      s3 = null;\n    }\n    s4 = peg$currPos;\n    s5 = [];\n    if (peg$r0.test(input.charAt(peg$currPos))) {\n      s6 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s6 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e20); }\n    }\n    while (s6 !== peg$FAILED) {\n      s5.push(s6);\n      if (peg$r0.test(input.charAt(peg$currPos))) {\n        s6 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s6 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e20); }\n      }\n    }\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s6 = peg$c18;\n      peg$currPos++;\n    } else {\n      s6 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e21); }\n    }\n    if (s6 !== peg$FAILED) {\n      s7 = [];\n      if (peg$r0.test(input.charAt(peg$currPos))) {\n        s8 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s8 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e20); }\n      }\n      if (s8 !== peg$FAILED) {\n        while (s8 !== peg$FAILED) {\n          s7.push(s8);\n          if (peg$r0.test(input.charAt(peg$currPos))) {\n            s8 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e20); }\n          }\n        }\n      } else {\n        s7 = peg$FAILED;\n      }\n      if (s7 !== peg$FAILED) {\n        s5 = [s5, s6, s7];\n        s4 = s5;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s4;\n      s4 = peg$FAILED;\n    }\n    if (s4 === peg$FAILED) {\n      s4 = [];\n      if (peg$r0.test(input.charAt(peg$currPos))) {\n        s5 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e20); }\n      }\n      if (s5 !== peg$FAILED) {\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          if (peg$r0.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e20); }\n          }\n        }\n      } else {\n        s4 = peg$FAILED;\n      }\n    }\n    if (s4 !== peg$FAILED) {\n      s3 = [s3, s4];\n      s2 = s3;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f5(s1);\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e19); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesign() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 43) {\n      s0 = peg$c19;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e22); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 45) {\n        s0 = peg$c20;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e23); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOL() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    peg$silentFails++;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    peg$silentFails--;\n    if (s1 === peg$FAILED) {\n      s0 = undefined;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n})()\n", "export default // Generated by Peggy 2.0.1.\n//\n// https://peggyjs.org/\n(function() {\n  \"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { path_spec: peg$parsepath_spec, foreach_body: peg$parseforeach_body };\n  var peg$startRuleFunction = peg$parsepath_spec;\n\n\n\n  var peg$e0 = peg$anyExpectation();\n  var peg$e1 = peg$otherExpectation(\"same line comment\");\n  var peg$e2 = peg$otherExpectation(\"own line comment\");\n  var peg$e3 = peg$otherExpectation(\"comment\");\n  var peg$e4 = peg$otherExpectation(\"floating comment\");\n  var peg$e5 = peg$otherExpectation(\"operation\");\n  var peg$e6 = peg$otherExpectation(\"=\");\n\n  var peg$f0 = function(v) { return v; };\n  var peg$f1 = function(ops) { return { type: \"path_spec\", content: ops }; };\n  var peg$f2 = function(c1, op, comment) { return { op, comment }; };\n  var peg$f3 = function(c1, ops, c2, body) {\n            const comments = [c1, ...ops.map((x) => x.comment), c2].filter(\n                (x) => x\n            );\n            const attribute = ops.map((x) => x.op.content.content).join(\" \");\n            return {\n                type: \"animation\",\n                comments,\n                attribute,\n                content: body.content,\n            };\n        };\n  var peg$f4 = function(start, b) {\n            return { ...b, start, type: \"foreach\" };\n        };\n  var peg$f5 = function(c1, variables, options, c2, c3, list, c4, command) {\n            const comments = [c1, c2, c3, c4].filter((x) => x);\n            return {\n                type: \"foreach_body\",\n                variables,\n                options: options && options.content,\n                list,\n                command,\n                comments,\n            };\n        };\n  var peg$f6 = function(c1, options, c2, body) {\n            const comments = [c1, c2].filter((x) => x);\n            return {\n                type: \"svg_operation\",\n                options: options && options.content,\n                content: body,\n                comments,\n            };\n        };\n  var peg$f7 = function(c1, c2, coord, c3, c4, x) {\n                    return { coord: x, comment: c4 };\n                };\n  var peg$f8 = function(c1, c2, coord, c3, a, c5) {\n            const comments = [c1, c2, c3, a && a.comment, c5].filter((x) => x);\n            return {\n                type: \"curve_to\",\n                controls: a ? [coord, a.coord] : [coord],\n                comments,\n            };\n        };\n  var peg$f9 = function() { return { type: \"line_to\", command: \"|-\" }; };\n  var peg$f10 = function() { return { type: \"line_to\", command: \"-|\" }; };\n  var peg$f11 = function() { return { type: \"line_to\", command: \"--\" }; };\n  var peg$f12 = function(prefix, content) {\n            return { type: \"coordinate\", content, prefix };\n        };\n  var peg$f13 = function(content) {\n            return { type: \"square_brace_group\", content };\n        };\n  var peg$f14 = function(v) { return { type: \"unknown\", content: v }; };\n  var peg$f15 = function(tok) { return options.isSameLineComment(tok); };\n  var peg$f16 = function(tok) { return tok; };\n  var peg$f17 = function(tok) { return options.isOwnLineComment(tok); };\n  var peg$f18 = function(tok) { return tok; };\n  var peg$f19 = function(tok) { return options.isComment(tok); };\n  var peg$f20 = function(tok) { return tok; };\n  var peg$f21 = function(tok) { return options.isWhitespace(tok); };\n  var peg$f22 = function(tok) { return tok; };\n  var peg$f23 = function(c) { return c; };\n  var peg$f24 = function(tok) { return options.isOperation(tok); };\n  var peg$f25 = function(tok) {\n            return { type: \"operation\", content: tok };\n        };\n  var peg$f26 = function(tok) { return options.isChar(tok, \"=\"); };\n  var peg$f27 = function(tok) { return tok; };\n  var peg$f28 = function(tok) { return options.isChar(tok, \"[\"); };\n  var peg$f29 = function(tok) { return tok; };\n  var peg$f30 = function(tok) { return options.isChar(tok, \"]\"); };\n  var peg$f31 = function(tok) { return tok; };\n  var peg$f32 = function(tok) { return options.isChar(tok, \"(\"); };\n  var peg$f33 = function(tok) { return tok; };\n  var peg$f34 = function(tok) { return options.isChar(tok, \")\"); };\n  var peg$f35 = function(tok) { return tok; };\n  var peg$f36 = function(tok) { return options.isChar(tok, \"+\"); };\n  var peg$f37 = function(tok) { return tok; };\n  var peg$f38 = function(tok) { return options.isChar(tok, \"-\"); };\n  var peg$f39 = function(tok) { return tok; };\n  var peg$f40 = function(tok) { return options.isChar(tok, \"|\"); };\n  var peg$f41 = function(tok) { return tok; };\n  var peg$f42 = function(tok) { return options.isChar(tok, \".\"); };\n  var peg$f43 = function(tok) { return tok; };\n  var peg$f44 = function(tok) { return options.isChar(tok, \"controls\"); };\n  var peg$f45 = function(tok) { return tok; };\n  var peg$f46 = function(tok) { return options.isChar(tok, \"and\"); };\n  var peg$f47 = function(tok) { return tok; };\n  var peg$f48 = function(tok) { return options.isChar(tok, \"svg\"); };\n  var peg$f49 = function(tok) { return tok; };\n  var peg$f50 = function(tok) { return options.isGroup(tok); };\n  var peg$f51 = function(tok) { return tok; };\n  var peg$f52 = function(tok) { return options.isAnyMacro(tok); };\n  var peg$f53 = function(tok) { return tok; };\n  var peg$f54 = function(tok) { return options.isChar(tok, \"foreach\"); };\n  var peg$f55 = function(tok) { return tok; };\n  var peg$f56 = function(tok) { return options.isMacro(tok, \"foreach\"); };\n  var peg$f57 = function(tok) { return tok; };\n  var peg$f58 = function(tok) { return options.isChar(tok, \"in\"); };\n  var peg$f59 = function(tok) { return tok; };\n  var peg$f60 = function(tok) { return options.isChar(tok, \":\"); };\n  var peg$f61 = function(tok) { return tok; };\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = 0;\n  var peg$maxFailExpected = [];\n  var peg$silentFails = 0;\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsepath_spec() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$currPos;\n    s3 = peg$parsesquare_brace_group();\n    if (s3 === peg$FAILED) {\n      s3 = peg$parsecoordinate();\n      if (s3 === peg$FAILED) {\n        s3 = peg$parsecurve_to();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseline_to();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parsesvg();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parseforeach();\n              if (s3 === peg$FAILED) {\n                s3 = peg$parseoperation();\n                if (s3 === peg$FAILED) {\n                  s3 = peg$parsecomment();\n                  if (s3 === peg$FAILED) {\n                    s3 = peg$parseanimation();\n                    if (s3 === peg$FAILED) {\n                      s3 = peg$parseunknown();\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    if (s3 !== peg$FAILED) {\n      s4 = [];\n      s5 = peg$parse_();\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = peg$parse_();\n      }\n      peg$savedPos = s2;\n      s2 = peg$f0(s3);\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$currPos;\n        s3 = peg$parsesquare_brace_group();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsecoordinate();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parsecurve_to();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parseline_to();\n              if (s3 === peg$FAILED) {\n                s3 = peg$parsesvg();\n                if (s3 === peg$FAILED) {\n                  s3 = peg$parseforeach();\n                  if (s3 === peg$FAILED) {\n                    s3 = peg$parseoperation();\n                    if (s3 === peg$FAILED) {\n                      s3 = peg$parsecomment();\n                      if (s3 === peg$FAILED) {\n                        s3 = peg$parseanimation();\n                        if (s3 === peg$FAILED) {\n                          s3 = peg$parseunknown();\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parse_();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parse_();\n          }\n          peg$savedPos = s2;\n          s2 = peg$f0(s3);\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f1(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseanimation() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecolon();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_comment_();\n      s3 = [];\n      s4 = peg$currPos;\n      s5 = peg$parseoperation();\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse_comment_();\n        peg$savedPos = s4;\n        s4 = peg$f2(s2, s5, s6);\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$currPos;\n          s5 = peg$parseoperation();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_comment_();\n            peg$savedPos = s4;\n            s4 = peg$f2(s2, s5, s6);\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        }\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parseequals();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parse_comment_();\n          s6 = peg$parsegroup();\n          if (s6 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f3(s2, s3, s5, s6);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseforeach() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseforeach_keyword();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseforeach_macro();\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseforeach_body();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f4(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseforeach_body() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_comment_();\n    s2 = peg$currPos;\n    s3 = [];\n    s4 = peg$currPos;\n    s5 = peg$currPos;\n    peg$silentFails++;\n    s6 = peg$parsein_keyword();\n    if (s6 === peg$FAILED) {\n      s6 = peg$parsesquare_brace_group();\n    }\n    peg$silentFails--;\n    if (s6 === peg$FAILED) {\n      s5 = undefined;\n    } else {\n      peg$currPos = s5;\n      s5 = peg$FAILED;\n    }\n    if (s5 !== peg$FAILED) {\n      if (input.length > peg$currPos) {\n        s6 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s6 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e0); }\n      }\n      if (s6 !== peg$FAILED) {\n        s5 = [s5, s6];\n        s4 = s5;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s4;\n      s4 = peg$FAILED;\n    }\n    while (s4 !== peg$FAILED) {\n      s3.push(s4);\n      s4 = peg$currPos;\n      s5 = peg$currPos;\n      peg$silentFails++;\n      s6 = peg$parsein_keyword();\n      if (s6 === peg$FAILED) {\n        s6 = peg$parsesquare_brace_group();\n      }\n      peg$silentFails--;\n      if (s6 === peg$FAILED) {\n        s5 = undefined;\n      } else {\n        peg$currPos = s5;\n        s5 = peg$FAILED;\n      }\n      if (s5 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s6 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e0); }\n        }\n        if (s6 !== peg$FAILED) {\n          s5 = [s5, s6];\n          s4 = s5;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n    }\n    s2 = input.substring(s2, peg$currPos);\n    s3 = peg$parsesquare_brace_group();\n    if (s3 === peg$FAILED) {\n      s3 = null;\n    }\n    s4 = peg$parse_comment_();\n    s5 = peg$parsein_keyword();\n    if (s5 !== peg$FAILED) {\n      s6 = peg$parse_comment_();\n      s7 = peg$parsegroup();\n      if (s7 === peg$FAILED) {\n        s7 = peg$parsemacro();\n      }\n      if (s7 !== peg$FAILED) {\n        s8 = peg$parse_comment_();\n        s9 = peg$parseforeach();\n        if (s9 === peg$FAILED) {\n          s9 = peg$parsegroup();\n          if (s9 === peg$FAILED) {\n            s9 = peg$parsemacro();\n          }\n        }\n        if (s9 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f5(s1, s2, s3, s4, s6, s7, s8, s9);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesvg() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsesvg_keyword();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_comment_();\n      s3 = peg$parsesquare_brace_group();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      s4 = peg$parse_comment_();\n      s5 = peg$parsegroup();\n      if (s5 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f6(s2, s3, s4, s5);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecurve_to() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n\n    s0 = peg$currPos;\n    s1 = peg$parsedotdot();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_comment_();\n      s3 = peg$parsecontrols_keyword();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse_comment_();\n        s5 = peg$parsecoordinate();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_comment_();\n          s7 = peg$currPos;\n          s8 = peg$parseand_keyword();\n          if (s8 !== peg$FAILED) {\n            s9 = peg$parse_comment_();\n            s10 = peg$parsecoordinate();\n            if (s10 !== peg$FAILED) {\n              peg$savedPos = s7;\n              s7 = peg$f7(s2, s4, s5, s6, s9, s10);\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s7;\n            s7 = peg$FAILED;\n          }\n          if (s7 === peg$FAILED) {\n            s7 = null;\n          }\n          s8 = peg$parse_comment_();\n          s9 = peg$parsedotdot();\n          if (s9 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f8(s2, s4, s5, s6, s7, s8);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseline_to() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsepipe();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseminus();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f9();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseminus();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsepipe();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f10();\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseminus();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseminus();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f11();\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecoordinate() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    s3 = peg$parseplus();\n    if (s3 !== peg$FAILED) {\n      s4 = peg$parseplus();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      s3 = [s3, s4];\n      s2 = s3;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    s1 = input.substring(s1, peg$currPos);\n    s2 = peg$parseopen_paren();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$currPos;\n      s4 = [];\n      s5 = peg$currPos;\n      s6 = peg$currPos;\n      peg$silentFails++;\n      s7 = peg$parseclose_paren();\n      peg$silentFails--;\n      if (s7 === peg$FAILED) {\n        s6 = undefined;\n      } else {\n        peg$currPos = s6;\n        s6 = peg$FAILED;\n      }\n      if (s6 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s7 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s7 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e0); }\n        }\n        if (s7 !== peg$FAILED) {\n          s6 = [s6, s7];\n          s5 = s6;\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s5;\n        s5 = peg$FAILED;\n      }\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = peg$currPos;\n        s6 = peg$currPos;\n        peg$silentFails++;\n        s7 = peg$parseclose_paren();\n        peg$silentFails--;\n        if (s7 === peg$FAILED) {\n          s6 = undefined;\n        } else {\n          peg$currPos = s6;\n          s6 = peg$FAILED;\n        }\n        if (s6 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s7 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e0); }\n          }\n          if (s7 !== peg$FAILED) {\n            s6 = [s6, s7];\n            s5 = s6;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n      }\n      s3 = input.substring(s3, peg$currPos);\n      s4 = peg$parseclose_paren();\n      if (s4 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f12(s1, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesquare_brace_group() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$parseopen_square_brace();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = peg$currPos;\n      s5 = peg$currPos;\n      peg$silentFails++;\n      s6 = peg$parseclose_square_brace();\n      peg$silentFails--;\n      if (s6 === peg$FAILED) {\n        s5 = undefined;\n      } else {\n        peg$currPos = s5;\n        s5 = peg$FAILED;\n      }\n      if (s5 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s6 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e0); }\n        }\n        if (s6 !== peg$FAILED) {\n          s5 = [s5, s6];\n          s4 = s5;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$currPos;\n        s5 = peg$currPos;\n        peg$silentFails++;\n        s6 = peg$parseclose_square_brace();\n        peg$silentFails--;\n        if (s6 === peg$FAILED) {\n          s5 = undefined;\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n        if (s5 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s6 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e0); }\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n      }\n      s2 = input.substring(s2, peg$currPos);\n      s3 = peg$parseclose_square_brace();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f13(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedotdot() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsedot();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsedot();\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseunknown() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f14(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesame_line_comment() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f15(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f16(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e1); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseown_line_comment() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f17(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f18(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomment() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f19(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f20(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f21(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f22(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parse_comment_() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parse_();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parse_();\n    }\n    s2 = peg$parsecomment();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    s3 = [];\n    s4 = peg$parse_();\n    while (s4 !== peg$FAILED) {\n      s3.push(s4);\n      s4 = peg$parse_();\n    }\n    peg$savedPos = s0;\n    s0 = peg$f23(s2);\n    peg$silentFails--;\n    s1 = peg$FAILED;\n    if (peg$silentFails === 0) { peg$fail(peg$e4); }\n\n    return s0;\n  }\n\n  function peg$parseoperation() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f24(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f25(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e5); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseequals() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f26(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f27(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e6); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseopen_square_brace() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f28(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f29(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseclose_square_brace() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f30(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f31(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseopen_paren() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f32(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f33(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseclose_paren() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f34(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f35(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseplus() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f36(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f37(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseminus() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f38(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f39(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsepipe() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f40(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f41(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedot() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f42(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f43(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecontrols_keyword() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f44(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f45(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseand_keyword() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f46(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f47(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesvg_keyword() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f48(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f49(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsegroup() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f50(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f51(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemacro() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f52(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f53(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseforeach_keyword() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f54(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f55(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseforeach_macro() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f56(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f57(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsein_keyword() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f58(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f59(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecolon() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f60(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f61(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOL() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    peg$silentFails++;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    peg$silentFails--;\n    if (s1 === peg$FAILED) {\n      s0 = undefined;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n\n    //\n    // These are compatability functions used when running in the browser\n    //\n    // Check if the `options` object has the functions that we need.\n    // If not, try to add them\n    if (!options.isWhitespace) {\n        try {\n            Object.assign(options, {\n                isChar: (node, char) =>\n                    node.type === \"string\" && node.content === char,\n                isOperation: (node) =>\n                    node.type === \"string\" && node.content.match(/[a-zA-Z]/),\n                isWhitespace: (node) =>\n                    node.type === \"whitespace\" || node.type === \"parbreak\",\n                isSameLineComment: (node) =>\n                    node.type === \"comment\" && node.sameline,\n                isOwnLineComment: (node) =>\n                    node.type === \"comment\" && !node.sameline,\n                isComment: (node) => node.type === \"comment\",\n                isGroup: (node) => node.type === \"group\",\n                isMacro: (node, name) =>\n                    node.type === \"macro\" && node.content === name,\n                isAnyMacro: (node) => node.type === \"macro\",\n            });\n        } catch (e) {\n            console.warn(\"Error when initializing parser\", e);\n        }\n    }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n})()\n", "// This file needs to be here because typescript does not know how to use babel's transpiler\n// to directly load Pegjs grammars.\n// @ts-nocheck\nimport _LatexPegParser from \"../grammars/latex.pegjs\";\nimport _AlignEnvironmentPegParser from \"../grammars/align-environment.pegjs\";\nimport _ArgSpecPegParser from \"../grammars/xparse-argspec.pegjs\";\nimport _PgfkeysPegParser from \"../grammars/pgfkeys.pegjs\";\nimport _MacroSubstitutionPegParser from \"../grammars/macro-substitutions.pegjs\";\nimport _LigaturesPegParser from \"../grammars/ligatures.pegjs\";\nimport _XColorPegParser from \"../grammars/xcolor-expressions.pegjs\";\nimport _TabularPegParser from \"../grammars/tabular-spec.pegjs\";\nimport _SystemePegParser from \"../grammars/systeme-environment.pegjs\";\nimport _GluePegParser from \"../grammars/tex-glue.pegjs\";\nimport _TikzPegParser from \"../grammars/tikz.pegjs\";\n\ntype PegParser = {\n    parse: (input: string | unknown[], options?: unknown) => any;\n    SyntaxError: (\n        message: string,\n        expected: string,\n        found: unknown,\n        location: unknown\n    ) => unknown;\n};\n\nconst LatexPegParser = _LatexPegParser as PegParser;\nconst AlignEnvironmentPegParser = _AlignEnvironmentPegParser as PegParser;\nconst ArgSpecPegParser = _ArgSpecPegParser as PegParser;\nconst PgfkeysPegParser = _PgfkeysPegParser as PegParser;\nconst MacroSubstitutionPegParser = _MacroSubstitutionPegParser as PegParser;\nconst LigaturesPegParser = _LigaturesPegParser as PegParser;\nconst XColorPegParser = _XColorPegParser as PegParser;\nconst TabularPegParser = _TabularPegParser as PegParser;\nconst SystemePegParser = _SystemePegParser as PegParser;\nconst GluePegParser = _GluePegParser as PegParser;\nconst TikzPegParser = _TikzPegParser as PegParser;\n\nexport {\n    LatexPegParser,\n    AlignEnvironmentPegParser,\n    ArgSpecPegParser,\n    PgfkeysPegParser,\n    MacroSubstitutionPegParser,\n    LigaturesPegParser,\n    XColorPegParser,\n    TabularPegParser,\n    SystemePegParser,\n    GluePegParser,\n    TikzPegParser,\n};\n", "import { ArgSpecPegParser as PegParser } from \"@unified-latex/unified-latex-util-pegjs\";\nimport * as ArgSpec from \"./argspec-types\";\n\n/**\n * Produce a string containing any decorators for the argspec node.\n * For example, `!` in front of a node means \"don't accept leading whitespace\"\n */\nfunction getDecorators(node: ArgSpec.Node): string {\n    let ret = \"\";\n    if ((node as ArgSpec.LeadingWhitespace).noLeadingWhitespace) {\n        ret += \"!\";\n    }\n    return ret;\n}\n\n/**\n * Print an `xparse` argument specification AST\n * to a string.\n */\nexport function printRaw(node: ArgSpec.Ast, root = false): string {\n    if (typeof node === \"string\") {\n        return node;\n    }\n\n    if (Array.isArray(node)) {\n        const sepToken = root ? \" \" : \"\";\n        return node.map((tok) => printRaw(tok)).join(sepToken);\n    }\n\n    const decorators = getDecorators(node);\n    const defaultArg = (node as ArgSpec.DefaultArgument).defaultArg\n        ? printRaw((node as ArgSpec.DefaultArgument).defaultArg)\n        : \"\";\n    let spec = decorators;\n\n    const type = node.type;\n    switch (type) {\n        case \"body\":\n            return decorators + \"b\";\n        case \"optionalStar\":\n            return decorators + \"s\";\n        case \"optionalToken\":\n            return spec + \"t\" + node.token;\n        case \"optional\":\n            // [...] is the default enclosure for optional arguments\n            if (node.openBrace === \"[\" && node.closeBrace === \"]\") {\n                spec += node.defaultArg ? \"O\" : \"o\";\n            } else {\n                spec += node.defaultArg ? \"D\" : \"d\";\n                spec += node.openBrace + node.closeBrace;\n            }\n            return spec + defaultArg;\n        case \"mandatory\":\n            // {...} is the default enclosure for mandatory arguments\n            if (node.openBrace === \"{\" && node.closeBrace === \"}\") {\n                spec += \"m\";\n            } else {\n                spec += node.defaultArg ? \"R\" : \"r\";\n                spec += node.openBrace + node.closeBrace;\n            }\n            return spec + defaultArg;\n        case \"embellishment\":\n            spec += node.defaultArg ? \"E\" : \"e\";\n            return (\n                spec +\n                \"{\" +\n                printRaw(node.embellishmentTokens) +\n                \"}\" +\n                defaultArg\n            );\n        case \"verbatim\":\n            return spec + \"v\" + node.openBrace;\n        case \"group\":\n            return spec + \"{\" + printRaw(node.content) + \"}\";\n        case \"until\": {\n            const stopTokens = printRaw(node.stopTokens);\n            return stopTokens.length > 1 || stopTokens[0] === \" \"\n                ? `u{${stopTokens}}`\n                : `u${stopTokens}`;\n        }\n        default:\n            const neverType: never = type;\n            console.warn(`Unknown node type \"${neverType}\" for node`, node);\n            return \"\";\n    }\n}\n\nconst parseCache: { [argStr: string]: ArgSpec.Node[] } = {};\n\n/**\n * Parse an `xparse` argument specification string to an AST.\n * This function caches results. Don't mutate the returned AST!\n *\n * @param {string} [str=\"\"] - LaTeX string input\n * @returns - AST for LaTeX string\n */\nexport function parse(str = \"\"): ArgSpec.Node[] {\n    parseCache[str] = parseCache[str] || PegParser.parse(str);\n    return parseCache[str];\n}\n", "export type Ast = Node[] | Node;\nexport type Node =\n    | Optional\n    | Mandatory\n    | Verbatim\n    | Body\n    | Group\n    | Until\n    | string;\ntype Optional = OptionalArg | OptionalStar | OptionalToken | Embellishment;\ninterface AstNode {\n    type: string;\n}\ninterface Arg extends AstNode {\n    openBrace: string;\n    closeBrace: string;\n}\nexport interface LeadingWhitespace {\n    noLeadingWhitespace: boolean | undefined;\n}\nexport interface DefaultArgument {\n    defaultArg: Group;\n}\ninterface Verbatim extends Arg {\n    type: \"verbatim\";\n}\ninterface OptionalArg extends LeadingWhitespace, DefaultArgument, Arg {\n    type: \"optional\";\n}\ninterface OptionalStar extends LeadingWhitespace, AstNode {\n    type: \"optionalStar\";\n}\ninterface OptionalToken extends LeadingWhitespace, AstNode {\n    type: \"optionalToken\";\n    token: string;\n}\ninterface Embellishment extends DefaultArgument, AstNode {\n    type: \"embellishment\";\n    embellishmentTokens: string[];\n}\ninterface Mandatory extends LeadingWhitespace, DefaultArgument, Arg {\n    type: \"mandatory\";\n}\ninterface Group extends AstNode {\n    type: \"group\";\n    content: (Group | string)[];\n}\ninterface Body extends AstNode {\n    type: \"body\";\n}\ninterface Until extends AstNode {\n    type: \"until\";\n    stopTokens: string[];\n}\n", "import type * as Ast from \"@unified-latex/unified-latex-types\";\n\ntype CoercibleNode = string | Ast.Node;\ntype CoercibleArgument = null | CoercibleNode | Ast.Argument;\ntype MacroSpecialOptions = {\n    escapeToken?: string;\n};\ntype ArgumentsSpecialOptions = {\n    braces?: string;\n    defaultOpenMark?: string;\n    defaultCloseMark?: string;\n};\ntype ArgumentSpecialOptions = {\n    braces?: string;\n    openMark?: string;\n    closeMark?: string;\n};\n\nfunction normalizeNode(node: CoercibleNode): Ast.Node {\n    if (typeof node === \"string\") {\n        return s(node);\n    }\n    return node;\n}\n\nfunction normalizeArgument(\n    arg: CoercibleArgument,\n    openMark = \"{\",\n    closeMark = \"}\"\n): Ast.Argument {\n    if (arg == null) {\n        return { type: \"argument\", content: [], openMark: \"\", closeMark: \"\" };\n    }\n    if (typeof arg === \"string\") {\n        return {\n            type: \"argument\",\n            openMark,\n            closeMark,\n            content: [s(arg)],\n        };\n    }\n    if (arg.type === \"argument\") {\n        return arg;\n    }\n    return { type: \"argument\", openMark, closeMark, content: [arg] };\n}\n\nfunction normalizeArgumentsList(\n    args?: CoercibleArgument | CoercibleArgument[],\n    openMark = \"{\",\n    closeMark = \"}\"\n): Ast.Argument[] {\n    if (args == null) {\n        return [];\n    }\n    if (Array.isArray(args)) {\n        return args.map((arg) => normalizeArgument(arg, openMark, closeMark));\n    }\n    return [normalizeArgument(args, openMark, closeMark)];\n}\n\ntype BracesPair = { openMark: string; closeMark: string };\nconst BRACES_MAP: Record<string, BracesPair> = {\n    \"*\": { openMark: \"\", closeMark: \"\" },\n    \"{\": { openMark: \"{\", closeMark: \"}\" },\n    \"[\": { openMark: \"[\", closeMark: \"]\" },\n    \"(\": { openMark: \"(\", closeMark: \")\" },\n    \"<\": { openMark: \"<\", closeMark: \">\" },\n};\nconst CLOSE_BRACES = new Set(\n    Object.values(BRACES_MAP)\n        .map((x) => x.closeMark)\n        .filter((x) => x)\n);\n\n/**\n * Turn a braces signature into an array of braces.\n */\nfunction bracesToOpenAndCloseMarks(braces: string): BracesPair[] {\n    const ret: BracesPair[] = [];\n\n    for (const char of braces.split(\"\")) {\n        if (CLOSE_BRACES.has(char)) {\n            continue;\n        }\n        const braces = BRACES_MAP[char];\n        if (braces == null) {\n            throw new Error(`Unknown open/close mark type \"${char}\"`);\n        }\n        braces;\n        ret.push(braces);\n    }\n\n    return ret;\n}\n\n/**\n * Create an Argument list. `special.braces` can optionally specify\n * the signature of the open/close marks that each argument uses. For example\n * ```\n * args([\"a\", \"b\"], { braces: \"[]{}\" });\n * ```\n * will result in arguments `[a]{b}`. Valid braces are `*`, `[`, `{`, `(`, and `<`.\n *\n * `null` may be passed as the value of an empty optional argument. If `null` is passed,\n * the `openBrace` and `closeBrace` of the argument will be set to empty strings and the\n * contents will be set to an empty array. For example,\n * ```\n * args([null, \"b\"], { braces: \"[]{}\" });\n * ```\n * will produce the same structure as if the the first \"optional argument\" were omitted in regular parsing.\n */\nexport function args(\n    args: CoercibleArgument | CoercibleArgument[],\n    special?: ArgumentsSpecialOptions\n): Ast.Argument[] {\n    if (!Array.isArray(args)) {\n        args = [args];\n    }\n    if (special?.braces) {\n        const braces = bracesToOpenAndCloseMarks(special.braces);\n        if (braces.length !== args.length) {\n            throw new Error(\n                `There is a difference between the number of supplied braces and the number of supplied arguments. ${args.length} supplied with braces signature ${special.braces}`\n            );\n        }\n        return args.map((arg, i) =>\n            normalizeArgument(arg, braces[i].openMark, braces[i].closeMark)\n        );\n    }\n\n    const openMark = special?.defaultOpenMark ?? \"{\";\n    const closeMark = special?.defaultCloseMark ?? \"}\";\n    return normalizeArgumentsList(args, openMark, closeMark);\n}\n\n/**\n * Create an Argument. `special.braces` can optionally specify\n * the signature of the open/close marks that each argument uses. For example\n * ```\n * arg(\"a\", { braces: \"[]\" });\n * ```\n * will result in arguments `[a]`. Valid braces are `*`, `[`, `{`, `<`, and `(`.\n *\n * `null` may be passed as the value of an empty optional argument. If `null` is passed,\n * the `openBrace` and `closeBrace` of the argument will be set to empty strings and the\n * contents will be set to an empty array. For example,\n * ```\n * args([null, \"b\"], { braces: \"[]{}\" });\n * ```\n * will produce the same structure as if the the first \"optional argument\" were omitted in regular parsing.\n */\nexport function arg(\n    args: CoercibleArgument | Ast.Node[],\n    special?: ArgumentSpecialOptions\n): Ast.Argument {\n    if (args == null) {\n        return { type: \"argument\", content: [], openMark: \"\", closeMark: \"\" };\n    }\n    if (typeof args === \"string\") {\n        args = s(args);\n    }\n    if (!Array.isArray(args) && args.type === \"argument\") {\n        return args;\n    }\n\n    let openMark = special?.openMark ?? \"{\";\n    let closeMark = special?.closeMark ?? \"}\";\n    if (special?.braces) {\n        const braces = bracesToOpenAndCloseMarks(special.braces);\n        if (braces[0]) {\n            openMark = braces[0].openMark;\n            closeMark = braces[0].closeMark;\n        }\n    }\n\n    if (!Array.isArray(args)) {\n        args = [args];\n    }\n\n    return { type: \"argument\", content: args, openMark, closeMark };\n}\n\n/**\n * Create a Macro with the given `name`. The macro\n * may be followed by any number of arguments.\n */\nexport function m(\n    name: string,\n    marcoArgs?: CoercibleArgument | CoercibleArgument[],\n    special?: MacroSpecialOptions\n): Ast.Macro {\n    const args = normalizeArgumentsList(marcoArgs);\n    const escapeToken = special?.escapeToken;\n    const ret: Ast.Macro = { type: \"macro\", content: name };\n\n    if (args.length > 0) {\n        ret.args = args;\n    }\n    if (escapeToken != null) {\n        ret.escapeToken = escapeToken;\n    }\n\n    return ret;\n}\n\n/**\n * Create a String node from `value`\n */\nexport function s(value: string | Ast.String): Ast.String {\n    if (typeof value === \"string\") {\n        return { type: \"string\", content: value };\n    }\n    return value;\n}\n\n/**\n * Create an Environment node.\n */\nexport function env(\n    name: string,\n    body: CoercibleNode | CoercibleNode[],\n    envArgs?: CoercibleArgument | CoercibleArgument[],\n    special?: unknown\n): Ast.Environment {\n    if (!Array.isArray(body)) {\n        body = [body];\n    }\n    const args = normalizeArgumentsList(envArgs, \"[\", \"]\");\n    const ret: Ast.Environment = {\n        type: \"environment\",\n        env: name,\n        content: body.map(normalizeNode),\n    };\n    if (args.length > 0) {\n        ret.args = args;\n    }\n\n    return ret;\n}\n\n/**\n * Whitespace node.\n */\nexport const SP: Ast.Whitespace = { type: \"whitespace\" };\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\n/**\n * Scan `nodes` looking for the first occurrence of `token`.\n * If `options.onlySkipWhitespaceAndComments==true`, then the scan\n * will only skip whitespace/comment nodes.\n */\nexport function scan(\n    nodes: (Ast.Node | Ast.Argument)[],\n    token: string | Ast.Node | Ast.Argument,\n    options?: {\n        /**\n         * Index to start scanning.\n         */\n        startIndex?: number;\n        /**\n         * If `true`, whitespace and comments will be skilled but any other\n         * node that doesn't match `token` will cause the scan to terminate.\n         */\n        onlySkipWhitespaceAndComments?: boolean;\n        /**\n         * If `true`, will look inside `Ast.String` nodes to see if the string contents\n         * contain `token`.\n         */\n        allowSubstringMatches?: boolean;\n    }\n): number | null {\n    const { startIndex, onlySkipWhitespaceAndComments, allowSubstringMatches } =\n        options || {};\n    if (typeof token === \"string\") {\n        token = { type: \"string\", content: token } as Ast.String;\n    }\n\n    for (let i = startIndex || 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (node.type === token.type) {\n            switch (node.type) {\n                case \"comment\":\n                case \"displaymath\":\n                case \"inlinemath\":\n                case \"root\":\n                case \"parbreak\":\n                case \"whitespace\":\n                case \"verb\":\n                case \"verbatim\":\n                case \"group\":\n                    return i;\n                case \"macro\":\n                    if (node.content === (token as Ast.Macro).content) {\n                        return i;\n                    }\n                    break;\n                case \"environment\":\n                case \"mathenv\":\n                    if (\n                        printRaw(node.env) ===\n                        printRaw((token as Ast.Environment).env)\n                    ) {\n                        return i;\n                    }\n                    break;\n                case \"string\":\n                    if (node.content === (token as Ast.String).content) {\n                        return i;\n                    }\n                    if (\n                        allowSubstringMatches &&\n                        node.content.indexOf((token as Ast.String).content) >= 0\n                    ) {\n                        return i;\n                    }\n                    break;\n            }\n        }\n        if (\n            onlySkipWhitespaceAndComments &&\n            !match.whitespace(node) &&\n            !match.comment(node)\n        ) {\n            return null;\n        }\n    }\n\n    return null;\n}\n", "import Trie from \"trie-prefix-tree\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\nexport { Trie };\n\n/**\n * Efficiently search for a large number of strings using a prefix-tree.\n * The longest match is returned.\n *\n * @param options.startIndex the index to start scanning at. Defaults to 0.\n * @param options.matchSubstrings whether to allow matching only part of a substring.\n * @param options.assumeOneCharStrings assume that all strings are one character long (for example, like they are in math mode)\n */\nexport function prefixMatch(\n    nodes: Ast.Node[],\n    prefixes: string | string[] | ReturnType<typeof Trie>,\n    options?: {\n        startIndex?: number;\n        matchSubstrings?: boolean;\n        assumeOneCharStrings?: boolean;\n    }\n): {\n    match: string;\n    endNodeIndex: number;\n    endNodePartialMatch: string | null;\n} | null {\n    const {\n        startIndex = 0,\n        matchSubstrings = false,\n        assumeOneCharStrings = false,\n    } = options || {};\n\n    if (typeof prefixes === \"string\") {\n        prefixes = [prefixes];\n    }\n    if (Array.isArray(prefixes)) {\n        prefixes = Trie(prefixes);\n    }\n    const prefixTree = prefixes;\n\n    const history = {\n        lastPrefix: \"\",\n        lastWord: \"\",\n        index: startIndex,\n        partialMatch: \"\",\n    };\n\n    /**\n     * Try to match the next character. If it matches,\n     * record it properly in the `history` object.\n     */\n    function tryToMatchNextChar(char: string, index: number): boolean {\n        let ret = false;\n        if (prefixTree.isPrefix(history.lastPrefix + char)) {\n            history.lastPrefix += char;\n            history.index = index;\n            ret = true;\n        }\n        if (prefixTree.hasWord(history.lastPrefix)) {\n            history.lastWord = history.lastPrefix;\n        }\n        return ret;\n    }\n\n    // Loop through the nodes looking for the longest prefix match\n    for (let i = 0; startIndex + i < nodes.length; i++) {\n        const node = nodes[startIndex + i];\n        if (!match.string(node)) {\n            break;\n        }\n        if (assumeOneCharStrings && node.content.length !== 1) {\n            break;\n        }\n        if (matchSubstrings) {\n            // We need to test letter-by-letter for substring matches\n            let fullMatch = true;\n            history.partialMatch = \"\";\n            for (let j = 0; j < node.content.length; j++) {\n                const char = node.content[j];\n                if (tryToMatchNextChar(char, startIndex + i)) {\n                    history.partialMatch += char;\n                } else {\n                    fullMatch = false;\n                    break;\n                }\n            }\n            if (fullMatch) {\n                history.partialMatch = \"\";\n            } else {\n                break;\n            }\n        } else {\n            if (!tryToMatchNextChar(node.content, startIndex + i)) {\n                break;\n            }\n        }\n    }\n\n    return history.lastWord\n        ? {\n              match: history.lastWord,\n              endNodeIndex: history.index,\n              endNodePartialMatch: history.partialMatch\n                  ? history.partialMatch\n                  : null,\n          }\n        : null;\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\n\n/**\n * Updates the `._renderInfo` property on a node to include\n * whatever has been supplied to `renderInfo`. If `renderInfo`\n * is null, no update is performed.\n *\n * *This operation mutates `node`*\n */\nexport function updateRenderInfo(\n    node: Ast.Node,\n    renderInfo: object | null | undefined\n) {\n    if (renderInfo != null) {\n        node._renderInfo = { ...(node._renderInfo || {}), ...renderInfo };\n    }\n    return node;\n}\n\n/**\n * Removes any `_renderInfo` and `position` tags present in the AST. This\n * operation is _destructive_.\n */\nexport function trimRenderInfo<T extends Ast.Ast>(ast: T) {\n    visit(ast, (node) => {\n        delete node._renderInfo;\n        delete node.position;\n    });\n    return ast;\n}\n\n// NOTE: The docstring comment must be the last item in the index.ts file!\n/**\n * ## What is this?\n *\n * Functions to help modify the `_renderInfo` of a `unified-latex` Abstract Syntax Tree (AST).\n *\n * ## When should I use this?\n *\n * If you want to compare the structure of an AST without position information or extra information\n * that is kept for pretty-printing, these functions can be used to remove/modify the `_renderInfo`\n * of an `Ast.Node`.\n */\n", "import {\n    ArgSpecAst as ArgSpec,\n    parse as parseArgspec,\n} from \"@unified-latex/unified-latex-util-argspec\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { arg } from \"@unified-latex/unified-latex-builder\";\nimport { gobbleSingleArgument } from \"./gobble-single-argument\";\nimport { ArgumentParser } from \"@unified-latex/unified-latex-types\";\n\n/**\n * Gobbles an argument of whose type is specified\n * by `argSpec` starting at the position `startPos`. If an argument couldn't be found,\n * `argument` will be `null`.\n */\nexport function gobbleArguments(\n    nodes: Ast.Node[],\n    argSpec: string | ArgSpec.Node[] | ArgumentParser,\n    startPos = 0\n): {\n    args: Ast.Argument[];\n    nodesRemoved: number;\n} {\n    if (typeof argSpec === \"function\") {\n        return argSpec(nodes, startPos);\n    }\n\n    if (typeof argSpec === \"string\") {\n        argSpec = parseArgspec(argSpec);\n    }\n\n    const args: Ast.Argument[] = [];\n    let nodesRemoved = 0;\n    for (const spec of argSpec) {\n        const { argument, nodesRemoved: removed } = gobbleSingleArgument(\n            nodes,\n            spec,\n            startPos\n        );\n        if (argument) {\n            args.push(argument);\n            nodesRemoved += removed;\n        } else {\n            args.push(arg([], { openMark: \"\", closeMark: \"\" }));\n        }\n    }\n\n    return { args, nodesRemoved };\n}\n", "import { ArgSpecAst as ArgSpec } from \"@unified-latex/unified-latex-util-argspec\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { scan } from \"@unified-latex/unified-latex-util-scan\";\nimport { arg } from \"@unified-latex/unified-latex-builder\";\n\n/**\n * Gobbles an argument of whose type is specified\n * by `argSpec` starting at the position `startPos`. If an argument couldn't be found,\n * `argument` will be `null`.\n */\nexport function gobbleSingleArgument(\n    nodes: Ast.Node[],\n    argSpec: ArgSpec.Node,\n    startPos = 0\n): {\n    argument: Ast.Argument | null;\n    nodesRemoved: number;\n} {\n    if (typeof argSpec === \"string\" || !argSpec.type) {\n        throw new Error(\n            `argSpec must be an already-parsed argument specification, not \"${JSON.stringify(\n                argSpec\n            )}\"`\n        );\n    }\n\n    let argument: Ast.Argument | null = null;\n\n    let currPos = startPos;\n\n    // Gobble whitespace from `currPos` onward, updating `currPos`.\n    // If `argSpec` specifies leading whitespace is not allowed,\n    // this function does nothing.\n    const gobbleWhitespace = (argSpec as ArgSpec.LeadingWhitespace)\n        .noLeadingWhitespace\n        ? () => {}\n        : () => {\n              while (currPos < nodes.length) {\n                  if (!match.whitespace(nodes[currPos])) {\n                      break;\n                  }\n                  currPos++;\n              }\n          };\n\n    const openMark: string = (argSpec as any).openBrace || \"\";\n    const closeMark: string = (argSpec as any).closeBrace || \"\";\n\n    // Only mandatory arguments can be wrapped in {...}.\n    // Since we already parse such things as groups, we need to\n    // check the open and closing symbols to see if we allow for\n    // groups to be accepted as arguments\n    const acceptGroup =\n        (argSpec.type === \"mandatory\" || argSpec.type === \"optional\") &&\n        openMark === \"{\" &&\n        closeMark === \"}\";\n\n    // Find the position of the open brace and the closing brace.\n    // The position(s) are null if the brace isn't found.\n    function findBracePositions(): [number | null, number | null] {\n        let openMarkPos: number | null = null;\n        if (openMark) {\n            openMarkPos = nodes.findIndex(\n                (node, i) => i >= currPos && match.string(node, openMark)\n            );\n            if (openMarkPos < currPos) {\n                openMarkPos = null;\n            }\n        }\n        let closeMarkPos: number | null = null;\n        if (openMarkPos != null) {\n            closeMarkPos = nodes.findIndex(\n                (node, i) =>\n                    i >= (openMarkPos as number) + 1 &&\n                    match.string(node, closeMark)\n            );\n            if (closeMarkPos < openMarkPos + 1) {\n                closeMarkPos = null;\n            }\n        }\n        return [openMarkPos, closeMarkPos];\n    }\n\n    // Do the actual matching\n    gobbleWhitespace();\n    const currNode = nodes[currPos];\n    if (\n        currNode == null ||\n        match.comment(currNode) ||\n        match.parbreak(currNode)\n    ) {\n        return { argument, nodesRemoved: 0 };\n    }\n\n    switch (argSpec.type) {\n        case \"mandatory\":\n            if (acceptGroup) {\n                // We have already gobbled whitespace, so at this point, `currNode`\n                // is either an openMark or we don't have an optional argument.\n                let content: Ast.Node[] = [currNode];\n                if (match.group(currNode)) {\n                    // Unwrap a group if there is one.\n                    content = currNode.content;\n                }\n                argument = arg(content, {\n                    openMark,\n                    closeMark,\n                });\n                currPos++;\n                break;\n            }\n        // NOTE: Fallthrough is on purpose.\n        // Matching a mandatory argument and an optional argument is the same for our purposes\n        // because we're not going to fail to parse because of a missing argument.\n        case \"optional\":\n            // It is possible that an optional argument accepts a group if its open/close braces are `{}`\n            if (acceptGroup && match.group(currNode)) {\n                argument = arg(currNode.content, {\n                    openMark,\n                    closeMark,\n                });\n                currPos++;\n                break;\n            }\n            if (match.string(currNode, openMark)) {\n                // If we're here, we have custom braces to match\n                const [openMarkPos, closeMarkPos] = findBracePositions();\n                if (openMarkPos != null && closeMarkPos != null) {\n                    argument = arg(nodes.slice(openMarkPos + 1, closeMarkPos), {\n                        openMark,\n                        closeMark,\n                    });\n                    currPos = closeMarkPos + 1;\n                    break;\n                }\n            }\n            break;\n        case \"optionalStar\":\n        case \"optionalToken\":\n            if (\n                match.string(\n                    currNode,\n                    argSpec.type === \"optionalStar\" ? \"*\" : argSpec.token\n                )\n            ) {\n                argument = arg([currNode], { openMark: \"\", closeMark: \"\" });\n                currPos++;\n                break;\n            }\n            break;\n        case \"until\": {\n            if (argSpec.stopTokens.length > 1) {\n                console.warn(\n                    `\"until\" matches with multi-token stop conditions are not yet implemented`\n                );\n                break;\n            }\n            const rawToken = argSpec.stopTokens[0];\n            const stopToken: Ast.String | Ast.Whitespace =\n                rawToken === \" \"\n                    ? { type: \"whitespace\" }\n                    : { type: \"string\", content: argSpec.stopTokens[0] };\n            let matchPos = scan(nodes, stopToken, {\n                startIndex: startPos,\n                allowSubstringMatches: true,\n            });\n            if (\n                matchPos != null &&\n                partialStringMatch(nodes[matchPos], stopToken)\n            ) {\n                console.warn(\n                    `\"until\" arguments that stop at non-punctuation symbols is not yet implemented`\n                );\n                break;\n            }\n            // If the corresponding token is not found, eat nothing;\n            if (matchPos == null) {\n                break;\n            }\n            argument = arg(nodes.slice(startPos, matchPos), {\n                openMark: \"\",\n                closeMark: rawToken,\n            });\n            currPos = matchPos;\n            if (currPos < nodes.length) {\n                currPos++;\n            }\n            break;\n        }\n        default:\n            console.warn(\n                `Don't know how to find an argument of argspec type \"${argSpec.type}\"`\n            );\n    }\n\n    // `currPos` is has already stepped past any whitespace. However,\n    // if we did not consume an argument, we don't want to consume the whitespace.\n    const nodesRemoved = argument ? currPos - startPos : 0;\n    nodes.splice(startPos, nodesRemoved);\n    return { argument, nodesRemoved };\n}\n\n/**\n * Returns whether the presumed match \"node\" contains \"token\" as a strict\n * substring.\n */\nfunction partialStringMatch(node: Ast.Node, token: Ast.Node): boolean {\n    return (\n        match.anyString(node) &&\n        match.anyString(token) &&\n        node.content.length > token.content.length\n    );\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { MacroInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\nimport { gobbleArguments } from \"./gobble-arguments\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\n\n/**\n * Search (in a right-associative way) through the array for instances of\n * `macros` and attach arguments to the macro. Argument signatures are\n * specified by `macros[].signature`.\n *\n * Info stored in `macros[].renderInfo` will be attached to the node\n * with attribute `_renderInfo`.\n */\nexport function attachMacroArgsInArray(\n    nodes: Ast.Node[],\n    macros: MacroInfoRecord\n): void {\n    // Some preliminaries that are only used if `ast` is an array.\n    let currIndex: number;\n\n    /**\n     * Determine whether `node` matches one of the macros in `macros`.\n     * Care is taken when matching because not all macros have\n     * `\\` as their escape token.\n     */\n    const isRelevantMacro = match.createMacroMatcher(macros);\n\n    function gobbleUntilMacro() {\n        // Step backwards until we find the required macro\n        while (currIndex >= 0 && !isRelevantMacro(nodes[currIndex])) {\n            currIndex--;\n        }\n    }\n\n    // Search for an occurrence of any of the macros `macroName` and its arguments.\n    // Some macros are right-associative, so we should start searching from\n    // the right\n    currIndex = nodes.length - 1;\n    while (currIndex >= 0) {\n        gobbleUntilMacro();\n        if (currIndex < 0) {\n            // We didn't find an occurrence of the macro\n            return;\n        }\n\n        // Store the currIndex, which is where the macro is. Start searching\n        // for its arguments at the next index.\n        const macroIndex = currIndex;\n        const macro = nodes[macroIndex] as Ast.Macro;\n        const macroName = macro.content;\n        const macroInfo = macros[macroName];\n\n        // Add `._renderInfo` if we have any\n        updateRenderInfo(macro, macroInfo.renderInfo);\n\n        const signatureOrParser = macroInfo.argumentParser || macroInfo.signature\n\n        // If the macro has no signature, it shouldn't consume any arguments. Just move along.\n        // Note: It is important that this happens *after* `updateRenderInfo` is called, since\n        // we still want to update the render info even if there are no args.\n        if (signatureOrParser == null) {\n            currIndex--;\n            continue;\n        }\n\n        // We don't want to search for macro arguments if we already\n        // found them. If the macro has arguments, we assume that\n        // they've already been attached\n        if (macro.args != null) {\n            currIndex = macroIndex - 1;\n            continue;\n        }\n\n        // `currIndex` is the position of the macro. We want to start\n        // looking for the arguments right after the macro\n        currIndex++;\n        const { args } = gobbleArguments(nodes, signatureOrParser, currIndex);\n        macro.args = args;\n        // After we've gobbled the arguments, set\n        // ourselves one space before the macro so we can continue.\n        currIndex = macroIndex - 1;\n    }\n}\n\n/**\n * Recursively search for and attach the arguments for a\n * particular macro to its AST node. `macros` should\n * contain a `signature` property which specifies the arguments\n * signature in xparse syntax.\n */\nexport function attachMacroArgs(tree: Ast.Ast, macros: MacroInfoRecord) {\n    visit(\n        tree,\n        (nodes) => {\n            attachMacroArgsInArray(nodes, macros);\n        },\n        { includeArrays: true, test: Array.isArray }\n    );\n}\n", "import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { MacroInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { attachMacroArgsInArray } from \"./attach-arguments\";\n\ntype PluginOptions = { macros: MacroInfoRecord } | undefined;\n\n/**\n * Unified plugin to attach macro arguments to the macros specified via the `macros`\n * option.\n *\n * @param macros An object whose keys are macro names and values contains information about the macro and its argument signature.\n */\nexport const unifiedLatexAttachMacroArguments: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexAttachMacroArguments(options) {\n    return (tree) => {\n        const { macros = {} } = options || {};\n        if (Object.keys(macros).length === 0) {\n            console.warn(\n                \"Attempting to attach macro arguments but no macros are specified.\"\n            );\n        }\n        visit(\n            tree,\n            (nodes) => {\n                attachMacroArgsInArray(nodes, macros);\n            },\n            { includeArrays: true, test: Array.isArray }\n        );\n    };\n};\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Returns the content of `args` for a macro or environment as an array. If an argument\n * was omitted (e.g., because it was an optional arg that wasn't included), then `null` is returned.\n */\nexport function getArgsContent(\n    node: Ast.Macro | Ast.Environment\n): (Ast.Node[] | null)[] {\n    if (!Array.isArray(node.args)) {\n        return [];\n    }\n\n    return node.args.map((arg) => {\n        if (arg.openMark === \"\" && arg.content.length === 0) {\n            return null;\n        }\n        return arg.content;\n    });\n}\n\n/**\n * Returns the content of `args` for a macro or environment as an object whose keys are the \"names\"\n * of each argument. These names of the arguments must be specified in the `_renderInfo` prop. If `_renderInfo`\n * does not contain a `namedArguments` array, then an empty object will be returned.\n *\n * @namedArgumentsFallback - If `_renderInfo.namedArguments` is not provided, `namedArgumentsFallback` is ued.\n */\nexport function getNamedArgsContent(\n    node: Ast.Macro | Ast.Environment,\n    namedArgumentsFallback: readonly (string | null)[] = []\n): Record<string, Ast.Node[] | null> {\n    const names = node._renderInfo?.namedArguments || namedArgumentsFallback;\n\n    if (\n        !Array.isArray(node.args) ||\n        !Array.isArray(names) ||\n        names.length === 0\n    ) {\n        return {};\n    }\n    const ret: Record<string, Ast.Node[] | null> = {};\n\n    node.args.forEach((arg, i) => {\n        const name = names[i];\n        if (name == null) {\n            // If a null name was given, it shouldn't be listed as a named argument.\n            return;\n        }\n        let val: Ast.Node[] | null = arg.content;\n        if (arg.openMark === \"\" && arg.content.length === 0) {\n            val = null;\n        }\n        ret[name] = val;\n    });\n\n    return ret;\n}\n", "import { arg } from \"@unified-latex/unified-latex-builder\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    ArgSpecAst as ArgSpec,\n    parse as parseArgspec,\n} from \"@unified-latex/unified-latex-util-argspec\";\nimport { ArgumentParser } from \"@unified-latex/unified-latex-types\";\nimport { gobbleSingleArgument } from \"@unified-latex/unified-latex-util-arguments\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { scan } from \"@unified-latex/unified-latex-util-scan\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\nconst OPTIONAL_ARGUMENT_ARG_SPEC = parseArgspec(\"o\")[0];\n\nfunction blankArg() {\n    return arg([], { openMark: \"\", closeMark: \"\" });\n}\n\n/**\n * Find the arguments of a tikz command. Many tikz commands accept either\n * the a group as their only argument, or they scan their arguments until the first\n * `;` is found.\n *\n * This behavior cannot be achieved via a standard xparse spec.\n */\nexport const tikzCommandArgumentParser: ArgumentParser = (nodes, startPos) => {\n    const origStartPos = startPos;\n    let pos = startPos;\n    let nodesRemoved = 0;\n\n    const cursorPosAfterAnimations = eatAllAnimationSpecs(nodes, pos);\n    let animationArg = blankArg();\n    if (cursorPosAfterAnimations !== pos) {\n        const argContent = nodes.splice(pos, cursorPosAfterAnimations - pos);\n        trim(argContent);\n        animationArg = arg(argContent, {\n            openMark: \" \",\n            closeMark: \" \",\n        });\n    }\n    nodesRemoved += cursorPosAfterAnimations - pos;\n\n    const {\n        argument: _optionalArgument,\n        nodesRemoved: optionalArgumentNodesRemoved,\n    } = gobbleSingleArgument(nodes, OPTIONAL_ARGUMENT_ARG_SPEC, pos);\n    nodesRemoved += optionalArgumentNodesRemoved;\n    const optionalArg = _optionalArgument || blankArg();\n\n    // Eat whitespace\n    while (match.whitespace(nodes[pos])) {\n        pos++;\n    }\n    const firstNode = nodes[pos];\n\n    // If we're past the end of the array, give up.\n    if (!firstNode) {\n        return {\n            args: [animationArg, optionalArg, blankArg()],\n            nodesRemoved: 0,\n        };\n    }\n\n    // If we're a group, grab the contents and call it good.\n    if (match.group(firstNode)) {\n        const args = [animationArg, optionalArg, arg(firstNode.content)];\n        nodes.splice(origStartPos, pos - origStartPos + 1);\n        return { args, nodesRemoved: pos - origStartPos + 1 + nodesRemoved };\n    }\n\n    // No group, so scan for a semicolon.\n    const semicolonPosition = scan(nodes, \";\", { startIndex: pos });\n    if (semicolonPosition != null) {\n        const argNodes = nodes.splice(\n            origStartPos,\n            semicolonPosition - origStartPos + 1\n        );\n        trim(argNodes);\n        const args = [animationArg, optionalArg, arg(argNodes)];\n        return {\n            args,\n            nodesRemoved: origStartPos - semicolonPosition + 1 + nodesRemoved,\n        };\n    }\n\n    // If there was no semicolon, give up.\n    return {\n        args: [animationArg, optionalArg, blankArg()],\n        nodesRemoved: 0,\n    };\n};\n\n/**\n * Find the next index after all animation specs. If no animation specs are present,\n * return `startPos`.\n *\n * An animation spec looks like\n * ```\n * :rotate = { 0s=\"0\", 2s=\"90\", begin on=click }\n * ```\n * Any number can be listed. They start with a colon and have an equals sign followed by a group.\n */\nfunction eatAllAnimationSpecs(nodes: Ast.Node[], startPos: number): number {\n    const colonPos = scan(nodes, \":\", {\n        startIndex: startPos,\n        allowSubstringMatches: true,\n        onlySkipWhitespaceAndComments: true,\n    });\n\n    if (!colonPos) {\n        return startPos;\n    }\n\n    let lastMatchPos = startPos;\n    let i = colonPos + 1;\n    for (; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (match.string(node, \"[\")) {\n            // XXX As per the tikz manual, we stop scanning if we find an open square brace.\n            break;\n        }\n        if (match.string(node, \"=\")) {\n            i++;\n            // Look for a group next\n            while (match.whitespace(nodes[i]) || match.comment(nodes[i])) {\n                i++;\n            }\n            if (!match.group(nodes[i])) {\n                break;\n            }\n            // We have a match!\n            lastMatchPos = i + 1;\n\n            // Start the process again\n            const colonPos = scan(nodes, \":\", {\n                startIndex: lastMatchPos,\n                allowSubstringMatches: true,\n                onlySkipWhitespaceAndComments: true,\n            });\n            if (colonPos == null) {\n                break;\n            }\n            i = colonPos + 1;\n        }\n    }\n\n    return lastMatchPos;\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as TikzSpec from \"./types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { decorateArrayForPegjs } from \"@unified-latex/unified-latex-util-pegjs\";\nimport { TikzPegParser } from \"@unified-latex/unified-latex-util-pegjs\";\n\ntype TikzParseOptions = {\n    startRule?: \"path_spec\" | \"foreach_body\";\n};\n\nfunction createMatchers() {\n    return {\n        isChar: match.string,\n        isTerminal: (node: any) => match.string(node, \";\"),\n        isOperation: (node: any) =>\n            match.anyString(node) && node.content.match(/[a-zA-Z]/),\n        isWhitespace: (node: any) =>\n            match.whitespace(node) || match.parbreak(node),\n        isComment: match.comment,\n        isGroup: match.group,\n        isMacro: match.macro,\n        isAnyMacro: match.anyMacro,\n    };\n}\n\nconst matchers = createMatchers();\n\n/**\n * Parse the contents of the `\\systeme{...}` macro\n */\nexport function parse<Options extends TikzParseOptions>(\n    ast: Ast.Node[],\n    options?: Options\n): Options extends { startRule: infer R }\n    ? R extends \"path_spec\"\n        ? TikzSpec.PathSpec\n        : TikzSpec.ForeachBody\n    : TikzSpec.PathSpec {\n    const { startRule = \"path_spec\" } = options || {};\n    if (!Array.isArray(ast)) {\n        throw new Error(\"You must pass an array of nodes\");\n    }\n    // We need to at functions to `nodes` so that it imitates\n    // a Javascript string. Because we're mutating, make a copy first\n    ast = decorateArrayForPegjs([...ast]);\n    // matchers are passed in via the second argument (the `options` argument)\n    // so they are available from within the Pegjs grammar.\n    return TikzPegParser.parse(ast, {\n        ...matchers,\n        startRule,\n    });\n}\n", "import { PgfkeysPegParser } from \"@unified-latex/unified-latex-util-pegjs\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { decorateArrayForPegjs } from \"@unified-latex/unified-latex-util-pegjs\";\n\n// The types returned by the grammar\n\nexport type Item = {\n    itemParts?: Ast.Node[][];\n    trailingComment: Ast.Comment | null;\n    trailingComma?: boolean;\n    leadingParbreak?: boolean;\n};\n\nexport function createMatchers() {\n    return {\n        isChar: (node: Ast.Node, char: string) => match.string(node, char),\n        isComma: (node: Ast.Node) => match.string(node, \",\"),\n        isEquals: (node: Ast.Node) => match.string(node, \"=\"),\n        isWhitespace: (node: Ast.Node) => match.whitespace(node),\n        isParbreak: (node: Ast.Node) => match.parbreak(node),\n        isSameLineComment: (node: Ast.Node) =>\n            match.comment(node) && node.sameline,\n        isOwnLineComment: (node: Ast.Node) =>\n            match.comment(node) && !node.sameline,\n    };\n}\n\n/**\n * Parse the arguments of a Pgfkeys macro. The `ast`\n * is expected to be a comma separated list of `Item`s.\n * Each item can have 0 or more item parts, which are separated\n * by \"=\". If `itemPart` is undefined,\n *\n * If `options.allowParenGroups === true`, then commas that occur inside groups of parenthesis\n * will not be parsed as separators. This is useful for parsing tikz `\\foreach` loops.\n */\nexport function parsePgfkeys(\n    ast: Ast.Node[],\n    options?: { allowParenGroups: boolean }\n): Item[] {\n    if (!Array.isArray(ast)) {\n        throw new Error(\"You must pass an array of nodes\");\n    }\n    const { allowParenGroups = false } = options || {};\n    // We need to at functions to `nodes` so that it imitates\n    // a Javascript string. Because we're mutating, make a copy first\n    ast = decorateArrayForPegjs([...ast]);\n    // matchers are passed in via the second argument (the `options` argument)\n    // so they are available from within the Pegjs grammar.\n    return PgfkeysPegParser.parse(ast, {\n        ...createMatchers(),\n        allowParenGroups,\n    }) as Item[];\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { parsePgfkeys } from \"./pgfkeys-parser\";\n\n/**\n * Parse `arg` as pgfkeys and return a JavaScript object with the results.\n * The keys will be normalized to strings and the values will be arrays of nodes.\n */\nexport function pgfkeysArgToObject(\n    arg: Ast.Argument | Ast.Node[]\n): Record<string, Ast.Node[]> {\n    function parseFront(nodes: Ast.Node[]): string {\n        return printRaw(nodes);\n    }\n    function parseBack(nodes: Ast.Node[] | undefined): Ast.Node[] {\n        if (!nodes) {\n            return [];\n        }\n        // If the only element is a group, we unwrap it\n        if (nodes.length === 1 && match.group(nodes[0])) {\n            return nodes[0].content;\n        }\n        return nodes;\n    }\n\n    let nodeList: Ast.Node[];\n    if (match.argument(arg)) {\n        nodeList = arg.content;\n    } else {\n        nodeList = arg;\n    }\n    const parsedArgs = parsePgfkeys(nodeList);\n    return Object.fromEntries(\n        parsedArgs\n            .filter((part) => part.itemParts)\n            .map((part) => [\n                parseFront(part.itemParts![0]),\n                parseBack(part.itemParts![1]),\n            ])\n    );\n}\n", "import { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    hardline,\n    join,\n    breakParent,\n    line,\n    group,\n    indent,\n    softline,\n} from \"./common\";\nimport {\n    linebreak,\n    printRaw,\n} from \"@unified-latex/unified-latex-util-print-raw\";\nimport { parsePgfkeys } from \"@unified-latex/unified-latex-util-pgfkeys\";\n\n/**\n * Format a sequence of Pgfkeys key-value pairs. `nodes` will be parsed\n * by a grammar defining Pgfkeys\n */\nexport function printArgumentPgfkeys(\n    nodes: Ast.Node[],\n    options: {\n        openMark: string;\n        closeMark: string;\n        leadingComment?: Ast.Comment | null | undefined;\n        allowParenGroups?: boolean;\n    }\n): Doc {\n    const { allowParenGroups = false } = options;\n    const parsed = parsePgfkeys(nodes, { allowParenGroups });\n\n    const content: Doc[] = [];\n    for (const part of parsed) {\n        const isLastItem = part === parsed[parsed.length - 1];\n\n        if (part.itemParts) {\n            // parts are printed using `printRaw`, `hardline` is used in place\n            // of \"\\n\"\n            const parts = part.itemParts.map((node) =>\n                printRaw(node, { asArray: true }).map((token) =>\n                    token === linebreak ? hardline : token\n                )\n            );\n            const row = join(\"=\", parts);\n            content.push(row);\n            if (part.trailingComma) {\n                content.push(\",\");\n            }\n        }\n        if (part.trailingComment) {\n            const leadingContent: Doc[] = part.itemParts ? [\" \"] : [];\n            if (part.leadingParbreak) {\n                // We preserve parbreaks before comments, so if we have\n                // one, insert an extra hardline\n                leadingContent.push(hardline);\n            }\n\n            content.push(\n                ...leadingContent,\n                // We're carefully and manually controlling the newlines,\n                // so print the comment directly without any newlines\n                \"%\",\n                part.trailingComment.content,\n                breakParent\n            );\n        }\n\n        if (!isLastItem) {\n            content.push(line);\n        }\n    }\n\n    let leadingComment: Doc[] = [\"\"];\n    if (options.leadingComment) {\n        if (options.leadingComment.leadingWhitespace) {\n            leadingComment.push(\" \");\n        }\n        leadingComment.push(\"%\" + options.leadingComment.content, breakParent);\n    }\n\n    return group([\n        options.openMark,\n        ...leadingComment,\n        // If there is no content, we don't want to push an extra `softline`.\n        // This matters because the braces group could still be broken by `leadingComment`\n        content.length > 0 ? indent([softline, ...content]) : \"\",\n        softline,\n        options.closeMark,\n    ]);\n}\n", "import type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport {\n    getNodeInfo,\n    formatDocArray,\n    hardline,\n    join,\n    ifBreak,\n    breakParent,\n    line,\n    group,\n    indent,\n    softline,\n    fill,\n} from \"./common\";\nimport {\n    printRaw,\n} from \"@unified-latex/unified-latex-util-print-raw\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\nimport {\n    parse as parseTikz,\n    PathSpec,\n    PathSpecNode,\n    printRaw as tikzPrintRaw,\n} from \"@unified-latex/unified-latex-ctan/package/tikz\";\nimport { printArgumentPgfkeys } from \"./print-argument-pgfkeys\";\n\nexport function printTikzArgument(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Argument;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    const content: Doc[] = [];\n    const nodes = [...node.content];\n    trim(nodes);\n    try {\n        const tikzAst = parseTikz(nodes);\n        if (tikzAst.content.length === 0) {\n            content.push(\";\");\n            return content;\n        }\n\n        const printer = new TikzArgumentPrinter(tikzAst, path, print);\n        return printer.toDoc();\n    } catch (e) {\n        console.warn(\"Encountered error when trying to parse tikz argument\", e);\n    }\n\n    content.push(\";\");\n\n    return content;\n}\n\n/**\n * Print a fragment of an AST to a `Doc`.\n */\nfunction printFragment(\n    fragment: Ast.Node | Ast.Argument,\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc\n): Doc {\n    const tmpKey = Symbol();\n    const currNode = path.getNode();\n    if (!currNode) {\n        throw new Error(\n            \"tried to print a fragment, but the current node is `null`\"\n        );\n    }\n    (currNode as any)[tmpKey] = fragment;\n    const ret = print(tmpKey);\n    delete (currNode as any)[tmpKey];\n    return ret;\n}\n\n/**\n * Turn an item in a tikz PathSpec into a Doc for printing.\n */\nfunction printTikzPathSpecNode(\n    node: PathSpecNode,\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc\n): Doc {\n    switch (node.type) {\n        case \"comment\":\n            return printFragment(node, path, print);\n        case \"unknown\":\n            // `\"unknown\"` nodes contain regular AST nodes as children which couldn't be identified by the parser\n            return printFragment(node.content, path, print);\n        case \"coordinate\":\n            return [printRaw(node.prefix), \"(\", printRaw(node.content), \")\"];\n        case \"line_to\":\n            return node.command;\n        case \"square_brace_group\":\n            return printOptionalArgs(node.content);\n        case \"operation\":\n            return node.content.content;\n        case \"svg_operation\": {\n            const comments = node.comments.map((n) =>\n                printTikzPathSpecNode(n, path, print)\n            );\n            const options = node.options ? printOptionalArgs(node.options) : [];\n            const rest: Doc[] = node.options\n                ? [group(indent([line, printRaw(node.content)]))]\n                : [\" \", printRaw(node.content)];\n            return [...comments, \"svg\", options, ...rest];\n        }\n        case \"curve_to\": {\n            const comments = node.comments.map((n) =>\n                printTikzPathSpecNode(n, path, print)\n            );\n            const printedControls =\n                node.controls.length > 1\n                    ? [\n                          printTikzPathSpecNode(node.controls[0], path, print),\n                          \" \",\n                          \"and\",\n                          line,\n                          printTikzPathSpecNode(node.controls[1]!, path, print),\n                      ]\n                    : [printTikzPathSpecNode(node.controls[0], path, print)];\n            return [\n                ...comments,\n                \"..\",\n                \" \",\n                group(\n                    indent([\"controls\", line, ...printedControls, \" \", \"..\"])\n                ),\n            ];\n        }\n        case \"animation\": {\n            const comments = node.comments.map((n) =>\n                printTikzPathSpecNode(n, path, print)\n            );\n\n            return [\n                ...comments,\n                \":\",\n                node.attribute,\n                \" \",\n                \"=\",\n                \" \",\n                group(\n                    indent([\n                        printArgumentPgfkeys(node.content, {\n                            openMark: \"{\",\n                            closeMark: \"}\",\n                        }),\n                    ])\n                ),\n            ];\n        }\n        case \"foreach\": {\n            const comments = node.comments.map((n) =>\n                printTikzPathSpecNode(n, path, print)\n            );\n            const variables = [...node.variables];\n            trim(variables);\n            const list =\n                node.list.type === \"macro\"\n                    ? printFragment(node.list, path, print)\n                    : printArgumentPgfkeys(node.list.content, {\n                          openMark: \"{\",\n                          closeMark: \"}\",\n                          allowParenGroups: true,\n                      });\n            const doc = [\n                ...comments,\n                printRaw(node.start),\n                \" \",\n                printRaw(variables),\n            ];\n            if (node.options) {\n                doc.push(\" \", indent(printOptionalArgs(node.options)));\n            }\n\n            // The list, e.g. `{1,2,...,9}`\n            doc.push(\" \", \"in\", \" \", group(indent(list)));\n            // The loop body\n            // XXX: if we are in a tikz node, whitespace doesn't matter. If we are in a regular\n            // part of the document, the loop body is whitespace-sensitive\n            const commandType = node.command.type;\n            switch (commandType) {\n                case \"foreach\":\n                    doc.push(\n                        indent([\n                            line,\n                            printTikzPathSpecNode(node.command, path, print),\n                        ])\n                    );\n                    break;\n                case \"macro\":\n                    doc.push(\n                        indent([line, printFragment(node.command, path, print)])\n                    );\n                    break;\n                case \"group\": {\n                    const groupContent = [...node.command.content];\n                    trim(groupContent);\n                    doc.push(\n                        \" \",\n                        indent(\n                            group([\n                                \"{\",\n                                indent([\n                                    softline,\n                                    ...groupContent.map((n) =>\n                                        printFragment(n, path, print)\n                                    ),\n                                ]),\n                                softline,\n                                \"}\",\n                            ])\n                        )\n                    );\n                    break;\n                }\n                default:\n                    const invalidType: void = commandType;\n                    console.warn(\n                        `Unhandled command type when printing \"foreach\": ${invalidType}`\n                    );\n            }\n\n            return indent(doc);\n        }\n    }\n    console.warn(\n        `Encountered unknown type when trying to print tikz PathSpec: \"${\n            (node as any).type\n        }\"`\n    );\n    return [];\n}\n\nfunction printOptionalArgs(nodes: Ast.Node[]): Doc {\n    return printArgumentPgfkeys(nodes, {\n        openMark: \"[\",\n        closeMark: \"]\",\n    });\n}\n\n/**\n * Utility to turn a Tikz PathSpec into a Prettier Doc.\n */\nclass TikzArgumentPrinter {\n    #path: PrettierTypes.AstPath;\n    #print: PrettierTypes.RecursivePrintFunc;\n    nodes: PathSpec[\"content\"];\n    constructor(\n        spec: PathSpec,\n        path: PrettierTypes.AstPath,\n        print: PrettierTypes.RecursivePrintFunc\n    ) {\n        this.#path = path;\n        this.#print = print;\n        this.nodes = [...spec.content];\n    }\n\n    nodeToDoc(node: PathSpecNode): Doc {\n        return printTikzPathSpecNode(node, this.#path, this.#print);\n    }\n\n    toDoc(): Doc {\n        const doc: Doc = [];\n        const startArg = this.eatOptionalArg();\n        if (startArg.optionalArg) {\n            doc.push(\n                ...startArg.comments.map((c) =>\n                    printFragment(c, this.#path, this.#print)\n                )\n            );\n            doc.push(printOptionalArgs(startArg.optionalArg.content));\n        }\n\n        const innerDoc: Doc = [];\n        doc.push(group([indent(innerDoc), \";\"]));\n        let cycle = -1;\n        while (this.nodes.length > 0) {\n            cycle++;\n            // If this is the first item being printed and the draw command has no optional\n            // argument, then we force the command to start printing on the same line.\n            const firstSep = cycle === 0 && !startArg.optionalArg ? \" \" : line;\n            const comingUp = this.peek();\n            switch (comingUp) {\n                case \"short_path\": {\n                    const [n0, n1, n2] = this.nodes.splice(0, 3);\n                    // A short path does not break\n                    innerDoc.push(\n                        firstSep,\n                        this.nodeToDoc(n0),\n                        \" \",\n                        this.nodeToDoc(n1),\n                        \" \",\n                        this.nodeToDoc(n2)\n                    );\n                    continue;\n                }\n                case \"long_path\": {\n                    // A long path consists of at least a node followed by a joiner\n                    const [n0, n1] = this.nodes.splice(0, 2);\n                    if (n1.type === \"operation\") {\n                        this.nodes.unshift(n1);\n                        innerDoc.push(\n                            firstSep,\n                            this.nodeToDoc(n0),\n                            \" \",\n                            this.eatOperation()\n                        );\n                    } else {\n                        innerDoc.push(\n                            firstSep,\n                            this.nodeToDoc(n0),\n                            \" \",\n                            this.nodeToDoc(n1)\n                        );\n                    }\n                    continue;\n                }\n                case \"node\":\n                    {\n                        const eatenNode = this.eatNode();\n                        if (eatenNode) {\n                            innerDoc.push(line, ...eatenNode);\n                            continue;\n                        }\n                        console.warn(\n                            \"Expected to print a tikz `node` PathSpec but couldn't find the text `node`\"\n                        );\n                    }\n                    continue;\n                case \"operation\":\n                    innerDoc.push(firstSep, this.eatOperation());\n                    continue;\n                case \"unknown\": {\n                    const node = this.nodes.shift()!;\n                    innerDoc.push(firstSep, this.nodeToDoc(node));\n                    continue;\n                }\n            }\n            this.nodes.shift();\n        }\n\n        return doc;\n    }\n\n    /**\n     * Look at the current node and the nodes that follow. Return what\n     * \"type\" is recognized.\n     */\n    peek() {\n        // A short path is two coordinates, joined by a line_to (with no coordinates/line_to's following).\n        // If there are comments intermixed, the short path is broken.\n        const [n0, n1, n2, n3] = [\n            this.nodes[0],\n            this.nodes[1],\n            this.nodes[2],\n            this.nodes[3],\n        ];\n        if (n0?.type === \"coordinate\" && isPathJoinOperation(n1)) {\n            if (\n                n2?.type === \"coordinate\" &&\n                !(n3?.type === \"coordinate\" || isPathJoinOperation(n3))\n            ) {\n                return \"short_path\";\n            }\n            return \"long_path\";\n        }\n        if (n0?.type === \"operation\") {\n            if (n0.content.content === \"node\") {\n                // Nodes are a special type of operation.\n                return \"node\";\n            }\n            return \"operation\";\n        }\n\n        return \"unknown\";\n    }\n\n    /**\n     * Eat comments and an optional arg if present. If no optional\n     * arg is present, do nothing.\n     */\n    eatOptionalArg() {\n        let i = 0;\n        const comments: Ast.Comment[] = [];\n        let optionalArg:\n            | (PathSpecNode & { type: \"square_brace_group\" })\n            | null = null;\n        for (; i < this.nodes.length; i++) {\n            const node = this.nodes[i];\n            if (node.type === \"square_brace_group\") {\n                optionalArg = node;\n                i++;\n                break;\n            }\n            if (node.type === \"comment\") {\n                comments.push(node);\n                continue;\n            }\n            break;\n        }\n        if (optionalArg) {\n            // If we grabbed an optional argument, remove it and everything\n            // preceding it.\n            this.nodes.splice(0, i);\n        }\n        return { optionalArg, comments };\n    }\n\n    /**\n     * Eat a `type === \"operation\"` node whose contents is `\"node\"`. I.e.,\n     * the type of thing that shows up in `\\path node at (1,1) {foo};`\n     */\n    eatNode(): Doc[] | null {\n        const firstNode = this.nodes[0];\n        if (\n            firstNode?.type === \"operation\" &&\n            firstNode.content.content === \"node\"\n        ) {\n            this.nodes.shift();\n        } else {\n            return null;\n        }\n\n        // From the tikz documentation:\n        // \\path \u2026 node \u27E8foreach statements\u27E9 [\u27E8options\u27E9] (\u27E8name\u27E9) at(\u27E8coordinate\u27E9)\n        //       :\u27E8animation attribute\u27E9={\u27E8options\u27E9} {\u27E8node contents\u27E9} \u2026;\n        //\n        // Order of the parts of the specification.\n        // Everything between \u201Cnode\u201D and the opening brace of a node is optional.\n        // If there are \u27E8foreach statements\u27E9, they must come first, directly following \u201Cnode\u201D.\n        // Other than that, the ordering of all the other elements of a node specification\n        // (the \u27E8options\u27E9, the \u27E8name\u27E9, \u27E8coordinate\u27E9, and \u27E8animation attribute\u27E9) is arbitrary, indeed,\n        // there can be multiple occurrences of any of these elements (although for the name and the\n        // coordinate this makes no sense).\n\n        const innerDoc: Doc = [];\n        const commentBlock: Doc = [];\n        const doc: Doc = [commentBlock, \"node\", group(indent(innerDoc))];\n        // We now peek to see if a group `{...}` is the next thing. If so,\n        // we're going to eat everything up to it and call it quits. Otherwise,\n        // we bail.\n        let hasNodeArgument = false;\n        let shouldBail = false;\n        let i = 0;\n        const comments: Doc[] = [];\n        const options: Doc[] = [];\n        const name: Doc[] = [];\n        const atLocations: Doc[] = [];\n        const animations: Doc[] = [];\n        let content: Doc = [];\n        for (; i < this.nodes.length && !shouldBail; i++) {\n            const node = this.nodes[i];\n            switch (node.type) {\n                case \"animation\":\n                    animations.push(this.nodeToDoc(node));\n                    continue;\n                case \"comment\": {\n                    const comment: Ast.Comment = {\n                        ...node,\n                        leadingWhitespace: false,\n                    };\n                    comments.push(this.nodeToDoc(comment));\n                    continue;\n                }\n                case \"square_brace_group\":\n                    options.push(printOptionalArgs(node.content));\n                    continue;\n                case \"coordinate\":\n                    name.push(this.nodeToDoc(node));\n                    continue;\n                case \"operation\": {\n                    // An \"at\" should be followed by a coordinate or a macro. If it is,\n                    // then we slurp it. Otherwise we bail.\n                    if (node.content.content === \"at\") {\n                        const nextNode = this.nodes[i + 1];\n                        if (\n                            !nextNode ||\n                            !(\n                                nextNode.type === \"coordinate\" ||\n                                (nextNode.type === \"unknown\" &&\n                                    match.anyMacro(nextNode.content))\n                            )\n                        ) {\n                            shouldBail = true;\n                            continue;\n                        }\n                        atLocations.push([\"at\", \" \", this.nodeToDoc(nextNode)]);\n                        i++;\n                        continue;\n                    }\n                    shouldBail = true;\n                    continue;\n                }\n                case \"unknown\": {\n                    // If we're here, we must be the termination group.\n                    if (match.group(node.content)) {\n                        hasNodeArgument = true;\n                        content = this.nodeToDoc(node);\n                    }\n                    // NOTE: the fallthrough here is on purpose. Finding the terminating\n                    // groups should end our loop.\n                }\n            }\n            break;\n        }\n        if (!hasNodeArgument) {\n            return innerDoc;\n        }\n        // We have collected docs for all the nodes we've scanned, so delete\n        // them from the list.\n        this.nodes.splice(0, i + 1);\n\n        // We standardize node rendering as `[options] :animations (name) at (pos) {content}`\n        let isFirstElement = true;\n        let isNamed = !(Array.isArray(name) && name.length === 0);\n        // Comments get hoisted to before the \"node\" keyword\n        for (const comment of comments) {\n            commentBlock.push(comment, hardline);\n        }\n        if (options.length > 0) {\n            innerDoc.push(join(\" \", options));\n            isFirstElement = false;\n        }\n        if (animations.length > 0) {\n            innerDoc.push(isFirstElement ? \" \" : line);\n            innerDoc.push(join(line, animations));\n            isFirstElement = false;\n        }\n        if (isNamed) {\n            innerDoc.push(isFirstElement ? \" \" : line);\n            innerDoc.push(name);\n            isFirstElement = false;\n        }\n        if (atLocations.length > 0) {\n            innerDoc.push(isFirstElement || isNamed ? \" \" : line);\n            innerDoc.push(join(line, atLocations));\n            isFirstElement = false;\n        }\n        innerDoc.push(line, content);\n\n        return doc;\n    }\n\n    /**\n     * Eat a `type === \"operation\"` node, including its optional arguments.\n     */\n    eatOperation(): Doc[] {\n        const node = this.nodes[0];\n        if (node?.type === \"operation\") {\n            this.nodes.shift();\n        } else {\n            return [];\n        }\n\n        const doc: Doc[] = [];\n        if (node?.type !== \"operation\") {\n            throw new Error(\"Expecting `operation` node.\");\n        }\n        const options = this.eatOptionalArg();\n        doc.push(\n            ...options.comments.map((c) =>\n                printFragment(c, this.#path, this.#print)\n            ),\n            node.content.content\n        );\n        if (options.optionalArg) {\n            doc.push(indent(printOptionalArgs(options.optionalArg.content)));\n        }\n\n        return doc;\n    }\n}\n\nconst PATH_JOIN_OPERATIONS = new Set([\"rectangle\", \"grid\", \"sin\", \"cos\", \"to\"]);\n/**\n * Return whether `node` is a \"path join\", like `--`, `rectangle`, etc.\n *\n * A path join is an operation that sits between two coordinates, like\n * `(a) -- (b)` or `(a) rectangle (b)`.\n */\nfunction isPathJoinOperation(node?: PathSpecNode): boolean {\n    if (!node) {\n        return false;\n    }\n    switch (node.type) {\n        case \"line_to\":\n        case \"curve_to\":\n            return true;\n        case \"operation\":\n            return PATH_JOIN_OPERATIONS.has(node.content.content);\n    }\n    return false;\n}\n", "import type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport { getNodeInfo, formatDocArray, hardline, ifBreak, fill } from \"./common\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\nimport { printTikzArgument } from \"./tikz\";\nimport { printArgumentPgfkeys } from \"./print-argument-pgfkeys\";\n\nexport function printArgument(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Argument;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    // We can return early for empty arguments (this is common for omitted optional arguments)\n    if (\n        node.openMark === \"\" &&\n        node.closeMark === \"\" &&\n        node.content.length === 0\n    ) {\n        return [];\n    }\n    const parentNode = path.getParentNode();\n    const { renderInfo: parentRenderInfo } = getNodeInfo(parentNode, options);\n    // We handle printing pgfkeys arguments manually\n    if (parentRenderInfo.pgfkeysArgs) {\n        const leadingComment =\n            node.content.length > 0 &&\n            match.comment(node.content[0]) &&\n            node.content[0].sameline\n                ? node.content[0]\n                : null;\n        const content = leadingComment ? node.content.slice(1) : node.content;\n        trim(content);\n        return printArgumentPgfkeys(content, {\n            openMark: node.openMark,\n            closeMark: node.closeMark,\n            leadingComment,\n        });\n    }\n    if (parentRenderInfo.tikzPathCommand) {\n        return printTikzArgument(path, print, options);\n    }\n\n    // Regular argument printing\n    const openMark = node.openMark;\n    const closeMark = node.closeMark;\n    let content = path.map(print, \"content\");\n    content = formatDocArray(node.content, content, options);\n\n    // if the last item is a comment, we need to insert a hardline\n    if (match.comment(node.content[node.content.length - 1])) {\n        content.push(hardline);\n    }\n\n    let rawRet: Doc[] = [openMark, fill(content), closeMark];\n    if (renderInfo.inParMode) {\n        // In paragraph node, arguments should flow just like text\n        rawRet = [openMark, ...content, closeMark];\n    }\n    if (referenceMap) {\n        // Save the raw rendered data in case a renderer higher up\n        // wants to unwrap it\n        referenceMap.setRenderCache(node, rawRet);\n    }\n\n    return rawRet;\n}\n", "import type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport { getNodeInfo, fill, formatDocArray } from \"./common\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Returns true if a `\\documentclass` macro is detected,\n * which would indicate that the node list contains the preamble.\n *\n * @param {[object]} nodes\n */\nexport function hasPreambleCode(nodes: Ast.Node[]) {\n    return nodes.some((node) => match.macro(node, \"documentclass\"));\n}\n\nexport function printRoot(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Root;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    const content = path.map(print, \"content\");\n    const rawContent = formatDocArray(node.content, content, options);\n\n    const concatFunction = hasPreambleCode(node.content) ? (x: any) => x : fill;\n    return concatFunction(rawContent);\n}\n", "import type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport * as PrettierTypes from \"./prettier-types\";\n\nexport function printComment(\n    path: PrettierTypes.AstPath,\n    _print: PrettierTypes.RecursivePrintFunc,\n    _options: any\n): Doc {\n    const node = path.getNode() as Ast.Comment;\n\n    // If a comment is on the same line as other content and it has leading whitespace,\n    // add a single whitespace token.\n    let leadingWhitespace = \"\";\n    if (node.leadingWhitespace && node.sameline) {\n        leadingWhitespace = \" \";\n    }\n\n    const content: Doc[] = [leadingWhitespace, \"%\" + printRaw(node.content)];\n    return content;\n}\n", "import type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport {\n    getNodeInfo,\n    softline,\n    fill,\n    hardline,\n    line,\n    indent,\n    ESCAPE,\n    joinWithSoftline,\n    formatDocArray,\n} from \"./common\";\n\nexport function printInlineMath(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.InlineMath;\n\n    // Since `$$` starts display math mode (in plain TeX),\n    // an empty inline math environment must be printed as `$ $`.\n    // We special case this.\n    if (node.content.length === 0) {\n        // We won't allow an empty math environment to be broken\n        return [\"$\", \" \", \"$\"];\n    }\n\n    let content = path.map(print, \"content\");\n    content = formatDocArray(node.content, content, options);\n    content = joinWithSoftline(content);\n\n    // If the last node is a comment, we need a linebreak before the closing `$`\n    if (node.content[node.content.length - 1].type === \"comment\") {\n        content.push(hardline);\n    }\n\n    return fill([\"$\", ...content, \"$\"]);\n}\n\nexport function printDisplayMath(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.InlineMath;\n\n    let content = path.map(print, \"content\");\n    content = formatDocArray(node.content, content, options);\n    content = joinWithSoftline(content);\n\n    // If we start with a comment on the same line as the environment\n    // We should not insert a newline at the start of the environment body\n    const bodyStartToken: PrettierTypes.Doc[] = [hardline];\n    if (\n        node.content.length === 0 ||\n        (node.content[0].type === \"comment\" && node.content[0].sameline)\n    ) {\n        bodyStartToken.pop();\n    }\n\n    return [\n        ESCAPE + \"[\",\n        indent(fill(bodyStartToken.concat(content))),\n        hardline,\n        ESCAPE + \"]\",\n    ];\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport {\n    AlignEnvironmentPegParser,\n    decorateArrayForPegjs,\n} from \"@unified-latex/unified-latex-util-pegjs\";\n\n// The types returned by the grammar\ninterface RowItems {\n    cells: Ast.Node[][];\n    colSeps: Ast.String[];\n}\n\ninterface Row extends RowItems {\n    rowSep: Ast.Macro | null;\n    trailingComment: Ast.Comment | null;\n}\n\nexport function createMatchers(rowSepMacros: string[], colSep: string[]) {\n    const isRowSep = match.createMacroMatcher(rowSepMacros);\n    return {\n        isRowSep,\n        isColSep: (node: Ast.Node) =>\n            colSep.some((sep) => match.string(node, sep)),\n        isWhitespace: (node: Ast.Node) => match.whitespace(node),\n        isSameLineComment: (node: Ast.Node) =>\n            match.comment(node) && node.sameline,\n        isOwnLineComment: (node: Ast.Node) =>\n            match.comment(node) && !node.sameline,\n    };\n}\n\n/**\n * Parse the content of an align environment into an array of row objects.\n * Each row object looks like\n * ```\n *  {\n *    cells: [...],\n *    colSeps: [...],\n *    rowSep: ...,\n *    trailingComment: ...\n *  }\n * ```\n * `...` may be an ast node or `null`.\n *\n * @export\n * @param {[object]} ast\n * @param {string} [colSep=[\"&\"]]\n * @param {string} [rowSepMacros=[\"\\\\\", \"hline\", \"cr\"]]\n * @returns\n */\nexport function parseAlignEnvironment(\n    ast: Ast.Node[],\n    colSep = [\"&\"],\n    rowSepMacros = [\"\\\\\", \"hline\", \"cr\"]\n): Row[] {\n    if (!Array.isArray(ast)) {\n        throw new Error(\"You must pass an array of nodes\");\n    }\n    // We need to at functions to `nodes` so that it imitates\n    // a Javascript string. Because we're mutating, make a copy first\n    ast = decorateArrayForPegjs([...ast]);\n    // matchers are passed in via the second argument (the `options` argument)\n    // so they are available from within the Pegjs grammar.\n    return AlignEnvironmentPegParser.parse(\n        ast,\n        createMatchers(rowSepMacros, colSep)\n    ) as Row[];\n}\n", "import type { Doc } from \"prettier\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport {\n    getNodeInfo,\n    softline,\n    fill,\n    indent,\n    hardline,\n    line,\n    ESCAPE,\n    formatEnvSurround,\n    joinWithSoftline,\n    formatDocArray,\n} from \"./common\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { parseAlignEnvironment } from \"@unified-latex/unified-latex-util-align\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\n\nexport function printVerbatimEnvironment(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.VerbatimEnvironment;\n\n    const env = formatEnvSurround(node as any);\n\n    return [env.start, node.content, env.end];\n}\n\nexport function printEnvironment(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Environment;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    const args = node.args ? path.map(print, \"args\" as any) : [];\n    const env = formatEnvSurround(node);\n\n    let content = path.map(print, \"content\");\n    content = formatDocArray(node.content, content, options);\n    if (renderInfo.inMathMode) {\n        content = joinWithSoftline(content);\n    }\n\n    // If we start with a comment on the same line as the environment\n    // We should not insert a newline at the start of the environment body\n    let bodyStartToken: PrettierTypes.Doc[] = [hardline];\n    if (\n        node.content.length === 0 ||\n        (node.content[0].type === \"comment\" && node.content[0].sameline)\n    ) {\n        bodyStartToken.pop();\n    }\n\n    return [\n        env.start,\n        ...args,\n        indent(fill(bodyStartToken.concat(content))),\n        hardline,\n        env.end,\n    ];\n}\n\nexport function printAlignedEnvironment(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Environment;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    const args = node.args ? path.map(print, \"args\" as any) : [];\n    const env = formatEnvSurround(node);\n\n    // If an aligned environment starts with a same-line comment, we want\n    // to ignore it. It will be printed by the environment itself.\n    const leadingComment =\n        node.content[0] &&\n        node.content[0].type === \"comment\" &&\n        node.content[0].sameline\n            ? node.content[0]\n            : null;\n\n    const { rows, rowSeps, trailingComments } = formatAlignedContent(\n        leadingComment ? node.content.slice(1) : node.content\n    );\n\n    const content = [];\n    for (let i = 0; i < rows.length; i++) {\n        const row = rows[i];\n        const rowSep = rowSeps[i];\n        const trailingComment = trailingComments[i];\n\n        // A row has\n        // 1) Content\n        // 2) (optional) rowSep (e.g., `\\\\`)\n        // 3) (optional) comment\n        // We want there to be exactly one space before the rowsep and exactly one space\n        // before any comment.\n        content.push(row);\n        if (rowSep) {\n            content.push(printRaw(rowSep));\n        }\n        if (rowSep && trailingComment) {\n            content.push(\" \");\n        }\n        if (trailingComment) {\n            content.push([\"%\", printRaw(trailingComment.content)]);\n        }\n        if (rowSep || trailingComment) {\n            content.push(hardline);\n        }\n    }\n    // Make sure the last item is not a `hardline`.\n    if (content[content.length - 1] === hardline) {\n        content.pop();\n    }\n\n    if (leadingComment) {\n        content.unshift(\n            leadingComment.leadingWhitespace ? \" \" : \"\",\n            \"%\" + printRaw(leadingComment.content),\n            hardline\n        );\n        return [env.start, ...args, indent(content), hardline, env.end];\n    }\n    return [\n        env.start,\n        ...args,\n        indent([hardline, ...content]),\n        hardline,\n        env.end,\n    ];\n}\n\n/**\n * Formats the content of an aligned/tabular environment's content.\n * Ensures the \"&\" delimiters all line up.\n *\n * @export\n * @param {[object]} nodes\n * @returns {{rows: [string], rowSeps: [object]}}\n */\nexport function formatAlignedContent(nodes: Ast.Node[]) {\n    function getSpace(len = 1) {\n        return \" \".repeat(len);\n    }\n\n    const rows = parseAlignEnvironment(nodes as any);\n    // Find the number of columns\n    const numCols = Math.max(...rows.map((r) => r.cells.length));\n    const rowSeps = rows.map(({ rowSep }) => printRaw(rowSep || []));\n    const trailingComments = rows.map(({ trailingComment }) => trailingComment);\n\n    // Get the widths of each column.\n    // Column widths will be the width of column contents plus the width\n    // of the separator. This way, even multi-character separators\n    // can be accommodated when rendering.\n    const renderedRows = rows.map(({ cells, colSeps }) => ({\n        cells: cells.map((nodes) => {\n            trim(nodes);\n\n            return printRaw(nodes);\n        }),\n        seps: colSeps.map((nodes) => printRaw(nodes)),\n    }));\n    const colWidths: number[] = [];\n    for (let i = 0; i < numCols; i++) {\n        colWidths.push(\n            Math.max(\n                ...renderedRows.map(\n                    ({ cells, seps }) =>\n                        ((cells[i] || \"\") + (seps[i] || \"\")).length\n                )\n            )\n        );\n    }\n\n    const joinedRows = renderedRows.map(({ cells, seps }) => {\n        if (cells.length === 1 && cells[0] === \"\") {\n            return \"\";\n        }\n        let ret = \"\";\n        for (let i = 0; i < cells.length; i++) {\n            // There are at least as many cells as there are `seps`. Possibly one extra\n            const width = colWidths[i] - (seps[i] || \"\").length;\n\n            // Insert a space at the start so we don't run into the prior separator.\n            // We'll trim this off in the end, in case it's not needed.\n            ret +=\n                (i === 0 ? \"\" : \" \") +\n                cells[i] +\n                getSpace(width - cells[i].length + 1) +\n                (seps[i] || \"\");\n        }\n        return ret;\n    });\n\n    return { rows: joinedRows, rowSeps, trailingComments };\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\n\n/**\n * Generate a data structure that can be queried\n * for the next/previous node. This allows for \"peeking\"\n * during the rendering process.\n *\n * @class ReferenceMap\n */\nexport class ReferenceMap {\n    ast: Ast.Ast;\n    map: Map<\n        Ast.Ast,\n        { previous?: Ast.Ast; next?: Ast.Ast; renderCache?: any }\n    >;\n\n    constructor(ast: Ast.Ast) {\n        this.ast = ast;\n        this.map = new Map();\n        visit(\n            this.ast,\n            (nodeList) => {\n                for (let i = 0; i < nodeList.length; i++) {\n                    this.map.set(nodeList[i], {\n                        previous: nodeList[i - 1],\n                        next: nodeList[i + 1],\n                    });\n                }\n            },\n            { includeArrays: true, test: Array.isArray }\n        );\n    }\n\n    /**\n     * Associate render-specific data with this node. This data\n     * will be overwritten if `setRenderCache` is called twice.\n     *\n     * @param {Ast.Ast} node\n     * @param {*} data\n     * @memberof ReferenceMap\n     */\n    setRenderCache(node: any, data: any): void {\n        const currData = this.map.get(node) || {};\n        this.map.set(node, { ...currData, renderCache: data });\n    }\n\n    /**\n     * Retrieve data associated with `node` via `setRenderCache`\n     *\n     * @param {Ast.Ast} node\n     * @returns {(object | undefined)}\n     * @memberof ReferenceMap\n     */\n    getRenderCache(node: any): object | any[] | undefined {\n        return this.map.get(node)?.renderCache;\n    }\n\n    getPreviousNode(node: Ast.Ast): Ast.Node | undefined {\n        return (this.map.get(node) || ({} as any)).previous;\n    }\n\n    getNextNode(node: Ast.Ast): Ast.Node | undefined {\n        return (this.map.get(node) || ({} as any)).next;\n    }\n}\n", "import type { Doc } from \"prettier\";\nimport * as PrettierTypes from \"./prettier-types\";\n\nimport { hardline, line, ESCAPE, getNodeInfo } from \"./common\";\nimport { printMacro } from \"./macro\";\nimport { printArgument } from \"./argument\";\nimport { printRoot } from \"./root\";\nimport { printComment } from \"./comment\";\nimport { printInlineMath, printDisplayMath } from \"./math\";\nimport {\n    printVerbatimEnvironment,\n    printEnvironment,\n    printAlignedEnvironment,\n} from \"./environment\";\nimport {\n    linebreak,\n    printRaw,\n} from \"@unified-latex/unified-latex-util-print-raw\";\nimport { ReferenceMap } from \"../reference-map\";\n\nexport function printLatexAst(\n    path: PrettierTypes.AstPath,\n    options: PrettierTypes.Options & { referenceMap?: ReferenceMap },\n    print: PrettierTypes.RecursivePrintFunc\n): Doc {\n    const node = path.getValue();\n    const { renderInfo } = getNodeInfo(node, options);\n\n    if (node == null) {\n        return node;\n    }\n    if (typeof node === \"string\") {\n        return node;\n    }\n\n    switch (node.type) {\n        case \"root\":\n            // Create the ReferenceMap from the root node, so that\n            // it can traverse the entire AST\n            if (options.referenceMap) {\n                console.warn(\n                    \"Processing root node, but ReferenceMap already exists. Are there multiple nodes of type 'root'?\"\n                );\n            }\n            options.referenceMap = new ReferenceMap(node);\n            return printRoot(path, print, options);\n        case \"argument\":\n            return printArgument(path, print, options);\n        case \"comment\":\n            return printComment(path, print, options);\n        case \"environment\":\n        case \"mathenv\":\n            if (renderInfo.alignContent) {\n                return printAlignedEnvironment(path, print, options);\n            }\n            return printEnvironment(path, print, options);\n        case \"displaymath\":\n            return printDisplayMath(path, print, options);\n        case \"group\":\n            // When we print a group, we are conservative and do a raw print of its contents.\n            // However, we want to use `linebreak`s instead of literal `\\n` tokens.\n            const content = printRaw(node.content, {\n                asArray: true,\n            }).map((token) => (token === linebreak ? hardline : token));\n            return [\"{\", ...content, \"}\"];\n        case \"inlinemath\":\n            return printInlineMath(path, print, options);\n        case \"macro\":\n            return printMacro(path, print, options);\n        case \"parbreak\":\n            return [hardline, hardline];\n        case \"string\":\n            return node.content;\n        case \"verb\":\n            return [\n                ESCAPE,\n                node.env,\n                node.escape,\n                printRaw(node.content),\n                node.escape,\n            ];\n        case \"verbatim\":\n            return printVerbatimEnvironment(path, print, options);\n        case \"whitespace\":\n            return line;\n        default:\n            console.warn(\"Printing unknown type\", node);\n            return printRaw(node);\n    }\n}\n", "/**\n * Throw a given error.\n *\n * @param {Error|null|undefined} [error]\n *   Maybe error.\n * @returns {asserts error is null|undefined}\n */\nexport function bail(error) {\n  if (error) {\n    throw error\n  }\n}\n", "/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('vfile').VFileValue} VFileValue\n * @typedef {import('..').Processor} Processor\n * @typedef {import('..').Plugin} Plugin\n * @typedef {import('..').Preset} Preset\n * @typedef {import('..').Pluggable} Pluggable\n * @typedef {import('..').PluggableList} PluggableList\n * @typedef {import('..').Transformer} Transformer\n * @typedef {import('..').Parser} Parser\n * @typedef {import('..').Compiler} Compiler\n * @typedef {import('..').RunCallback} RunCallback\n * @typedef {import('..').ProcessCallback} ProcessCallback\n *\n * @typedef Context\n * @property {Node} tree\n * @property {VFile} file\n */\n\nimport {bail} from 'bail'\nimport isBuffer from 'is-buffer'\nimport extend from 'extend'\nimport isPlainObj from 'is-plain-obj'\nimport {trough} from 'trough'\nimport {VFile} from 'vfile'\n\n// Expose a frozen processor.\nexport const unified = base().freeze()\n\nconst own = {}.hasOwnProperty\n\n// Function to create the first processor.\n/**\n * @returns {Processor}\n */\nfunction base() {\n  const transformers = trough()\n  /** @type {Processor['attachers']} */\n  const attachers = []\n  /** @type {Record<string, unknown>} */\n  let namespace = {}\n  /** @type {boolean|undefined} */\n  let frozen\n  let freezeIndex = -1\n\n  // Data management.\n  // @ts-expect-error: overloads are handled.\n  processor.data = data\n  processor.Parser = undefined\n  processor.Compiler = undefined\n\n  // Lock.\n  processor.freeze = freeze\n\n  // Plugins.\n  processor.attachers = attachers\n  // @ts-expect-error: overloads are handled.\n  processor.use = use\n\n  // API.\n  processor.parse = parse\n  processor.stringify = stringify\n  // @ts-expect-error: overloads are handled.\n  processor.run = run\n  processor.runSync = runSync\n  // @ts-expect-error: overloads are handled.\n  processor.process = process\n  processor.processSync = processSync\n\n  // Expose.\n  return processor\n\n  // Create a new processor based on the processor in the current scope.\n  /** @type {Processor} */\n  function processor() {\n    const destination = base()\n    let index = -1\n\n    while (++index < attachers.length) {\n      destination.use(...attachers[index])\n    }\n\n    destination.data(extend(true, {}, namespace))\n\n    return destination\n  }\n\n  /**\n   * @param {string|Record<string, unknown>} [key]\n   * @param {unknown} [value]\n   * @returns {unknown}\n   */\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen)\n        namespace[key] = value\n        return processor\n      }\n\n      // Get `key`.\n      return (own.call(namespace, key) && namespace[key]) || null\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', frozen)\n      namespace = key\n      return processor\n    }\n\n    // Get space.\n    return namespace\n  }\n\n  /** @type {Processor['freeze']} */\n  function freeze() {\n    if (frozen) {\n      return processor\n    }\n\n    while (++freezeIndex < attachers.length) {\n      const [attacher, ...options] = attachers[freezeIndex]\n\n      if (options[0] === false) {\n        continue\n      }\n\n      if (options[0] === true) {\n        options[0] = undefined\n      }\n\n      /** @type {Transformer|void} */\n      const transformer = attacher.call(processor, ...options)\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer)\n      }\n    }\n\n    frozen = true\n    freezeIndex = Number.POSITIVE_INFINITY\n\n    return processor\n  }\n\n  /**\n   * @param {Pluggable|null|undefined} [value]\n   * @param {...unknown} options\n   * @returns {Processor}\n   */\n  function use(value, ...options) {\n    /** @type {Record<string, unknown>|undefined} */\n    let settings\n\n    assertUnfrozen('use', frozen)\n\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin(value, ...options)\n    } else if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new TypeError('Expected usable value, not `' + value + '`')\n    }\n\n    if (settings) {\n      namespace.settings = Object.assign(namespace.settings || {}, settings)\n    }\n\n    return processor\n\n    /**\n     * @param {import('..').Pluggable<unknown[]>} value\n     * @returns {void}\n     */\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value)\n      } else if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          const [plugin, ...options] = value\n          addPlugin(plugin, ...options)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new TypeError('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    /**\n     * @param {Preset} result\n     * @returns {void}\n     */\n    function addPreset(result) {\n      addList(result.plugins)\n\n      if (result.settings) {\n        settings = Object.assign(settings || {}, result.settings)\n      }\n    }\n\n    /**\n     * @param {PluggableList|null|undefined} [plugins]\n     * @returns {void}\n     */\n    function addList(plugins) {\n      let index = -1\n\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (Array.isArray(plugins)) {\n        while (++index < plugins.length) {\n          const thing = plugins[index]\n          add(thing)\n        }\n      } else {\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    /**\n     * @param {Plugin} plugin\n     * @param {...unknown} [value]\n     * @returns {void}\n     */\n    function addPlugin(plugin, value) {\n      let index = -1\n      /** @type {Processor['attachers'][number]|undefined} */\n      let entry\n\n      while (++index < attachers.length) {\n        if (attachers[index][0] === plugin) {\n          entry = attachers[index]\n          break\n        }\n      }\n\n      if (entry) {\n        if (isPlainObj(entry[1]) && isPlainObj(value)) {\n          value = extend(true, entry[1], value)\n        }\n\n        entry[1] = value\n      } else {\n        // @ts-expect-error: fine.\n        attachers.push([...arguments])\n      }\n    }\n  }\n\n  /** @type {Processor['parse']} */\n  function parse(doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Parser = processor.Parser\n    assertParser('parse', Parser)\n\n    if (newable(Parser, 'parse')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Parser(String(file), file).parse()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Parser(String(file), file) // eslint-disable-line new-cap\n  }\n\n  /** @type {Processor['stringify']} */\n  function stringify(node, doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Compiler = processor.Compiler\n    assertCompiler('stringify', Compiler)\n    assertNode(node)\n\n    if (newable(Compiler, 'compile')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Compiler(node, file).compile()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Compiler(node, file) // eslint-disable-line new-cap\n  }\n\n  /**\n   * @param {Node} node\n   * @param {VFileCompatible|RunCallback} [doc]\n   * @param {RunCallback} [callback]\n   * @returns {Promise<Node>|void}\n   */\n  function run(node, doc, callback) {\n    assertNode(node)\n    processor.freeze()\n\n    if (!callback && typeof doc === 'function') {\n      callback = doc\n      doc = undefined\n    }\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((node: Node) => void)} resolve\n     * @param {(error: Error) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      // @ts-expect-error: `doc` can\u2019t be a callback anymore, we checked.\n      transformers.run(node, vfile(doc), done)\n\n      /**\n       * @param {Error|null} error\n       * @param {Node} tree\n       * @param {VFile} file\n       * @returns {void}\n       */\n      function done(error, tree, file) {\n        tree = tree || node\n        if (error) {\n          reject(error)\n        } else if (resolve) {\n          resolve(tree)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, tree, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['runSync']} */\n  function runSync(node, file) {\n    /** @type {Node|undefined} */\n    let result\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.run(node, file, done)\n\n    assertDone('runSync', 'run', complete)\n\n    // @ts-expect-error: we either bailed on an error or have a tree.\n    return result\n\n    /**\n     * @param {Error|null} [error]\n     * @param {Node} [tree]\n     * @returns {void}\n     */\n    function done(error, tree) {\n      bail(error)\n      result = tree\n      complete = true\n    }\n  }\n\n  /**\n   * @param {VFileCompatible} doc\n   * @param {ProcessCallback} [callback]\n   * @returns {Promise<VFile>|undefined}\n   */\n  function process(doc, callback) {\n    processor.freeze()\n    assertParser('process', processor.Parser)\n    assertCompiler('process', processor.Compiler)\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((file: VFile) => void)} resolve\n     * @param {(error?: Error|null|undefined) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      const file = vfile(doc)\n\n      processor.run(processor.parse(file), file, (error, tree, file) => {\n        if (error || !tree || !file) {\n          done(error)\n        } else {\n          /** @type {unknown} */\n          const result = processor.stringify(tree, file)\n\n          if (result === undefined || result === null) {\n            // Empty.\n          } else if (looksLikeAVFileValue(result)) {\n            file.value = result\n          } else {\n            file.result = result\n          }\n\n          done(error, file)\n        }\n      })\n\n      /**\n       * @param {Error|null|undefined} [error]\n       * @param {VFile|undefined} [file]\n       * @returns {void}\n       */\n      function done(error, file) {\n        if (error || !file) {\n          reject(error)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['processSync']} */\n  function processSync(doc) {\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.freeze()\n    assertParser('processSync', processor.Parser)\n    assertCompiler('processSync', processor.Compiler)\n\n    const file = vfile(doc)\n\n    processor.process(file, done)\n\n    assertDone('processSync', 'process', complete)\n\n    return file\n\n    /**\n     * @param {Error|null|undefined} [error]\n     * @returns {void}\n     */\n    function done(error) {\n      complete = true\n      bail(error)\n    }\n  }\n}\n\n/**\n * Check if `value` is a constructor.\n *\n * @param {unknown} value\n * @param {string} name\n * @returns {boolean}\n */\nfunction newable(value, name) {\n  return (\n    typeof value === 'function' &&\n    // Prototypes do exist.\n    // type-coverage:ignore-next-line\n    value.prototype &&\n    // A function with keys in its prototype is probably a constructor.\n    // Classes\u2019 prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    // type-coverage:ignore-next-line\n    (keys(value.prototype) || name in value.prototype)\n  )\n}\n\n/**\n * Check if `value` is an object with keys.\n *\n * @param {Record<string, unknown>} value\n * @returns {boolean}\n */\nfunction keys(value) {\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */\nfunction assertParser(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Parser`')\n  }\n}\n\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */\nfunction assertCompiler(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Compiler`')\n  }\n}\n\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      'Cannot call `' +\n        name +\n        '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'\n    )\n  }\n}\n\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */\nfunction assertNode(node) {\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n  // type-coverage:ignore-next-line\n  if (!isPlainObj(node) || typeof node.type !== 'string') {\n    throw new TypeError('Expected node, got `' + node + '`')\n    // Fine.\n  }\n}\n\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {VFile}\n */\nfunction vfile(value) {\n  return looksLikeAVFile(value) ? value : new VFile(value)\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {value is VFile}\n */\nfunction looksLikeAVFile(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'message' in value &&\n      'messages' in value\n  )\n}\n\n/**\n * @param {unknown} [value]\n * @returns {value is VFileValue}\n */\nfunction looksLikeAVFileValue(value) {\n  return typeof value === 'string' || isBuffer(value)\n}\n", "export default function isPlainObject(value) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n", "/**\n * @typedef {(error?: Error|null|undefined, ...output: Array<any>) => void} Callback\n * @typedef {(...input: Array<any>) => any} Middleware\n *\n * @typedef {(...input: Array<any>) => void} Run\n *   Call all middleware.\n * @typedef {(fn: Middleware) => Pipeline} Use\n *   Add `fn` (middleware) to the list.\n * @typedef {{run: Run, use: Use}} Pipeline\n *   Middleware.\n */\n\n/**\n * Create new middleware.\n *\n * @returns {Pipeline}\n */\nexport function trough() {\n  /** @type {Array<Middleware>} */\n  const fns = []\n  /** @type {Pipeline} */\n  const pipeline = {run, use}\n\n  return pipeline\n\n  /** @type {Run} */\n  function run(...values) {\n    let middlewareIndex = -1\n    /** @type {Callback} */\n    const callback = values.pop()\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Expected function as last argument, not ' + callback)\n    }\n\n    next(null, ...values)\n\n    /**\n     * Run the next `fn`, or we\u2019re done.\n     *\n     * @param {Error|null|undefined} error\n     * @param {Array<any>} output\n     */\n    function next(error, ...output) {\n      const fn = fns[++middlewareIndex]\n      let index = -1\n\n      if (error) {\n        callback(error)\n        return\n      }\n\n      // Copy non-nullish input into values.\n      while (++index < values.length) {\n        if (output[index] === null || output[index] === undefined) {\n          output[index] = values[index]\n        }\n      }\n\n      // Save the newly created `output` for the next call.\n      values = output\n\n      // Next or done.\n      if (fn) {\n        wrap(fn, next)(...output)\n      } else {\n        callback(null, ...output)\n      }\n    }\n  }\n\n  /** @type {Use} */\n  function use(middelware) {\n    if (typeof middelware !== 'function') {\n      throw new TypeError(\n        'Expected `middelware` to be a function, not ' + middelware\n      )\n    }\n\n    fns.push(middelware)\n    return pipeline\n  }\n}\n\n/**\n * Wrap `middleware`.\n * Can be sync or async; return a promise, receive a callback, or return new\n * values and errors.\n *\n * @param {Middleware} middleware\n * @param {Callback} callback\n */\nexport function wrap(middleware, callback) {\n  /** @type {boolean} */\n  let called\n\n  return wrapped\n\n  /**\n   * Call `middleware`.\n   * @this {any}\n   * @param {Array<any>} parameters\n   * @returns {void}\n   */\n  function wrapped(...parameters) {\n    const fnExpectsCallback = middleware.length > parameters.length\n    /** @type {any} */\n    let result\n\n    if (fnExpectsCallback) {\n      parameters.push(done)\n    }\n\n    try {\n      result = middleware.apply(this, parameters)\n    } catch (error) {\n      const exception = /** @type {Error} */ (error)\n\n      // Well, this is quite the pickle.\n      // `middleware` received a callback and called it synchronously, but that\n      // threw an error.\n      // The only thing left to do is to throw the thing instead.\n      if (fnExpectsCallback && called) {\n        throw exception\n      }\n\n      return done(exception)\n    }\n\n    if (!fnExpectsCallback) {\n      if (result instanceof Promise) {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  /**\n   * Call `callback`, only once.\n   * @type {Callback}\n   */\n  function done(error, ...output) {\n    if (!called) {\n      called = true\n      callback(error, ...output)\n    }\n  }\n\n  /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */\n  function then(value) {\n    done(null, value)\n  }\n}\n", "/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {Record<string, unknown> & {type: string, position?: Position|undefined}} NodeLike\n * @typedef {import('./minurl.shared.js').URL} URL\n * @typedef {import('../index.js').Data} Data\n * @typedef {import('../index.js').Value} Value\n *\n * @typedef {'ascii'|'utf8'|'utf-8'|'utf16le'|'ucs2'|'ucs-2'|'base64'|'base64url'|'latin1'|'binary'|'hex'} BufferEncoding\n *   Encodings supported by the buffer class.\n *   This is a copy of the typing from Node, copied to prevent Node globals from\n *   being needed.\n *   Copied from: <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/90a4ec8/types/node/buffer.d.ts#L170>\n *\n * @typedef {Value|Options|VFile|URL} Compatible\n *   Things that can be passed to the constructor.\n *\n * @typedef VFileCoreOptions\n * @property {Value} [value]\n * @property {string} [cwd]\n * @property {Array<string>} [history]\n * @property {string|URL} [path]\n * @property {string} [basename]\n * @property {string} [stem]\n * @property {string} [extname]\n * @property {string} [dirname]\n * @property {Data} [data]\n *\n * @typedef Map\n *   Raw source map, see:\n *   <https://github.com/mozilla/source-map/blob/58819f0/source-map.d.ts#L15-L23>.\n * @property {number} version\n * @property {Array<string>} sources\n * @property {Array<string>} names\n * @property {string|undefined} [sourceRoot]\n * @property {Array<string>|undefined} [sourcesContent]\n * @property {string} mappings\n * @property {string} file\n *\n * @typedef {{[key: string]: unknown} & VFileCoreOptions} Options\n *   Configuration: a bunch of keys that will be shallow copied over to the new\n *   file.\n *\n * @typedef {Record<string, unknown>} ReporterSettings\n * @typedef {<T = ReporterSettings>(files: Array<VFile>, options: T) => string} Reporter\n */\n\nimport buffer from 'is-buffer'\nimport {VFileMessage} from 'vfile-message'\nimport {path} from './minpath.js'\nimport {proc} from './minproc.js'\nimport {urlToPath, isUrl} from './minurl.js'\n\n// Order of setting (least specific to most), we need this because otherwise\n// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n// stem can be set.\nconst order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']\n\nexport class VFile {\n  /**\n   * Create a new virtual file.\n   *\n   * If `options` is `string` or `Buffer`, it\u2019s treated as `{value: options}`.\n   * If `options` is a `URL`, it\u2019s treated as `{path: options}`.\n   * If `options` is a `VFile`, shallow copies its data over to the new file.\n   * All fields in `options` are set on the newly created `VFile`.\n   *\n   * Path related fields are set in the following order (least specific to\n   * most specific): `history`, `path`, `basename`, `stem`, `extname`,\n   * `dirname`.\n   *\n   * It\u2019s not possible to set either `dirname` or `extname` without setting\n   * either `history`, `path`, `basename`, or `stem` as well.\n   *\n   * @param {Compatible} [value]\n   */\n  constructor(value) {\n    /** @type {Options} */\n    let options\n\n    if (!value) {\n      options = {}\n    } else if (typeof value === 'string' || buffer(value)) {\n      // @ts-expect-error Looks like a buffer.\n      options = {value}\n    } else if (isUrl(value)) {\n      options = {path: value}\n    } else {\n      // @ts-expect-error Looks like file or options.\n      options = value\n    }\n\n    /**\n     * Place to store custom information (default: `{}`).\n     * It\u2019s OK to store custom data directly on the file but moving it to\n     * `data` is recommended.\n     * @type {Data}\n     */\n    this.data = {}\n\n    /**\n     * List of messages associated with the file.\n     * @type {Array<VFileMessage>}\n     */\n    this.messages = []\n\n    /**\n     * List of filepaths the file moved between.\n     * The first is the original path and the last is the current path.\n     * @type {Array<string>}\n     */\n    this.history = []\n\n    /**\n     * Base of `path` (default: `process.cwd()` or `'/'` in browsers).\n     * @type {string}\n     */\n    this.cwd = proc.cwd()\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * Raw value.\n     * @type {Value}\n     */\n    this.value\n\n    // The below are non-standard, they are \u201Cwell-known\u201D.\n    // As in, used in several tools.\n\n    /**\n     * Whether a file was saved to disk.\n     * This is used by vfile reporters.\n     * @type {boolean}\n     */\n    this.stored\n\n    /**\n     * Sometimes files have a non-string, compiled, representation.\n     * This can be stored in the `result` field.\n     * One example is when turning markdown into React nodes.\n     * This is used by unified to store non-string results.\n     * @type {unknown}\n     */\n    this.result\n\n    /**\n     * Sometimes files have a source map associated with them.\n     * This can be stored in the `map` field.\n     * This should be a `Map` type, which is equivalent to the `RawSourceMap`\n     * type from the `source-map` module.\n     * @type {Map|undefined}\n     */\n    this.map\n    /* eslint-enable no-unused-expressions */\n\n    // Set path related properties in the correct order.\n    let index = -1\n\n    while (++index < order.length) {\n      const prop = order[index]\n\n      // Note: we specifically use `in` instead of `hasOwnProperty` to accept\n      // `vfile`s too.\n      if (prop in options && options[prop] !== undefined) {\n        // @ts-expect-error: TS is confused by the different types for `history`.\n        this[prop] = prop === 'history' ? [...options[prop]] : options[prop]\n      }\n    }\n\n    /** @type {string} */\n    let prop\n\n    // Set non-path related properties.\n    for (prop in options) {\n      // @ts-expect-error: fine to set other things.\n      if (!order.includes(prop)) this[prop] = options[prop]\n    }\n  }\n\n  /**\n   * Get the full path (example: `'~/index.min.js'`).\n   * @returns {string}\n   */\n  get path() {\n    return this.history[this.history.length - 1]\n  }\n\n  /**\n   * Set the full path (example: `'~/index.min.js'`).\n   * Cannot be nullified.\n   * You can set a file URL (a `URL` object with a `file:` protocol) which will\n   * be turned into a path with `url.fileURLToPath`.\n   * @param {string|URL} path\n   */\n  set path(path) {\n    if (isUrl(path)) {\n      path = urlToPath(path)\n    }\n\n    assertNonEmpty(path, 'path')\n\n    if (this.path !== path) {\n      this.history.push(path)\n    }\n  }\n\n  /**\n   * Get the parent path (example: `'~'`).\n   */\n  get dirname() {\n    return typeof this.path === 'string' ? path.dirname(this.path) : undefined\n  }\n\n  /**\n   * Set the parent path (example: `'~'`).\n   * Cannot be set if there\u2019s no `path` yet.\n   */\n  set dirname(dirname) {\n    assertPath(this.basename, 'dirname')\n    this.path = path.join(dirname || '', this.basename)\n  }\n\n  /**\n   * Get the basename (including extname) (example: `'index.min.js'`).\n   */\n  get basename() {\n    return typeof this.path === 'string' ? path.basename(this.path) : undefined\n  }\n\n  /**\n   * Set basename (including extname) (`'index.min.js'`).\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set basename(basename) {\n    assertNonEmpty(basename, 'basename')\n    assertPart(basename, 'basename')\n    this.path = path.join(this.dirname || '', basename)\n  }\n\n  /**\n   * Get the extname (including dot) (example: `'.js'`).\n   */\n  get extname() {\n    return typeof this.path === 'string' ? path.extname(this.path) : undefined\n  }\n\n  /**\n   * Set the extname (including dot) (example: `'.js'`).\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be set if there\u2019s no `path` yet.\n   */\n  set extname(extname) {\n    assertPart(extname, 'extname')\n    assertPath(this.dirname, 'extname')\n\n    if (extname) {\n      if (extname.charCodeAt(0) !== 46 /* `.` */) {\n        throw new Error('`extname` must start with `.`')\n      }\n\n      if (extname.includes('.', 1)) {\n        throw new Error('`extname` cannot contain multiple dots')\n      }\n    }\n\n    this.path = path.join(this.dirname, this.stem + (extname || ''))\n  }\n\n  /**\n   * Get the stem (basename w/o extname) (example: `'index.min'`).\n   */\n  get stem() {\n    return typeof this.path === 'string'\n      ? path.basename(this.path, this.extname)\n      : undefined\n  }\n\n  /**\n   * Set the stem (basename w/o extname) (example: `'index.min'`).\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set stem(stem) {\n    assertNonEmpty(stem, 'stem')\n    assertPart(stem, 'stem')\n    this.path = path.join(this.dirname || '', stem + (this.extname || ''))\n  }\n\n  /**\n   * Serialize the file.\n   *\n   * @param {BufferEncoding} [encoding='utf8']\n   *   When `value` is a `Buffer`, `encoding` is a character encoding to\n   *   understand it as (default: `'utf8'`).\n   * @returns {string}\n   *   Serialized file.\n   */\n  toString(encoding) {\n    return (this.value || '').toString(encoding)\n  }\n\n  /**\n   * Constructs a new `VFileMessage`, where `fatal` is set to `false`, and\n   * associates it with the file by adding it to `vfile.messages` and setting\n   * `message.file` to the current filepath.\n   *\n   * @param {string|Error|VFileMessage} reason\n   *   Human readable reason for the message, uses the stack and message of the error if given.\n   * @param {Node|NodeLike|Position|Point} [place]\n   *   Place where the message occurred in the file.\n   * @param {string} [origin]\n   *   Computer readable reason for the message\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  message(reason, place, origin) {\n    const message = new VFileMessage(reason, place, origin)\n\n    if (this.path) {\n      message.name = this.path + ':' + message.name\n      message.file = this.path\n    }\n\n    message.fatal = false\n\n    this.messages.push(message)\n\n    return message\n  }\n\n  /**\n   * Like `VFile#message()`, but associates an informational message where\n   * `fatal` is set to `null`.\n   *\n   * @param {string|Error|VFileMessage} reason\n   *   Human readable reason for the message, uses the stack and message of the error if given.\n   * @param {Node|NodeLike|Position|Point} [place]\n   *   Place where the message occurred in the file.\n   * @param {string} [origin]\n   *   Computer readable reason for the message\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  info(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = null\n\n    return message\n  }\n\n  /**\n   * Like `VFile#message()`, but associates a fatal message where `fatal` is\n   * set to `true`, and then immediately throws it.\n   *\n   * > \uD83D\uDC49 **Note**: a fatal error means that a file is no longer processable.\n   *\n   * @param {string|Error|VFileMessage} reason\n   *   Human readable reason for the message, uses the stack and message of the error if given.\n   * @param {Node|NodeLike|Position|Point} [place]\n   *   Place where the message occurred in the file.\n   * @param {string} [origin]\n   *   Computer readable reason for the message\n   * @returns {never}\n   *   Message.\n   */\n  fail(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = true\n\n    throw message\n  }\n}\n\n/**\n * Assert that `part` is not a path (as in, does not contain `path.sep`).\n *\n * @param {string|undefined} part\n * @param {string} name\n * @returns {void}\n */\nfunction assertPart(part, name) {\n  if (part && part.includes(path.sep)) {\n    throw new Error(\n      '`' + name + '` cannot be a path: did not expect `' + path.sep + '`'\n    )\n  }\n}\n\n/**\n * Assert that `part` is not empty.\n *\n * @param {string|undefined} part\n * @param {string} name\n * @returns {asserts part is string}\n */\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty')\n  }\n}\n\n/**\n * Assert `path` exists.\n *\n * @param {string|undefined} path\n * @param {string} name\n * @returns {asserts path is string}\n */\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too')\n  }\n}\n", "/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Serialize the positional info of a point, position (start and end points),\n * or node.\n *\n * @param {Node | NodeLike | Position | PositionLike | Point | PointLike | null | undefined} [value]\n *   Node, position, or point.\n * @returns {string}\n *   Pretty printed positional info of a node (`string`).\n *\n *   In the format of a range `ls:cs-le:ce` (when given `node` or `position`)\n *   or a point `l:c` (when given `point`), where `l` stands for line, `c` for\n *   column, `s` for `start`, and `e` for end.\n *   An empty string (`''`) is returned if the given value is neither `node`,\n *   `position`, nor `point`.\n */\nexport function stringifyPosition(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return ''\n  }\n\n  // Node.\n  if ('position' in value || 'type' in value) {\n    return position(value.position)\n  }\n\n  // Position.\n  if ('start' in value || 'end' in value) {\n    return position(value)\n  }\n\n  // Point.\n  if ('line' in value || 'column' in value) {\n    return point(value)\n  }\n\n  // ?\n  return ''\n}\n\n/**\n * @param {Point | PointLike | null | undefined} point\n * @returns {string}\n */\nfunction point(point) {\n  return index(point && point.line) + ':' + index(point && point.column)\n}\n\n/**\n * @param {Position | PositionLike | null | undefined} pos\n * @returns {string}\n */\nfunction position(pos) {\n  return point(pos && pos.start) + '-' + point(pos && pos.end)\n}\n\n/**\n * @param {number | null | undefined} value\n * @returns {number}\n */\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1\n}\n", "/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {object & {type: string, position?: Position|undefined}} NodeLike\n */\n\nimport {stringifyPosition} from 'unist-util-stringify-position'\n\nexport class VFileMessage extends Error {\n  /**\n   * Create a message for `reason` at `place` from `origin`.\n   *\n   * When an error is passed in as `reason`, the `stack` is copied.\n   *\n   * @param {string|Error|VFileMessage} reason\n   *   Reason for message.\n   *   Uses the stack and message of the error if given.\n   * @param {Node|NodeLike|Position|Point} [place]\n   *   Place at which the message occurred in a file.\n   * @param {string} [origin]\n   *   Place in code the message originates from (example `'my-package:my-rule-name'`)\n   */\n  constructor(reason, place, origin) {\n    /** @type {[string|null, string|null]} */\n    const parts = [null, null]\n    /** @type {Position} */\n    let position = {\n      // @ts-expect-error: we always follows the structure of `position`.\n      start: {line: null, column: null},\n      // @ts-expect-error: \"\n      end: {line: null, column: null}\n    }\n\n    super()\n\n    if (typeof place === 'string') {\n      origin = place\n      place = undefined\n    }\n\n    if (typeof origin === 'string') {\n      const index = origin.indexOf(':')\n\n      if (index === -1) {\n        parts[1] = origin\n      } else {\n        parts[0] = origin.slice(0, index)\n        parts[1] = origin.slice(index + 1)\n      }\n    }\n\n    if (place) {\n      // Node.\n      if ('type' in place || 'position' in place) {\n        if (place.position) {\n          // @ts-expect-error: looks like a position.\n          position = place.position\n        }\n      }\n      // Position.\n      else if ('start' in place || 'end' in place) {\n        // @ts-expect-error: looks like a position.\n        position = place\n      }\n      // Point.\n      else if ('line' in place || 'column' in place) {\n        position.start = place\n      }\n    }\n\n    // Fields from `Error`\n    this.name = stringifyPosition(place) || '1:1'\n    /** @type {string} */\n    this.message = typeof reason === 'object' ? reason.message : reason\n    /** @type {string} */\n    this.stack = ''\n\n    if (typeof reason === 'object' && reason.stack) {\n      this.stack = reason.stack\n    }\n\n    /**\n     * Reason for message.\n     *\n     * @type {string}\n     */\n    this.reason = this.message\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * Whether this is a fatal problem that marks an associated file as no\n     * longer processable.\n     * If `true`, marks associated file as no longer processable.\n     * If `false`, necessitates a (potential) change.\n     * The value can also be `null` or `undefined`, for things that might not\n     * need changing.\n     *\n     * @type {boolean?}\n     */\n    this.fatal\n\n    /**\n     * Starting line of error.\n     *\n     * @type {number?}\n     */\n    this.line = position.start.line\n\n    /**\n     * Starting column of error.\n     *\n     * @type {number?}\n     */\n    this.column = position.start.column\n\n    /**\n     * Full range information, when available.\n     * Has `start` and `end` fields, both set to an object with `line` and\n     * `column`, set to `number?`.\n     *\n     * @type {Position?}\n     */\n    this.position = position\n\n    /**\n     * Namespace of warning (example: `'my-package'`).\n     *\n     * @type {string?}\n     */\n    this.source = parts[0]\n\n    /**\n     * Category of message (example: `'my-rule-name'`).\n     *\n     * @type {string?}\n     */\n    this.ruleId = parts[1]\n\n    /**\n     * Path of a file (used throughout the VFile ecosystem).\n     *\n     * @type {string?}\n     */\n    this.file\n\n    // The following fields are \u201Cwell known\u201D.\n    // Not standard.\n    // Feel free to add other non-standard fields to your messages.\n\n    /**\n     * Specify the source value that\u2019s being reported, which is deemed\n     * incorrect.\n     *\n     * @type {string?}\n     */\n    this.actual\n\n    /**\n     * Suggest values that should be used instead of `actual`, one or more\n     * values that are deemed as acceptable.\n     *\n     * @type {Array<string>?}\n     */\n    this.expected\n\n    /**\n     * Link to documentation for the message.\n     *\n     * @type {string?}\n     */\n    this.url\n\n    /**\n     * Long form description of the message (supported by `vfile-reporter`).\n     *\n     * @type {string?}\n     */\n    this.note\n    /* eslint-enable no-unused-expressions */\n  }\n}\n\nVFileMessage.prototype.file = ''\nVFileMessage.prototype.name = ''\nVFileMessage.prototype.reason = ''\nVFileMessage.prototype.message = ''\nVFileMessage.prototype.stack = ''\nVFileMessage.prototype.fatal = null\nVFileMessage.prototype.column = null\nVFileMessage.prototype.line = null\nVFileMessage.prototype.source = null\nVFileMessage.prototype.ruleId = null\nVFileMessage.prototype.position = null\n", "// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Node\u2019s internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nexport const path = {basename, dirname, extname, join, sep: '/'}\n\n/* eslint-disable max-depth, complexity */\n\n/**\n * @param {string} path\n * @param {string} [ext]\n * @returns {string}\n */\nfunction basename(path, ext) {\n  if (ext !== undefined && typeof ext !== 'string') {\n    throw new TypeError('\"ext\" argument must be a string')\n  }\n\n  assertPath(path)\n  let start = 0\n  let end = -1\n  let index = path.length\n  /** @type {boolean|undefined} */\n  let seenNonSlash\n\n  if (ext === undefined || ext.length === 0 || ext.length > path.length) {\n    while (index--) {\n      if (path.charCodeAt(index) === 47 /* `/` */) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        if (seenNonSlash) {\n          start = index + 1\n          break\n        }\n      } else if (end < 0) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component.\n        seenNonSlash = true\n        end = index + 1\n      }\n    }\n\n    return end < 0 ? '' : path.slice(start, end)\n  }\n\n  if (ext === path) {\n    return ''\n  }\n\n  let firstNonSlashEnd = -1\n  let extIndex = ext.length - 1\n\n  while (index--) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (seenNonSlash) {\n        start = index + 1\n        break\n      }\n    } else {\n      if (firstNonSlashEnd < 0) {\n        // We saw the first non-path separator, remember this index in case\n        // we need it if the extension ends up not matching.\n        seenNonSlash = true\n        firstNonSlashEnd = index + 1\n      }\n\n      if (extIndex > -1) {\n        // Try to match the explicit extension.\n        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {\n          if (extIndex < 0) {\n            // We matched the extension, so mark this as the end of our path\n            // component\n            end = index\n          }\n        } else {\n          // Extension does not match, so our result is the entire path\n          // component\n          extIndex = -1\n          end = firstNonSlashEnd\n        }\n      }\n    }\n  }\n\n  if (start === end) {\n    end = firstNonSlashEnd\n  } else if (end < 0) {\n    end = path.length\n  }\n\n  return path.slice(start, end)\n}\n\n/**\n * @param {string} path\n * @returns {string}\n */\nfunction dirname(path) {\n  assertPath(path)\n\n  if (path.length === 0) {\n    return '.'\n  }\n\n  let end = -1\n  let index = path.length\n  /** @type {boolean|undefined} */\n  let unmatchedSlash\n\n  // Prefix `--` is important to not run on `0`.\n  while (--index) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      if (unmatchedSlash) {\n        end = index\n        break\n      }\n    } else if (!unmatchedSlash) {\n      // We saw the first non-path separator\n      unmatchedSlash = true\n    }\n  }\n\n  return end < 0\n    ? path.charCodeAt(0) === 47 /* `/` */\n      ? '/'\n      : '.'\n    : end === 1 && path.charCodeAt(0) === 47 /* `/` */\n    ? '//'\n    : path.slice(0, end)\n}\n\n/**\n * @param {string} path\n * @returns {string}\n */\nfunction extname(path) {\n  assertPath(path)\n\n  let index = path.length\n\n  let end = -1\n  let startPart = 0\n  let startDot = -1\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find.\n  let preDotState = 0\n  /** @type {boolean|undefined} */\n  let unmatchedSlash\n\n  while (index--) {\n    const code = path.charCodeAt(index)\n\n    if (code === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (unmatchedSlash) {\n        startPart = index + 1\n        break\n      }\n\n      continue\n    }\n\n    if (end < 0) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension.\n      unmatchedSlash = true\n      end = index + 1\n    }\n\n    if (code === 46 /* `.` */) {\n      // If this is our first dot, mark it as the start of our extension.\n      if (startDot < 0) {\n        startDot = index\n      } else if (preDotState !== 1) {\n        preDotState = 1\n      }\n    } else if (startDot > -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension.\n      preDotState = -1\n    }\n  }\n\n  if (\n    startDot < 0 ||\n    end < 0 ||\n    // We saw a non-dot character immediately before the dot.\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly `..`.\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return ''\n  }\n\n  return path.slice(startDot, end)\n}\n\n/**\n * @param {Array<string>} segments\n * @returns {string}\n */\nfunction join(...segments) {\n  let index = -1\n  /** @type {string|undefined} */\n  let joined\n\n  while (++index < segments.length) {\n    assertPath(segments[index])\n\n    if (segments[index]) {\n      joined =\n        joined === undefined ? segments[index] : joined + '/' + segments[index]\n    }\n  }\n\n  return joined === undefined ? '.' : normalize(joined)\n}\n\n/**\n * Note: `normalize` is not exposed as `path.normalize`, so some code is\n * manually removed from it.\n *\n * @param {string} path\n * @returns {string}\n */\nfunction normalize(path) {\n  assertPath(path)\n\n  const absolute = path.charCodeAt(0) === 47 /* `/` */\n\n  // Normalize the path according to POSIX rules.\n  let value = normalizeString(path, !absolute)\n\n  if (value.length === 0 && !absolute) {\n    value = '.'\n  }\n\n  if (value.length > 0 && path.charCodeAt(path.length - 1) === 47 /* / */) {\n    value += '/'\n  }\n\n  return absolute ? '/' + value : value\n}\n\n/**\n * Resolve `.` and `..` elements in a path with directory names.\n *\n * @param {string} path\n * @param {boolean} allowAboveRoot\n * @returns {string}\n */\nfunction normalizeString(path, allowAboveRoot) {\n  let result = ''\n  let lastSegmentLength = 0\n  let lastSlash = -1\n  let dots = 0\n  let index = -1\n  /** @type {number|undefined} */\n  let code\n  /** @type {number} */\n  let lastSlashIndex\n\n  while (++index <= path.length) {\n    if (index < path.length) {\n      code = path.charCodeAt(index)\n    } else if (code === 47 /* `/` */) {\n      break\n    } else {\n      code = 47 /* `/` */\n    }\n\n    if (code === 47 /* `/` */) {\n      if (lastSlash === index - 1 || dots === 1) {\n        // Empty.\n      } else if (lastSlash !== index - 1 && dots === 2) {\n        if (\n          result.length < 2 ||\n          lastSegmentLength !== 2 ||\n          result.charCodeAt(result.length - 1) !== 46 /* `.` */ ||\n          result.charCodeAt(result.length - 2) !== 46 /* `.` */\n        ) {\n          if (result.length > 2) {\n            lastSlashIndex = result.lastIndexOf('/')\n\n            if (lastSlashIndex !== result.length - 1) {\n              if (lastSlashIndex < 0) {\n                result = ''\n                lastSegmentLength = 0\n              } else {\n                result = result.slice(0, lastSlashIndex)\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/')\n              }\n\n              lastSlash = index\n              dots = 0\n              continue\n            }\n          } else if (result.length > 0) {\n            result = ''\n            lastSegmentLength = 0\n            lastSlash = index\n            dots = 0\n            continue\n          }\n        }\n\n        if (allowAboveRoot) {\n          result = result.length > 0 ? result + '/..' : '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (result.length > 0) {\n          result += '/' + path.slice(lastSlash + 1, index)\n        } else {\n          result = path.slice(lastSlash + 1, index)\n        }\n\n        lastSegmentLength = index - lastSlash - 1\n      }\n\n      lastSlash = index\n      dots = 0\n    } else if (code === 46 /* `.` */ && dots > -1) {\n      dots++\n    } else {\n      dots = -1\n    }\n  }\n\n  return result\n}\n\n/**\n * @param {string} path\n */\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError(\n      'Path must be a string. Received ' + JSON.stringify(path)\n    )\n  }\n}\n\n/* eslint-enable max-depth, complexity */\n", "// Somewhat based on:\n// <https://github.com/defunctzombie/node-process/blob/master/browser.js>.\n// But I don\u2019t think one tiny line of code can be copyrighted. \uD83D\uDE05\nexport const proc = {cwd}\n\nfunction cwd() {\n  return '/'\n}\n", "/**\n * @typedef URL\n * @property {string} hash\n * @property {string} host\n * @property {string} hostname\n * @property {string} href\n * @property {string} origin\n * @property {string} password\n * @property {string} pathname\n * @property {string} port\n * @property {string} protocol\n * @property {string} search\n * @property {any} searchParams\n * @property {string} username\n * @property {() => string} toString\n * @property {() => string} toJSON\n */\n\n/**\n * @param {unknown} fileURLOrPath\n * @returns {fileURLOrPath is URL}\n */\n// From: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js#L1501>\nexport function isUrl(fileURLOrPath) {\n  return (\n    fileURLOrPath !== null &&\n    typeof fileURLOrPath === 'object' &&\n    // @ts-expect-error: indexable.\n    fileURLOrPath.href &&\n    // @ts-expect-error: indexable.\n    fileURLOrPath.origin\n  )\n}\n", "/// <reference lib=\"dom\" />\n\nimport {isUrl} from './minurl.shared.js'\n\n// See: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js>\n\n/**\n * @param {string|URL} path\n */\nexport function urlToPath(path) {\n  if (typeof path === 'string') {\n    path = new URL(path)\n  } else if (!isUrl(path)) {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'The \"path\" argument must be of type string or an instance of URL. Received `' +\n        path +\n        '`'\n    )\n    error.code = 'ERR_INVALID_ARG_TYPE'\n    throw error\n  }\n\n  if (path.protocol !== 'file:') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError('The URL must be of scheme file')\n    error.code = 'ERR_INVALID_URL_SCHEME'\n    throw error\n  }\n\n  return getPathFromURLPosix(path)\n}\n\n/**\n * @param {URL} url\n */\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'File URL host must be \"localhost\" or empty on darwin'\n    )\n    error.code = 'ERR_INVALID_FILE_URL_HOST'\n    throw error\n  }\n\n  const pathname = url.pathname\n  let index = -1\n\n  while (++index < pathname.length) {\n    if (\n      pathname.charCodeAt(index) === 37 /* `%` */ &&\n      pathname.charCodeAt(index + 1) === 50 /* `2` */\n    ) {\n      const third = pathname.charCodeAt(index + 2)\n      if (third === 70 /* `F` */ || third === 102 /* `f` */) {\n        /** @type {NodeJS.ErrnoException} */\n        const error = new TypeError(\n          'File URL path must not include encoded / characters'\n        )\n        error.code = 'ERR_INVALID_FILE_URL_PATH'\n        throw error\n      }\n    }\n  }\n\n  return decodeURIComponent(pathname)\n}\n\nexport {isUrl} from './minurl.shared.js'\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { splitOnCondition } from \"./split-on-condition\";\n\n/**\n * Split an array of AST nodes based on a macro. An object `{segments: [], macros: []}`\n * is returned. The original array is reconstructed as\n * `segments[0] + macros[0] + segments[1] + ...`.\n *\n * @param {[object]} ast\n * @param {(string|[string])} macroName\n * @returns {{segments: [object], macros: [object]}}\n */\nexport function splitOnMacro(\n    ast: Ast.Node[],\n    macroName: string | string[]\n): { segments: Ast.Node[][]; macros: Ast.Macro[] } {\n    if (typeof macroName === \"string\") {\n        macroName = [macroName];\n    }\n    if (!Array.isArray(macroName)) {\n        throw new Error(\"Type coercion failed\");\n    }\n    const isSeparator = match.createMacroMatcher(macroName);\n    const { segments, separators } = splitOnCondition(ast, isSeparator);\n    return { segments, macros: separators as Ast.Macro[] };\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Split a list of nodes based on whether `splitFunc` returns `true`.\n * If `onlySplitOnFirstOccurrence` is set to true in the `options` object, then\n * there will be at most two segments returned.\n */\nexport function splitOnCondition(\n    nodes: Ast.Node[],\n    splitFunc: (node: Ast.Node) => boolean = () => false,\n    options?: { onlySplitOnFirstOccurrence?: boolean }\n): { segments: Ast.Node[][]; separators: Ast.Node[] } {\n    if (!Array.isArray(nodes)) {\n        throw new Error(`Can only split an Array, not ${nodes}`);\n    }\n\n    const { onlySplitOnFirstOccurrence = false } = options || {};\n\n    const splitIndices: number[] = [];\n    for (let i = 0; i < nodes.length; i++) {\n        if (splitFunc(nodes[i])) {\n            splitIndices.push(i);\n            if (onlySplitOnFirstOccurrence) {\n                break;\n            }\n        }\n    }\n\n    // Short circuit if there is no splitting to be done\n    if (splitIndices.length === 0) {\n        return { segments: [nodes], separators: [] };\n    }\n\n    let separators = splitIndices.map((i) => nodes[i]);\n    let segments = splitIndices.map((splitEnd, i) => {\n        const splitStart = i === 0 ? 0 : splitIndices[i - 1] + 1;\n        return nodes.slice(splitStart, splitEnd);\n    });\n    segments.push(\n        nodes.slice(splitIndices[splitIndices.length - 1] + 1, nodes.length)\n    );\n\n    return { segments, separators };\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Does the reverse of `splitOnMacro`\n */\nexport function unsplitOnMacro({\n    segments,\n    macros,\n}: {\n    segments: Ast.Node[][];\n    macros: Ast.Node[] | Ast.Node[][];\n}) {\n    if (segments.length === 0) {\n        console.warn(\"Trying to join zero segments\");\n        return [];\n    }\n    if (segments.length !== macros.length + 1) {\n        console.warn(\n            \"Mismatch between lengths of macros and segments when trying to unsplit\"\n        );\n    }\n\n    let ret = segments[0];\n    for (let i = 0; i < macros.length; i++) {\n        // Even though the type of macros[i] is node and not array,\n        // Array.concat still works\n        ret = ret.concat(macros[i]).concat(segments[i + 1]);\n    }\n\n    return ret;\n}\n", "/**\n * Joins an array of arrays with the item `sep`\n */\nexport function arrayJoin<T>(array: T[][], sep: T | T[]): T[] {\n    return array.flatMap((item, i) => {\n        if (i === 0) {\n            return item;\n        }\n        if (Array.isArray(sep)) {\n            return [...sep, ...item];\n        } else {\n            return [sep, ...item];\n        }\n    });\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    visit,\n    VisitInfo,\n} from \"@unified-latex/unified-latex-util-visit\";\n\n/**\n * Recursively replace nodes in `ast`. The `visitor` function is called on each node. If\n * `visitor` returns a node or an array of nodes, those nodes replace the node passed to `visitor`.\n * If `null` is returned, the node is deleted. If `undefined` is returned, no replacement happens.\n */\nexport function replaceNode(\n    ast: Ast.Ast,\n    visitor: (\n        node: Ast.Node | Ast.Argument,\n        info: VisitInfo\n    ) =>\n        | Ast.Node\n        | Ast.Argument\n        | (Ast.Node | Ast.Argument)[]\n        | null\n        | undefined\n        | void\n) {\n    visit(ast, {\n        leave: (node, info) => {\n            let replacement = visitor(node, info);\n            // Returning `undefined` or the same node means we shouldn't replace that node\n            if (typeof replacement === \"undefined\" || replacement === node) {\n                return;\n            }\n\n            if (!info.containingArray || info.index == null) {\n                throw new Error(\n                    \"Trying to replace node, but cannot find containing array\"\n                );\n            }\n\n            if (\n                replacement === null ||\n                (Array.isArray(replacement) && replacement.length === 0)\n            ) {\n                // A null return means that we delete the current node\n                info.containingArray.splice(info.index, 1);\n                return info.index;\n            }\n\n            if (!Array.isArray(replacement)) {\n                replacement = [replacement];\n            }\n\n            info.containingArray.splice(info.index, 1, ...replacement);\n            // We don't want to *reprocess* the nodes we just inserted into the array,\n            // lest we get stuck in a recursive loop if the replacement contains the original.\n            // Thus we jump to the index after our replacements.\n            return info.index + replacement.length;\n        },\n    });\n}\n", "import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trimEnd, trimStart } from \"@unified-latex/unified-latex-util-trim\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { replaceStreamingCommand } from \"./replace-streaming-command\";\nimport { replaceNodeDuringVisit } from \"./replace-node-during-visit\";\n\ntype PluginOptions = {\n    replacers: Record<\n        string,\n        (\n            content: Ast.Node[],\n            streamingCommand: Ast.Macro\n        ) => Ast.Node | Ast.Node[]\n    >;\n};\n\n/**\n * Unified plugin to replace all found streaming commands with their argument-style equivalents.\n * This only applies to sections of the tree with no math ancestor.\n *\n * @param options.replacer A record of macro names and replacer functions. A replacer function accepts content and the original streaming command and is expected to return the argument-style command. It may be called multiple times per streaming command.\n */\nexport const unifiedLatexReplaceStreamingCommands: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexReplaceStreamingCommands(options) {\n    const { replacers = {} } = options || {};\n    const isReplaceable = match.createMacroMatcher(replacers);\n    return (tree) => {\n        // We traverse all groups before we replace nodes in other contexts\n        visit(\n            tree,\n            (group, info) => {\n                if (\n                    info.context.hasMathModeAncestor ||\n                    !group.content.some(isReplaceable)\n                ) {\n                    return;\n                }\n\n                let fixed = replaceStreamingCommand(\n                    group,\n                    isReplaceable,\n                    (content, command) => {\n                        return replacers[command.content](content, command);\n                    }\n                );\n\n                // We cannot replace the node unless we can access the containing array.\n                if (!info.containingArray || info.index == null) {\n                    return;\n                }\n\n                // `fixed` may consist of only whitespace. If this is the case,\n                // surrounding whitespace must trimmed before\n                // inserting the group's contents.\n                const prevToken = info.containingArray[info.index - 1];\n                const nextToken = info.containingArray[info.index + 1];\n                if (\n                    match.whitespaceLike(prevToken) &&\n                    match.whitespaceLike(fixed[0])\n                ) {\n                    trimStart(fixed);\n                }\n                if (\n                    match.whitespaceLike(nextToken) &&\n                    match.whitespaceLike(fixed[fixed.length - 1])\n                ) {\n                    trimEnd(fixed);\n                }\n                replaceNodeDuringVisit(fixed, info);\n            },\n            { test: match.group }\n        );\n\n        visit(\n            tree,\n            (nodes, info) => {\n                if (\n                    info.context.hasMathModeAncestor ||\n                    !nodes.some(isReplaceable)\n                ) {\n                    return;\n                }\n\n                const replaced = replaceStreamingCommand(\n                    nodes,\n                    isReplaceable,\n                    (content, command) => {\n                        return replacers[command.content](content, command);\n                    }\n                );\n\n                // If we get back a different array than we input, the replacement did\n                // not happen in-place. In this case we need to manipulate `nodes`.\n                if (replaced !== nodes) {\n                    nodes.length = 0;\n                    nodes.push(...replaced);\n                }\n            },\n            { includeArrays: true, test: Array.isArray }\n        );\n    };\n};\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport {\n    splitOnCondition,\n    unsplitOnMacro,\n} from \"@unified-latex/unified-latex-util-split\";\nimport {\n    trim,\n    trimEnd,\n    trimStart,\n} from \"@unified-latex/unified-latex-util-trim\";\nimport { firstSignificantNode } from \"./utils/significant-node\";\nimport { replaceStreamingCommandInArray } from \"./utils/replace-streaming-command-in-array\";\nimport { wrapSignificantContent } from \"./utils/wrap-significant-content\";\n\ntype Replacer = (nodes: Ast.Node[]) => Ast.Node[];\n\n/**\n * Process streaming commands in a group. If needed, \"escape\" the group.\n * For example, `{\\bfseries xx}` -> `\\textbf{xx}`, but `{foo \\bfseries xx}` -> `{foo \\textbf{xx}}`.\n */\nexport function replaceStreamingCommandInGroup(\n    group: Ast.Group,\n    isStreamingCommand: (node: any) => node is Ast.Macro,\n    replacer: (\n        content: Ast.Node[],\n        streamingCommand: Ast.Macro\n    ) => Ast.Node | Ast.Node[],\n    options?: {\n        macrosThatBreakPars?: string[];\n        environmentsThatDontBreakPars?: string[];\n    }\n): Ast.Node[] {\n    const content = group.content;\n    // If the group started with a streaming command, we want to pop\n    // out of the group. E.g. `{\\bfseries foo}` -> `\\textbf{foo}` and not `{\\textbf{foo}}`\n    let popFromGroup = isStreamingCommand(firstSignificantNode(content));\n\n    let innerProcessed = replaceStreamingCommand(\n        content,\n        isStreamingCommand,\n        replacer,\n        options\n    );\n\n    // If the group consisted of just streaming commands (for some reason...)\n    // it should be eliminated\n    if (innerProcessed.length === 0) {\n        return [];\n    }\n\n    if (popFromGroup) {\n        return innerProcessed;\n    } else {\n        return [{ type: \"group\", content: innerProcessed }];\n    }\n}\n\n/**\n * Given a group or a node array, look for streaming commands (e.g., `\\bfseries`) and replace them\n * with the specified macro. The \"arguments\" of the streaming command are passed to `replacer` and the return\n * value of `replacer` is inserted into the stream.\n *\n * By default, this command will split at parbreaks (since commands like `\\textbf{...} do not accept parbreaks in their\n * contents) and call `replacer` multiple times, once per paragraph.\n *\n * Commands are also split at environments and at any macros listed in `macrosThatBreakPars`.\n */\nexport function replaceStreamingCommand(\n    ast: Ast.Group | Ast.Node[],\n    isStreamingCommand: (node: any) => node is Ast.Macro,\n    replacer: (\n        content: Ast.Node[],\n        streamingCommand: Ast.Macro\n    ) => Ast.Node | Ast.Node[],\n    options?: {\n        macrosThatBreakPars?: string[];\n        environmentsThatDontBreakPars?: string[];\n    }\n): Ast.Node[] {\n    if (typeof isStreamingCommand !== \"function\") {\n        throw new Error(\n            `'isStreamingCommand' must be a function, not '${typeof isStreamingCommand}'`\n        );\n    }\n\n    const {\n        macrosThatBreakPars = [\n            \"part\",\n            \"chapter\",\n            \"section\",\n            \"subsection\",\n            \"subsubsection\",\n            \"vspace\",\n            \"smallskip\",\n            \"medskip\",\n            \"bigskip\",\n            \"hfill\",\n        ],\n        environmentsThatDontBreakPars = [],\n    } = options || {};\n\n    let processedContent: Ast.Node[] = [];\n    if (match.group(ast)) {\n        processedContent = replaceStreamingCommandInGroup(\n            ast,\n            isStreamingCommand,\n            replacer\n        );\n    }\n\n    if (Array.isArray(ast)) {\n        // Streaming commands that come at the end of a sequence of nodes don't do anything.\n        // They also will consume whitespace, so we should remove them and the whitespace.\n        const nodes = ast;\n        let scanIndex = nodes.length;\n        let sliceIndex = scanIndex;\n        while (\n            scanIndex > 0 &&\n            (isStreamingCommand(nodes[scanIndex - 1]) ||\n                match.whitespace(nodes[scanIndex - 1]))\n        ) {\n            scanIndex--;\n            if (isStreamingCommand(nodes[scanIndex])) {\n                sliceIndex = scanIndex;\n            }\n        }\n        if (sliceIndex !== nodes.length) {\n            nodes.splice(sliceIndex);\n        }\n\n        const macroThatBreaks = match.createMacroMatcher(macrosThatBreakPars);\n        const envThatDoesntBreak = match.createEnvironmentMatcher(\n            environmentsThatDontBreakPars\n        );\n        // A \"par\" is anything that a streaming command shouldn't wrap and breaks the stream.\n        // This includes regular pars, but also environments and special macros like \\section\n        const isPar = (node: Ast.Node) =>\n            match.parbreak(node) ||\n            match.macro(node, \"par\") ||\n            macroThatBreaks(node) ||\n            (match.environment(node) && !envThatDoesntBreak(node)) ||\n            node.type === \"displaymath\";\n\n        // We split on both a parbreak and a literal `\\par`. But we will\n        // normalize everything to be parbreaks\n        const splitByPar = splitOnCondition(nodes, isPar);\n        splitByPar.separators = splitByPar.separators.map((sep) =>\n            match.macro(sep, \"par\") ? { type: \"parbreak\" } : sep\n        );\n\n        const replacers: Replacer[] = [];\n        let segments = splitByPar.segments.map((segment) => {\n            if (segment.length === 0) {\n                return segment;\n            }\n            function applyAccumulatedReplacers(nodes: Ast.Node[]): Ast.Node[] {\n                if (replacers.length === 0) {\n                    return nodes;\n                }\n                return wrapSignificantContent(\n                    nodes,\n                    composeReplacers(replacers)\n                );\n            }\n\n            const { foundStreamingCommands } = replaceStreamingCommandInArray(\n                segment,\n                isStreamingCommand,\n                replacer\n            );\n\n            // All streaming commands in `segment` have now been replaced. However,\n            // there might be commands from the previous paragraphs that should wrap\n            // the current segment!\n            const ret = applyAccumulatedReplacers(segment);\n\n            // Any streaming commands from this segment will carry over to the next,\n            // so keep track of them.\n            foundStreamingCommands.forEach((macro) => {\n                replacers.push((nodes: Ast.Node[]) => {\n                    const ret = replacer(nodes, macro as Ast.Macro);\n                    if (!Array.isArray(ret)) {\n                        return [ret];\n                    }\n                    return ret;\n                });\n            });\n\n            return ret;\n        });\n\n        // Leading/trailing whitespace was hoisted in front/back of each replacer.\n        // Since we're separated by parbreaks, we can safely trim all that whitespace.\n        if (segments.length > 1) {\n            segments.forEach((segment, i) => {\n                if (i === 0) {\n                    trimEnd(segment);\n                } else if (i === segments.length - 1) {\n                    trimStart(segment);\n                } else {\n                    trim(segment);\n                }\n            });\n        }\n\n        processedContent = unsplitOnMacro({\n            segments: segments,\n            macros: splitByPar.separators,\n        });\n    }\n\n    return processedContent;\n}\n\n/**\n * Given a sequence of replacer functions `[f, g, h]` return\n * `h \\circ g \\circ f`\n *\n * @param {((nodes: Ast.Node[]) => Ast.Node)[]} replacers\n * @returns {(nodes: Ast.Node[]) => Ast.Node}\n */\nfunction composeReplacers(replacers: Replacer[]): Replacer {\n    if (replacers.length === 0) {\n        throw new Error(\"Cannot compose zero replacement functions\");\n    }\n    return (nodes: Ast.Node[]) => {\n        let ret = nodes;\n        for (let i = 0; i < replacers.length; i++) {\n            const func = replacers[i];\n            ret = func(ret);\n        }\n        return ret;\n    };\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Returns the first non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function firstSignificantNode(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): Ast.Node | null {\n    const index = firstSignificantNodeIndex(nodes, parbreaksAreInsignificant);\n    if (index == null) {\n        return null;\n    }\n    return nodes[index];\n}\n\n/**\n * Returns the last non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function lastSignificantNode(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): Ast.Node | null {\n    const index = lastSignificantNodeIndex(nodes, parbreaksAreInsignificant);\n    if (index == null) {\n        return null;\n    }\n    return nodes[index];\n}\n\n/**\n * Returns the index of the last non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function lastSignificantNodeIndex(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): number | undefined {\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        const node = nodes[i];\n        if (\n            match.whitespace(node) ||\n            match.comment(node) ||\n            (parbreaksAreInsignificant && match.parbreak(node))\n        ) {\n            continue;\n        }\n        return i;\n    }\n    return undefined;\n}\n\n/**\n * Returns the index of the first non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function firstSignificantNodeIndex(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): number | undefined {\n    for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (\n            match.whitespace(node) ||\n            match.comment(node) ||\n            (parbreaksAreInsignificant && match.parbreak(node))\n        ) {\n            continue;\n        }\n        return i;\n    }\n    return undefined;\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { trimEnd, trimStart } from \"@unified-latex/unified-latex-util-trim\";\nimport { joinWithoutExcessWhitespace } from \"./join-without-excess-whitespace\";\nimport { wrapSignificantContent } from \"./wrap-significant-content\";\n\n/**\n * Replace commands identified by `isStreamingCommand` with the return value of `replacer`.\n * E.g., the array `[head, streamingCommand, ...tail]` will become `[head, replacer(tail, streamingCommand)]`.\n * This function does not split based on parbreaks/etc.. It is right-associative and returns\n * the streaming commands that were encountered.\n */\nexport function replaceStreamingCommandInArray(\n    nodes: Ast.Node[],\n    isStreamingCommand: (node: any) => node is Ast.Macro,\n    replacer: (\n        content: Ast.Node[],\n        streamingCommand: Ast.Macro\n    ) => Ast.Node | Ast.Node[]\n): { foundStreamingCommands: Ast.Node[] } {\n    // Streaming commands that come at the end don't do anything,\n    // so we should remove them\n    while (nodes.length > 0 && isStreamingCommand(nodes[nodes.length - 1])) {\n        nodes.pop();\n        trimEnd(nodes);\n    }\n\n    const foundStreamingCommands: Ast.Node[] = [];\n\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        const node = nodes[i];\n        if (isStreamingCommand(node)) {\n            const wrapper = (content: Ast.Node[]) => replacer(content, node);\n            let tail = nodes.slice(i + 1);\n            // Streaming commands are followed by whitespace, which becomes unneeded when the commands are replaced.\n            trimStart(tail);\n            tail = wrapSignificantContent(tail, wrapper);\n            foundStreamingCommands.push(node);\n\n            // Trim off what we're about to replace!\n            nodes.splice(i);\n\n            joinWithoutExcessWhitespace(nodes, tail);\n        }\n    }\n\n    return { foundStreamingCommands };\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trimStart } from \"@unified-latex/unified-latex-util-trim\";\n\n/**\n * Is the node space-like? I.e., is it whitespace or\n * a comment with leading whitespace?\n */\nfunction isSpaceLike(node: Ast.Node): boolean {\n    return (\n        match.whitespace(node) ||\n        (match.comment(node) && Boolean(node.leadingWhitespace))\n    );\n}\n\n/**\n * Similar to `head.push(...tail)` except that whitespace at the start\n * of `tail` and the end of `head` is collapsed.\n */\nexport function joinWithoutExcessWhitespace(\n    head: Ast.Node[],\n    tail: Ast.Node[]\n): void {\n    if (tail.length === 0) {\n        return;\n    }\n    if (head.length === 0) {\n        head.push(...tail);\n        return;\n    }\n    const headEnd = head[head.length - 1];\n    const tailStart = tail[0];\n    // Whitespace we can just trim off from either end\n    if (match.whitespace(headEnd) && match.whitespace(tailStart)) {\n        head.push(...tail.slice(1));\n        return;\n    }\n    // If there's no whitespace at one of the ends, no need to worry\n    // unless `tailStart` is a comment, in which case it should \"eat\"\n    // the whitespace\n    if (!isSpaceLike(headEnd) || !isSpaceLike(tailStart)) {\n        if (match.whitespace(headEnd) && match.comment(tailStart)) {\n            const comment: Ast.Comment = {\n                type: \"comment\",\n                content: tailStart.content,\n                sameline: true,\n                leadingWhitespace: true,\n            };\n            tail = tail.slice(1);\n            trimStart(tail);\n            head.pop();\n            head.push(comment, ...tail);\n            return;\n        }\n        head.push(...tail);\n        return;\n    }\n\n    // If we're here, we have a comment with leading whitespace on one side\n    // and whitespace/comments on the other.\n    if (match.comment(headEnd) && match.comment(tailStart)) {\n        if (tailStart.leadingWhitespace || tailStart.sameline) {\n            head.push(\n                { type: \"comment\", content: tailStart.content },\n                ...tail.slice(1)\n            );\n            return;\n        }\n        head.push(...tail);\n        return;\n    }\n\n    // Exactly one side is a comment, so we should trim the whitespace and keep the comment,\n    // but make sure the comment has leading whitespace!\n    let comment = match.comment(headEnd) ? headEnd : tailStart;\n    if (!match.comment(comment)) {\n        throw new Error(\n            `Expected a comment but found ${JSON.stringify(comment)}`\n        );\n    }\n\n    if (!comment.leadingWhitespace || !comment.sameline) {\n        comment = {\n            type: \"comment\",\n            content: comment.content,\n            leadingWhitespace: true,\n            sameline: true,\n        };\n    }\n\n    head.pop();\n    head.push(comment, ...tail.slice(1));\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Wraps `content` in the specified wrapper. This command is roughly equivalent to\n * `wrapper(content)` except that leading and trailing whitespace and comments are extracted\n * from `content` and moved to the front or back of the return array. For example,\n * `[\" \", \"foo\", \"bar\", \"% xxx\"]` -> `[\" \", wrapped([\"foo\", \"bar\"]), \"% xxx\"]`.\n *\n */\nexport function wrapSignificantContent(\n    content: Ast.Node[],\n    wrapper: (content: Ast.Node[]) => Ast.Node[] | Ast.Node\n): Ast.Node[] {\n    let hoistUntil = 0;\n    let hoistAfter = content.length;\n    for (let i = 0; i < content.length; i++) {\n        if (match.whitespace(content[i]) || match.comment(content[i])) {\n            hoistUntil = i + 1;\n            continue;\n        }\n        break;\n    }\n    for (let j = content.length - 1; j >= 0; j--) {\n        if (match.whitespace(content[j]) || match.comment(content[j])) {\n            hoistAfter = j;\n            continue;\n        }\n        break;\n    }\n\n    if (hoistUntil === 0 && hoistAfter === content.length) {\n        return ensureArray(wrapper(content));\n    }\n\n    const frontMatter = content.slice(0, hoistUntil);\n    const middle = content.slice(hoistUntil, hoistAfter);\n    const backMatter = content.slice(hoistAfter, content.length);\n\n    return frontMatter.concat(wrapper(middle), backMatter);\n}\n\nfunction ensureArray(x: Ast.Node | Ast.Node[]) {\n    if (!Array.isArray(x)) {\n        return [x];\n    }\n    return x;\n}\n", "import { VisitInfo } from \"@unified-latex/unified-latex-util-visit\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Replaces the current node with `replacement`. It is assumed that the current\n * node is in an array that is a child of a parent element. If this is not the case,\n * the function will error.\n */\nexport function replaceNodeDuringVisit(\n    replacement: Ast.Node | Ast.Argument | (Ast.Node | Ast.Argument)[],\n    info: VisitInfo\n) {\n    const parent = info.parents[0];\n    if (!parent) {\n        throw new Error(`Cannot replace node: parent not found`);\n    }\n    const container = parent[info.key as keyof typeof parent] as\n        | (Ast.Node | Ast.Argument)[]\n        | undefined;\n    if (!Array.isArray(container)) {\n        throw new Error(`Cannot replace node: containing array not found`);\n    }\n    if (info.index == null) {\n        throw new Error(`Cannot replace node: node index undefined`);\n    }\n    if (!Array.isArray(replacement)) {\n        container[info.index] = replacement;\n    } else {\n        container.splice(info.index, 1, ...replacement);\n    }\n}\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    cref: { signature: \"s m\" },\n    Cref: { signature: \"s m\" },\n    crefrange: { signature: \"s m m\" },\n    Crefrange: { signature: \"s m m\" },\n    cpageref: { signature: \"s m\" },\n    Cpageref: { signature: \"s m\" },\n    ref: { signature: \"m\" },\n    pageref: { signature: \"m\" },\n    namecref: { signature: \"m\" },\n    nameCref: { signature: \"m\" },\n    lcnamecref: { signature: \"m\" },\n    namecrefs: { signature: \"m\" },\n    nameCrefs: { signature: \"m\" },\n    lcnamecrefs: { signature: \"m\" },\n    labelcref: { signature: \"m\" },\n    labelcpageref: { signature: \"m\" },\n    crefalias: { signature: \"m m\" },\n    crefname: { signature: \"m m m\" },\n    // XXX there are many more obscure commands to add here\n    // https://ctan.org/pkg/cleveref\n    crefdefaultlabelformat: { signature: \"m\" },\n    crefrangeconjunction: { signature: \"m\" },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import { arg } from \"@unified-latex/unified-latex-builder\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\nimport {\n    lastSignificantNode,\n    lastSignificantNodeIndex,\n} from \"@unified-latex/unified-latex-util-replace\";\nimport { splitOnMacro } from \"@unified-latex/unified-latex-util-split\";\nimport { trim, trimEnd } from \"@unified-latex/unified-latex-util-trim\";\n\n/**\n * Clean up any whitespace issues in an enumerate environment. In particular,\n *      * Remove any leading or ending whitespace\n *      * Ensure there is a par between occurrences of `\\item`\n *      * Ensure there is whitespace after each occurrence of `\\item` provided there is content there\n * `itemName` can be used to set what the \"item\" macro is called.\n *\n * This function attaches content following a `\\item` to the `\\item` macro with\n * `openMark` and `closeMark` set to empty. This allows hanging-indents to be rendered.\n */\nexport function cleanEnumerateBody(\n    ast: Ast.Node[],\n    itemName = \"item\"\n): Ast.Node[] {\n    let { segments, macros } = splitOnMacro(ast, itemName);\n    // Trim the content of each block, but make sure there is a space\n    // between each macro and the content. Since the first segment of content\n    // appears *before* any macro, don't add a space there.\n    for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        if (i === 0) {\n            // The very first segment might be comment with leading whitespace. We don't want to trim that off\n            trimEnd(segment);\n        } else {\n            trim(segment);\n        }\n        // The very first segment comes before any `\\item` macros. It is either\n        // blank or contains comments (or is invalid LaTeX). We don't insert a space\n        // in this case.\n        if (segment.length > 0 && i > 0) {\n            segment.unshift({ type: \"whitespace\" });\n        }\n    }\n\n    let insertParbreakBefore: WeakSet<Ast.Node> = new WeakSet();\n\n    // We want a trailing indent for the `\\item` nodes. We will\n    // do this with a trick: we will add an argument to the index node\n    // with openMark=\" \" and closeMark=\"\"\n    let body: Ast.Node[] = macros.flatMap((node, i) => {\n        const segment = segments[i + 1];\n        const trailingComments = popTrailingComments(segment);\n        node.args = node.args || [];\n        node.args.push(arg(segment, { openMark: \"\", closeMark: \"\" }));\n        updateRenderInfo(node, { inParMode: true });\n\n        // The stream contains a mix of `\\item` macros and comments/parbreaks. We only\n        // want to insert parbreaks before `\\item` macros, so we record these for later.\n        if (i > 0 || segments[0]?.length > 0) {\n            insertParbreakBefore.add(node);\n        }\n\n        return [node, ...trailingComments];\n    });\n\n    // We want a parbreak between each `\\item` block and the preceding content.\n    // We've already logged the `\\item` macros in `insertParbreakBefore`.\n    body = body.flatMap((node) =>\n        insertParbreakBefore.has(node) ? [{ type: \"parbreak\" }, node] : node\n    );\n\n    body.unshift(...segments[0]);\n\n    // We have inserted parbreaks so some comments need to be told that there is a suffix parbreak\n    for (let i = 0; i < body.length - 1; i++) {\n        const node = body[i];\n        const nextNode = body[i + 1];\n        if (!match.parbreak(nextNode)) {\n            continue;\n        }\n        if (match.comment(node)) {\n            node.suffixParbreak = true;\n        }\n        // The heuristic for detecting an `item`-like node is that its last argument has no close mark.\n        // Regardless of what it is, if there is no close mark, when rendered we don't want two newlines to\n        // appear.\n        if (\n            match.macro(node) &&\n            node.args &&\n            node.args[node.args.length - 1].closeMark === \"\"\n        ) {\n            const args = node.args[node.args.length - 1].content;\n            const lastArg = args[args.length - 1];\n            if (match.comment(lastArg)) {\n                lastArg.suffixParbreak = true;\n            }\n        }\n    }\n\n    return body;\n}\n\n/**\n * Removes and returns any number of trailing comments/parbreaks from `nodes`.\n */\nfunction popTrailingComments(nodes: Ast.Node[]): Ast.Node[] {\n    let lastNodeIndex = lastSignificantNodeIndex(nodes, true);\n    if (\n        lastNodeIndex === nodes.length - 1 ||\n        (lastNodeIndex == null && nodes.length === 0)\n    ) {\n        return [];\n    }\n\n    // If `nodes` has a non-zero length and we didn't find a significant node, everything is comments!\n    if (lastNodeIndex == null) {\n        lastNodeIndex = -1;\n    }\n    return nodes.splice(lastNodeIndex + 1);\n}\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { cleanEnumerateBody } from \"../../utils/enumerate\";\n\nexport const macros: MacroInfoRecord = {\n    answerline: { signature: \"o\" },\n    fillin: { signature: \"o o\" },\n    fullwidth: { signature: \"m\" },\n    fillwidthlines: { signature: \"m\" },\n    fillwidthdottedlines: { signature: \"m\" },\n    fillwidthgrid: { signature: \"m\" },\n    makeemptybox: { signature: \"m\" },\n    CorrectChoiceEmphasis: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    SolutionEmphasis: { signature: \"m\", renderInfo: { breakAround: true } },\n    uplevel: { signature: \"m\", renderInfo: { breakAround: true } },\n    checkboxchar: { signature: \"m\", renderInfo: { breakAround: true } },\n    checkedchar: { signature: \"m\", renderInfo: { breakAround: true } },\n    pointname: { signature: \"m\", renderInfo: { breakAround: true } },\n    marginpointname: { signature: \"m\", renderInfo: { breakAround: true } },\n    extrawidth: { signature: \"m\", renderInfo: { breakAround: true } },\n    pointformat: { signature: \"m\", renderInfo: { breakAround: true } },\n    bonuspointformat: { signature: \"m\", renderInfo: { breakAround: true } },\n    totalformat: { signature: \"m\", renderInfo: { breakAround: true } },\n    qformat: { signature: \"m\", renderInfo: { breakAround: true } },\n    titledquestion: { signature: \"m o\", renderInfo: { breakAround: true } },\n    pointpoints: { signature: \"m m\", renderInfo: { breakAround: true } },\n    bonuspointpoints: { signature: \"m m\", renderInfo: { breakAround: true } },\n};\n\nexport const environments: EnvInfoRecord = {\n    choices: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\"),\n    },\n    checkboxes: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\"),\n    },\n    oneparchoices: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\"),\n    },\n    oneparcheckboxes: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\"),\n    },\n    parts: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"part\"),\n    },\n    subparts: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"subpart\"),\n    },\n    subsubparts: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"subsubpart\"),\n    },\n    questions: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"question\"),\n    },\n};\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    geometry: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    hypersetup: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    href: { signature: \"o m m\" },\n    url: { signature: \"m\" },\n    nolinkurl: { signature: \"m\" },\n    hyperbaseurl: { signature: \"m\" },\n    hyperimage: { signature: \"m m\" },\n    hyperdef: { signature: \"m m m\" },\n    hyperref: { signature: \"o m\" },\n    hyperlink: { signature: \"m m\" },\n    hypertarget: { signature: \"m m\" },\n    autoref: { signature: \"s m\" },\n    pageref: { signature: \"s m\" },\n    autopageref: { signature: \"s m\" },\n    pdfstringdef: { signature: \"m m\" },\n    pdfbookmark: { signature: \"o m m\" },\n    currentpdfbookmark: { signature: \"m m\" },\n    subpdfbookmark: { signature: \"m m\" },\n    belowpdfbookmark: { signature: \"m m\" },\n    texorpdfstring: { signature: \"m m\" },\n    thispdfpagelabel: { signature: \"m\" },\n    hypercalcbp: { signature: \"m\" },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\nimport { cleanEnumerateBody } from \"../../utils/enumerate\";\n\nexport const macros: MacroInfoRecord = {\n    // Special\n    \"\\\\\": { signature: \"!s !o\" },\n    _: { signature: \"m\", escapeToken: \"\" },\n    \"^\": { signature: \"m\", escapeToken: \"\" },\n    // \\newcommand arg signature from https://www.texdev.net/2020/08/19/the-good-the-bad-and-the-ugly-creating-document-commands\n    // List can be found in latex2e.pdf \"An unofficial reference manual\"\n    newcommand: {\n        signature: \"s +m o +o +m\",\n        renderInfo: {\n            breakAround: true,\n            namedArguments: [\"starred\", \"name\", \"numArgs\", \"default\", \"body\"],\n        },\n    },\n    renewcommand: {\n        signature: \"s +m o +o +m\",\n        renderInfo: {\n            breakAround: true,\n            namedArguments: [\"starred\", \"name\", \"numArgs\", \"default\", \"body\"],\n        },\n    },\n    providecommand: {\n        signature: \"s +m o +o +m\",\n        renderInfo: { breakAround: true },\n    },\n    // Counters\n    newcounter: {\n        signature: \"m o\",\n        renderInfo: { breakAround: true },\n    },\n    usecounter: {\n        signature: \"m\",\n    },\n    setcounter: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    addtocounter: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    stepcounter: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    refstepcounter: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    // Lengths\n    newlength: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    addtolength: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    settodepth: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    settoheight: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    settowidth: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    // Spaces\n    stretch: { signature: \"m\" },\n    hspace: { signature: \"s m\" },\n    vspace: { signature: \"s m\", renderInfo: { breakAround: true } },\n    vfill: { renderInfo: { breakAround: true } },\n    indent: { renderInfo: { breakAround: true } },\n    phantom: { signature: \"m\" },\n    vphantom: { signature: \"m\" },\n    hphantom: { signature: \"m\" },\n    noindent: { renderInfo: { breakAround: true } },\n    smallskip: { renderInfo: { breakAround: true } },\n    medskip: { renderInfo: { breakAround: true } },\n    bigskip: { renderInfo: { breakAround: true } },\n    smallbreak: { renderInfo: { breakAround: true } },\n    medbreak: { renderInfo: { breakAround: true } },\n    bigbreak: { renderInfo: { breakAround: true } },\n    newline: { renderInfo: { breakAround: true } },\n    linebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n    nolinebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n    clearpage: { renderInfo: { breakAround: true } },\n    cleardoublepage: { renderInfo: { breakAround: true } },\n    newpage: { renderInfo: { breakAround: true } },\n    enlargethispage: { signature: \"s\", renderInfo: { breakAround: true } },\n    pagebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n    nopagebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n    // Boxes\n    newsavebox: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    sbox: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    savebox: {\n        signature: \"m o o m\",\n        renderInfo: { breakAround: true },\n    },\n    mbox: { signature: \"m\" },\n    makebox: { signature: \"d() o o m\", renderInfo: { breakAround: true } },\n    fbox: { signature: \"m\" },\n    framebox: { signature: \"o o m\", renderInfo: { breakAround: true } },\n    frame: { signature: \"m\", renderInfo: { breakAround: true } },\n    parbox: { signature: \"o o o m m\", renderInfo: { breakAround: true } },\n    raisebox: { signature: \"m o o m\" },\n    marginpar: { signature: \"o m\", renderInfo: { breakAround: true } },\n    colorbox: { signature: \"o m m\", renderInfo: { breakAround: true } },\n    fcolorbox: { signature: \"o m m\", renderInfo: { breakAround: true } },\n    rotatebox: { signature: \"o m m\" },\n    scalebox: { signature: \"m o m\" },\n    reflectbox: { signature: \"m\" },\n    resizebox: { signature: \"s m m m\" },\n    // Define environments\n    newenvironment: {\n        signature: \"s m o o m m\",\n        renderInfo: { breakAround: true },\n    },\n    renewenvironment: {\n        signature: \"s m o o m m\",\n        renderInfo: { breakAround: true },\n    },\n    newtheorem: {\n        signature: \"s m o m o\",\n        renderInfo: { breakAround: true },\n    },\n    newfont: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    // Counters\n    alph: { signature: \"m\" },\n    Alph: { signature: \"m\" },\n    arabic: { signature: \"m\" },\n    roman: { signature: \"m\" },\n    Roman: { signature: \"m\" },\n    fnsymbol: { signature: \"m\" },\n    // Other\n    documentclass: {\n        signature: \"o m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    usepackage: {\n        signature: \"o m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    item: {\n        signature: \"o\",\n        renderInfo: { hangingIndent: true, namedArguments: [\"label\"] },\n    },\n    value: { signature: \"m\" },\n    centering: { renderInfo: { breakAround: true } },\n    input: { signature: \"m\", renderInfo: { breakAround: true } },\n    include: { signature: \"m\", renderInfo: { breakAround: true } },\n    includeonly: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    discretionary: { signature: \"m m m\" },\n    hyphenation: { signature: \"m m m\" },\n    footnote: { signature: \"o m\", renderInfo: { inParMode: true } },\n    footnotemark: { signature: \"o\" },\n    footnotetext: { signature: \"o m\", renderInfo: { inParMode: true } },\n    caption: {\n        signature: \"o m\",\n        renderInfo: { inParMode: true, breakAround: true },\n    },\n    // Math Commands\n    sqrt: { signature: \"o m\", renderInfo: { inMathMode: true } },\n    frac: { signature: \"m m\", renderInfo: { inMathMode: true } },\n    stackrel: { signature: \"m m\" },\n    ensuremath: { signature: \"m\", renderInfo: { inMathMode: true } },\n    // Layout commands\n    abstract: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    maketitle: { renderInfo: { breakAround: true } },\n    doublespacing: { renderInfo: { breakAround: true } },\n    singlespacing: { renderInfo: { breakAround: true } },\n    author: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    date: { signature: \"o m\", renderInfo: { breakAround: true } },\n    thanks: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    // amsart document class adds an optional argument\n    title: {\n        signature: \"o m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    pagenumbering: { signature: \"m\", renderInfo: { breakAround: true } },\n    pagestyle: { signature: \"m\", renderInfo: { breakAround: true } },\n    thispagestyle: { signature: \"m\", renderInfo: { breakAround: true } },\n    // Colors\n    definecolor: { signature: \"m m m\", renderInfo: { breakAround: true } },\n    pagecolor: { signature: \"o m\", renderInfo: { breakAround: true } },\n    nopagecolor: { renderInfo: { breakAround: true } },\n    multicolumn: { signature: \"m m m\" },\n    // Graphics\n    includegraphics: {\n        signature: \"s o o m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    rule: { signature: \"o m m\" },\n    // Sectioning\n    part: {\n        signature: \"s o m\",\n        renderInfo: {\n            breakAround: true,\n            inParMode: true,\n            namedArguments: [\"starred\", \"tocTitle\", \"title\"],\n        },\n    },\n    chapter: {\n        signature: \"s o m\",\n        renderInfo: {\n            breakAround: true,\n            inParMode: true,\n            namedArguments: [\"starred\", \"tocTitle\", \"title\"],\n        },\n    },\n    section: {\n        signature: \"s o m\",\n        renderInfo: {\n            breakAround: true,\n            inParMode: true,\n            namedArguments: [\"starred\", \"tocTitle\", \"title\"],\n        },\n    },\n    subsection: {\n        signature: \"s o m\",\n        renderInfo: {\n            breakAround: true,\n            inParMode: true,\n            namedArguments: [\"starred\", \"tocTitle\", \"title\"],\n        },\n    },\n    subsubsection: {\n        signature: \"s o m\",\n        renderInfo: {\n            breakAround: true,\n            inParMode: true,\n            namedArguments: [\"starred\", \"tocTitle\", \"title\"],\n        },\n    },\n    paragraph: {\n        signature: \"s o m\",\n        renderInfo: {\n            breakAround: true,\n            inParMode: true,\n            namedArguments: [\"starred\", \"tocTitle\", \"title\"],\n        },\n    },\n    subparagraph: {\n        signature: \"s o m\",\n        renderInfo: {\n            breakAround: true,\n            inParMode: true,\n            namedArguments: [\"starred\", \"tocTitle\", \"title\"],\n        },\n    },\n    appendix: { renderInfo: { breakAround: true, inParMode: true } },\n    frontmatter: { renderInfo: { breakAround: true, inParMode: true } },\n    mainmatter: { renderInfo: { breakAround: true, inParMode: true } },\n    backmatter: { renderInfo: { breakAround: true, inParMode: true } },\n    // Citing and references\n    bibitem: { signature: \"o m\", renderInfo: { hangingIndent: true } },\n    cite: { signature: \"o m\" },\n    // Fonts\n    textrm: { signature: \"m\", renderInfo: { inParMode: true } },\n    textit: { signature: \"m\", renderInfo: { inParMode: true } },\n    textmd: { signature: \"m\", renderInfo: { inParMode: true } },\n    textbf: { signature: \"m\", renderInfo: { inParMode: true } },\n    textup: { signature: \"m\", renderInfo: { inParMode: true } },\n    textsl: { signature: \"m\", renderInfo: { inParMode: true } },\n    textsf: { signature: \"m\", renderInfo: { inParMode: true } },\n    textsc: { signature: \"m\", renderInfo: { inParMode: true } },\n    texttt: { signature: \"m\", renderInfo: { inParMode: true } },\n    emph: { signature: \"m\", renderInfo: { inParMode: true } },\n    textnormal: { signature: \"m\", renderInfo: { inParMode: true } },\n    uppercase: { signature: \"m\", renderInfo: { inParMode: true } },\n    mathbf: { signature: \"m\" },\n    mathsf: { signature: \"m\" },\n    mathtt: { signature: \"m\" },\n    mathit: { signature: \"m\" },\n    mathnormal: { signature: \"m\" },\n    mathcal: { signature: \"m\" },\n    mathrm: { signature: \"m\" },\n    // Other\n    setlength: { signature: \"m m\", renderInfo: { breakAround: true } },\n    ref: { signature: \"s m\" },\n    label: { signature: \"o m\" }, // cleveref changes \\label to have this signature\n    printbibliography: { renderInfo: { breakAround: true } },\n    addtocontents: { signature: \"m m\", renderInfo: { breakAround: true } },\n    addcontentsline: { signature: \"m m m\", renderInfo: { breakAround: true } },\n    contentsline: { signature: \"m m m\", renderInfo: { breakAround: true } },\n    bibliography: { signature: \"m\", renderInfo: { breakAround: true } },\n    bibliographystyle: { signature: \"m\", renderInfo: { breakAround: true } },\n};\n\nexport const environments: EnvInfoRecord = {\n    document: {\n        processContent: (nodes) => {\n            trim(nodes);\n            return nodes;\n        },\n    },\n    array: { signature: \"o m\", renderInfo: { alignContent: true } },\n    description: { signature: \"o\", processContent: cleanEnumerateBody },\n    enumerate: {\n        signature: \"o\",\n        processContent: cleanEnumerateBody,\n        renderInfo: { pgfkeysArgs: true },\n    },\n    itemize: { signature: \"o\", processContent: cleanEnumerateBody },\n    trivlist: { signature: \"o\", processContent: cleanEnumerateBody },\n    list: { signature: \"m m\", processContent: cleanEnumerateBody },\n    figure: { signature: \"o\" },\n    \"figure*\": { signature: \"o\" },\n    filecontents: { signature: \"o m\" },\n    \"filecontents*\": { signature: \"o m\" },\n    minipage: { signature: \"o o o m\" },\n    picture: { signature: \"r() d()\" },\n    tabbing: { renderInfo: { alignContent: true } },\n    table: { signature: \"o\" },\n    tabular: { signature: \"o m\", renderInfo: { alignContent: true } },\n    \"tabular*\": { signature: \"m o m\", renderInfo: { alignContent: true } },\n    thebibliography: {\n        signature: \"m\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"bibitem\"),\n    },\n    // Math\n    math: { renderInfo: { inMathMode: true } },\n};\n", "import { arg } from \"@unified-latex/unified-latex-builder\";\nimport { Argument, ArgumentParser } from \"@unified-latex/unified-latex-types\";\nimport { parse as parseArgspec } from \"@unified-latex/unified-latex-util-argspec\";\nimport { Node } from \"@unified-latex/unified-latex-util-argspec/libs/argspec-types\";\nimport { gobbleSingleArgument } from \"@unified-latex/unified-latex-util-arguments\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\nconst argSpecM = parseArgspec(\"m\")[0];\nconst argSpecO = parseArgspec(\"o\")[0];\nconst argSpecRDelim: { [delim: string]: Node } = {};\n\n/**\n * This argument parser parses arguments in the form of\n * - [\u27E8key=value list\u27E9]\u27E8character\u27E9\u27E8source code\u27E9\u27E8same character\u27E9\n * - [\u27E8key=value list\u27E9]{\u27E8source code\u27E9}\n */\nexport const argumentParser: ArgumentParser = (nodes, startPos) => {\n    const { argument: optionalArg, nodesRemoved: optionalArgNodesRemoved } =\n        gobbleSingleArgument(nodes, argSpecO, startPos);\n\n    let codeArg: Argument | null = null;\n    let codeArgNodesRemoved: number = 0;\n    const nextNode = nodes[startPos];\n    if (match.group(nextNode)) {\n        const mandatoryArg = gobbleSingleArgument(nodes, argSpecM, startPos);\n        codeArg = mandatoryArg.argument;\n        codeArgNodesRemoved = mandatoryArg.nodesRemoved;\n    } else if (match.string(nextNode) && nextNode.content.length === 1) {\n        const delim = nextNode.content;\n        argSpecRDelim[delim] =\n            argSpecRDelim[delim] || parseArgspec(`r${delim}${delim}`)[0];\n        const delimArg = gobbleSingleArgument(\n            nodes,\n            argSpecRDelim[delim],\n            startPos\n        );\n        codeArg = delimArg.argument;\n        codeArgNodesRemoved = delimArg.nodesRemoved;\n    }\n\n    return {\n        args: [optionalArg || arg(null), codeArg || arg(null)],\n        nodesRemoved: optionalArgNodesRemoved + codeArgNodesRemoved,\n    };\n};\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport { argumentParser } from \"./libs/argument-parser\";\n\nexport const macros: MacroInfoRecord = {\n    lstset: { signature: \"m\" },\n    lstinline: { argumentParser: argumentParser },\n    lstinputlisting: { signature: \"o m\" },\n    lstdefinestyle: { signature: \"m m\" },\n    lstnewenvironment: { signature: \"m o o m m\" },\n    lstMakeShortInline: { signature: \"o m\" },\n    lstDeleteShortInline: { signature: \"m\" },\n    lstdefineformat: { signature: \"m m\" },\n    lstdefinelanguage: { signature: \"o m o m o\" },\n    lstalias: { signature: \"o m o m\" },\n    lstloadlanguages: { signature: \"m\" },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    see: { signature: \"m m\" },\n    seealso: { signature: \"m m\" },\n    seename: { signature: \"m\" },\n    alsoname: { signature: \"m\" },\n    index: { signature: \"m\" },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    mathtoolsset: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    mathllap: {\n        signature: \"o m\",\n    },\n    mathrlap: {\n        signature: \"o m\",\n    },\n    mathclap: {\n        signature: \"o m\",\n    },\n    clap: {\n        signature: \"m\",\n    },\n    mathmbox: {\n        signature: \"m\",\n    },\n    mathmakebox: {\n        signature: \"o o m\",\n    },\n    cramped: {\n        signature: \"o m\",\n    },\n    crampedllap: {\n        signature: \"o m\",\n    },\n    crampedrlap: {\n        signature: \"o m\",\n    },\n    crampedclap: {\n        signature: \"o m\",\n    },\n    crampedsubstack: {\n        signature: \"o m\",\n    },\n    smashoperator: {\n        signature: \"o m\",\n    },\n    newtagform: {\n        signature: \"m o m m\",\n    },\n    renewtagform: {\n        signature: \"m o m m\",\n    },\n    usetagform: {\n        signature: \"m\",\n    },\n    xleftrightarrow: { signature: \"o m\" },\n    xLeftarrow: { signature: \"o m\" },\n    xhookleftarrow: { signature: \"o m\" },\n    xmapsto: { signature: \"o m\" },\n    xRightarrow: { signature: \"o m\" },\n    xLeftrightarrow: { signature: \"o m\" },\n    xhookrightarrow: { signature: \"o m\" },\n    underbracket: { signature: \"o o m\" },\n    overbracket: { signature: \"o o m\" },\n    underbrace: { signature: \"m\" },\n    overbrace: { signature: \"m\" },\n    shoveleft: { signature: \"o m\" },\n    shoveright: { signature: \"o m\" },\n    ArrowBetweenLines: { signature: \"s o\" },\n    vdotswithin: { signature: \"m\" },\n    shortdotswithin: { signature: \"s m\" },\n    DeclarePairedDelimiter: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    DeclarePairedDelimiterX: {\n        signature: \"m o m m m\",\n        renderInfo: { breakAround: true },\n    },\n    DeclarePairedDelimiterXPP: {\n        signature: \"m o m m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    prescript: { signature: \"m m m\" },\n    DeclareMathSizes: { signature: \"m m m m\" },\n    newgathered: { signature: \"m m m m\" },\n    renewgathered: { signature: \"m m m m\" },\n    splitfrac: { signature: \"m m\" },\n    splitdfrac: { signature: \"m m\" },\n    xmathstrut: { signature: \"o m\" },\n    // amsthm\n    newtheorem: { signature: \"s m o m o\", renderInfo: { breakAround: true } },\n    theoremstyle: { signature: \"m\", renderInfo: { breakAround: true } },\n    newtheoremstyle: {\n        signature: \"m m m m m m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    // amsmath\n    text: { signature: \"m\", renderInfo: { inMathMode: false } },\n    // amsfonts\n    mathbb: { signature: \"m\" },\n    mathscr: { signature: \"m\" },\n    mathfrak: { signature: \"m\" },\n    frak: { signature: \"m\" },\n    Bdd: { signature: \"m\" },\n    bold: { signature: \"m\" },\n    // amsopn\n    operatorname: { signature: \"s m\" },\n    DeclareMathOperator: {\n        signature: \"s m m\",\n        renderInfo: { breakAround: true },\n    },\n};\n\nexport const environments: EnvInfoRecord = {\n    crampedsubarray: {\n        signature: \"m\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    matrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    bmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    pmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    vmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    Bmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    Vmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    smallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    psmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    vsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    bsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    Bsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    Vsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    \"matrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"bmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"pmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"vmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"Bmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"Vmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"smallmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"psmallmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"bsmallmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"vsmallmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"Bsmallmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"Vsmallmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    multilined: { signature: \"o o\", renderInfo: { inMathMode: true } },\n    cases: { renderInfo: { alignContent: true, inMathMode: true } },\n    \"cases*\": { renderInfo: { alignContent: true, inMathMode: true } },\n    dcases: { renderInfo: { alignContent: true, inMathMode: true } },\n    \"dcases*\": { renderInfo: { alignContent: true, inMathMode: true } },\n    rcases: { renderInfo: { alignContent: true, inMathMode: true } },\n    \"rcases*\": { renderInfo: { alignContent: true, inMathMode: true } },\n    drcases: { renderInfo: { alignContent: true, inMathMode: true } },\n    \"drcases*\": { renderInfo: { alignContent: true, inMathMode: true } },\n    spreadlines: { signature: \"m\", renderInfo: { inMathMode: true } },\n    lgathered: { signature: \"o\", renderInfo: { inMathMode: true } },\n    rgathered: { signature: \"o\", renderInfo: { inMathMode: true } },\n    // amsmath\n    \"align*\": { renderInfo: { inMathMode: true, alignContent: true } },\n    align: { renderInfo: { inMathMode: true, alignContent: true } },\n    aligned: { renderInfo: { inMathMode: true, alignContent: true } },\n    \"alignat*\": { renderInfo: { inMathMode: true, alignContent: true } },\n    alignat: { renderInfo: { inMathMode: true, alignContent: true } },\n    \"equation*\": { renderInfo: { inMathMode: true } },\n    equation: { renderInfo: { inMathMode: true } },\n    \"gather*\": { renderInfo: { inMathMode: true } },\n    gather: { renderInfo: { inMathMode: true } },\n    \"multline*\": { renderInfo: { inMathMode: true } },\n    multline: { renderInfo: { inMathMode: true } },\n    \"flalign*\": { renderInfo: { inMathMode: true, alignContent: true } },\n    flalign: { renderInfo: { inMathMode: true, alignContent: true } },\n    split: { renderInfo: { inMathMode: true } },\n    // Math environments\n    displaymath: { renderInfo: { inMathMode: true } },\n    // Typical amsthm environments\n    theorem: { signature: \"o\" },\n    lemma: { signature: \"o\" },\n    definition: { signature: \"o\" },\n    proposition: { signature: \"o\" },\n    corollary: { signature: \"o\" },\n    remark: { signature: \"!o\" },\n    example: { signature: \"!o\" },\n    proof: { signature: \"o\" },\n};\n", "import { arg } from \"@unified-latex/unified-latex-builder\";\nimport { Argument, ArgumentParser } from \"@unified-latex/unified-latex-types\";\nimport { parse as parseArgspec } from \"@unified-latex/unified-latex-util-argspec\";\nimport { Node } from \"@unified-latex/unified-latex-util-argspec/libs/argspec-types\";\nimport { gobbleSingleArgument } from \"@unified-latex/unified-latex-util-arguments\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\nconst argSpecM = parseArgspec(\"m\")[0];\nconst argSpecO = parseArgspec(\"o\")[0];\nconst argSpecRDelim: { [delim: string]: Node } = {};\n\n/**\n * This argument parser parses arguments in the form of\n * - [\u27E8options\u27E9]{\u27E8language\u27E9}\u27E8delim\u27E9\u27E8code\u27E9\u27E8delim\u27E9\n * - [\u27E8options\u27E9]{\u27E8language\u27E9}{\u27E8code\u27E9}\n */\nexport const argumentParser: ArgumentParser = (nodes, startPos) => {\n    const { argument: optionalArg, nodesRemoved: optionalArgNodesRemoved } =\n        gobbleSingleArgument(nodes, argSpecO, startPos);\n\n    const { argument: languageArg, nodesRemoved: languageArgNodesRemoved } =\n        gobbleSingleArgument(nodes, argSpecM, startPos);\n\n    let codeArg: Argument | null = null;\n    let codeArgNodesRemoved: number = 0;\n    const nextNode = nodes[startPos];\n    if (match.group(nextNode)) {\n        const mandatoryArg = gobbleSingleArgument(nodes, argSpecM, startPos);\n        codeArg = mandatoryArg.argument;\n        codeArgNodesRemoved = mandatoryArg.nodesRemoved;\n    } else if (match.string(nextNode) && nextNode.content.length === 1) {\n        const delim = nextNode.content;\n        argSpecRDelim[delim] =\n            argSpecRDelim[delim] || parseArgspec(`r${delim}${delim}`)[0];\n        const delimArg = gobbleSingleArgument(\n            nodes,\n            argSpecRDelim[delim],\n            startPos\n        );\n        codeArg = delimArg.argument;\n        codeArgNodesRemoved = delimArg.nodesRemoved;\n    }\n\n    return {\n        args: [\n            optionalArg || arg(null),\n            languageArg || arg(null),\n            codeArg || arg(null),\n        ],\n        nodesRemoved:\n            optionalArgNodesRemoved +\n            languageArgNodesRemoved +\n            codeArgNodesRemoved,\n    };\n};\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport { argumentParser } from \"./libs/argument-parser\";\n\nexport const macros: MacroInfoRecord = {\n    mint: { argumentParser: argumentParser },\n    mintinline: { argumentParser: argumentParser },\n    inputminted: { argumentParser: argumentParser },\n    usemintedstyle: { signature: \"m\" },\n    setminted: { signature: \"o m\" },\n    setmintedinline: { signature: \"o m\" },\n    newmint: { signature: \"o m m\" },\n    newminted: { signature: \"o m m\" },\n    newmintinline: { signature: \"o m m\" },\n    newmintedfile: { signature: \"o m m\" },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    NiceMatrixOptions: {\n        signature: \"m\",\n        renderInfo: { pgfkeysArgs: true, breakAround: true },\n    },\n};\n\nexport const environments: EnvInfoRecord = {\n    NiceTabular: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    NiceMatrixBlock: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    NiceArrayWithDelims: {\n        signature: \"m m o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    NiceArray: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    pNiceArray: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    bNiceArray: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    BNiceArray: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    vNiceArray: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    VNiceArray: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    NiceMatrix: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    pNiceMatrix: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    bNiceMatrix: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    BNiceMatrix: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    vNiceMatrix: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    VNiceMatrix: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n};\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    systeme: {\n        signature: \"s o o m\",\n        renderInfo: { inMathMode: true },\n    },\n    sysdelim: {\n        signature: \"m m\",\n    },\n    syseqsep: { signature: \"m\" },\n    sysalign: { signature: \"m\" },\n    syssignspace: { signature: \"m\" },\n    syseqspace: { signature: \"m\" },\n    syslineskipcoeff: { signature: \"m\" },\n    syseqivsign: { signature: \"m\" },\n    sysaddeqsign: { signature: \"m\" },\n    sysremoveeqsign: { signature: \"m\" },\n    sysextracolonsign: { signature: \"m\" },\n    syscodeextracol: { signature: \"m\" },\n    sysautonum: { signature: \"m\" },\n    syssubstitute: { signature: \"m\" },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as SystemeSpec from \"./types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { decorateArrayForPegjs } from \"@unified-latex/unified-latex-util-pegjs\";\nimport { SystemePegParser } from \"@unified-latex/unified-latex-util-pegjs\";\n\ntype SystemeMatchers = {\n    at?: string;\n    equals?: string;\n    equationSeparator?: string;\n    mathOperations?: string[];\n    whitelistedVariables?: (string | Ast.String | Ast.Macro)[];\n};\n\nfunction createMatchers({\n    at = \"@\",\n    equals = \"=\",\n    equationSeparator = \",\",\n    mathOperations = [\"+\", \"-\"],\n    whitelistedVariables,\n}: SystemeMatchers = {}) {\n    let isVar: (node: Ast.Node) => boolean = (node: Ast.Node) =>\n        match.anyString(node) && !!node.content.match(/[a-zA-Z]/);\n    if (whitelistedVariables) {\n        // Unwrap all strings\n        whitelistedVariables = whitelistedVariables.map((v) =>\n            match.anyString(v) ? v.content : v\n        );\n        const macros = whitelistedVariables.filter((v) =>\n            match.anyMacro(v)\n        ) as Ast.Macro[];\n        const strings = whitelistedVariables.filter(\n            (v) => typeof v === \"string\"\n        ) as string[];\n        const macroHash = Object.fromEntries(macros.map((v) => [v.content, v]));\n        const stringHash = Object.fromEntries(strings.map((s) => [s, s]));\n        const macroMatcher = match.createMacroMatcher(macroHash);\n        isVar = (node: Ast.Node) =>\n            macroMatcher(node) ||\n            (match.anyString(node) && !!stringHash[node.content]);\n    }\n    return {\n        isSep: (node: Ast.Node) => match.string(node, equationSeparator),\n        isVar,\n        isOperation: (node: Ast.Node) =>\n            mathOperations.some((op) => match.string(node, op)),\n        isEquals: (node: Ast.Node) => match.string(node, equals),\n        isAt: (node: Ast.Node) => match.string(node, at),\n        isSubscript: (node: Ast.Node) =>\n            match.macro(node, \"_\") && node.escapeToken === \"\",\n        isWhitespace: match.whitespace,\n        isSameLineComment: (node: Ast.Node) =>\n            match.comment(node) && node.sameline,\n        isOwnLineComment: (node: Ast.Node) =>\n            match.comment(node) && !node.sameline,\n    };\n}\n\n/**\n * Parse the contents of the `\\systeme{...}` macro\n */\nexport function parse(\n    ast: Ast.Node[],\n    options?: SystemeMatchers\n): SystemeSpec.Line[] {\n    if (!Array.isArray(ast)) {\n        throw new Error(\"You must pass an array of nodes\");\n    }\n    // We need to at functions to `nodes` so that it imitates\n    // a Javascript string. Because we're mutating, make a copy first\n    ast = decorateArrayForPegjs([...ast]);\n    // matchers are passed in via the second argument (the `options` argument)\n    // so they are available from within the Pegjs grammar.\n    return SystemePegParser.parse(\n        ast,\n        createMatchers(options || {})\n    ) as SystemeSpec.Line[];\n}\n", "import { printRaw as latexPrintRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport * as SystemeSpec from \"./types\";\n\n/**\n * Print an `systeme` argument specification AST to a string.\n */\nexport function printRaw(node: SystemeSpec.Ast, root = false): string {\n    if (typeof node === \"string\") {\n        return node;\n    }\n\n    if (Array.isArray(node)) {\n        const sepToken = root ? \" \" : \"\";\n        return node.map((tok) => printRaw(tok)).join(sepToken);\n    }\n\n    switch (node.type) {\n        case \"annotation\":\n            return `${latexPrintRaw(node.marker)}${latexPrintRaw(\n                node.content\n            )}`;\n        case \"item\":\n            return `${node.op ? latexPrintRaw(node.op) : \"\"}${latexPrintRaw(\n                node.content\n            )}`;\n        case \"equation\":\n            const left = node.left.map((n) => printRaw(n)).join(\"\");\n            const right = latexPrintRaw(node.right);\n            const equals = node.equals ? latexPrintRaw(node.equals) : \"\";\n            return `${left}${equals}${right}`;\n        case \"line\":\n            const equation = node.equation ? printRaw(node.equation) : \"\";\n            const annotation = node.annotation ? printRaw(node.annotation) : \"\";\n            const sep = node.sep ? latexPrintRaw(node.sep) : \"\";\n\n            const body = `${equation}${annotation}${sep}`;\n            if (node.trailingComment) {\n                return latexPrintRaw([body, node.trailingComment]);\n            }\n\n            return body;\n\n        default:\n            console.warn(\n                `Unknown node type \"${(node as any).type}\" for node`,\n                node\n            );\n            return \"\";\n    }\n}\n", "import * as SystemeSpec from \"./types\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { arrayJoin } from \"@unified-latex/unified-latex-util-split\";\nimport { parse } from \"./parser\";\nimport { structuredClone } from \"@unified-latex/structured-clone\";\nimport { deleteComments } from \"@unified-latex/unified-latex-util-comments\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\nimport { getArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\n\nconst AMP: Ast.String = { type: \"string\", content: \"&\" };\nconst SEP: Ast.Macro = { type: \"macro\", content: \"\\\\\" };\nconst QUAD: Ast.Macro = { type: \"macro\", content: \"quad\" };\nconst PLUS: Ast.String = { type: \"string\", content: \"+\" };\nconst COLUMN_KERN_ADJUSTMENT: Ast.Node[] = [\n    { type: \"string\", content: \"@\" },\n    {\n        type: \"group\",\n        content: [\n            { type: \"macro\", content: \"mkern\" },\n            { type: \"string\", content: \"5mu\" },\n        ],\n    },\n];\n\n/**\n * Return a map giving the sorted index of each variable in `vars`. There\n * may be duplicated variables in `vars`. The map will send duplicates to the same index.\n *\n * @param {Ast.Node[][]} vars\n * @returns\n */\nfunction sortVariables(\n    vars: Ast.Node[][],\n    whitelistedVariables?: Ast.Node[] | null\n) {\n    const varMap = new Map(vars.map((v) => [v, printRaw(v)]));\n    const varNames = Array.from(new Set(varMap.values()));\n    varNames.sort();\n    const nameToPos = whitelistedVariables\n        ? new Map(whitelistedVariables.map((v, i) => [printRaw(v), i]))\n        : new Map(varNames.map((name, i) => [name, i]));\n\n    return new Map(\n        Array.from(varMap.entries()).map(([variable, name]) => {\n            return [variable, nameToPos.get(name) ?? -1];\n        })\n    );\n}\n\n/**\n * Make an array of arrays representing the operation/content of each item in an equation\n * + the annotation. The return value is suitable to be joined with `&` for the body of an array.\n */\nfunction processLine(\n    line: SystemeSpec.Line,\n    numVars: number,\n    varOrder: Map<Ast.Node[], number>,\n    hasEquals: boolean,\n    hasAnnotation: boolean\n) {\n    const ret: Ast.Node[][] = [];\n    if (line.equation) {\n        // We need to combine all non-var items into a single expression\n        const nonVarItems = line.equation.left.filter(\n            (item) => item.variable == null\n        );\n        const varItems = line.equation.left.filter(\n            (item) => item.variable != null\n        );\n        let nonVarTerm: SystemeSpec.Item | null = null;\n        if (nonVarItems.length === 1) {\n            nonVarTerm = nonVarItems[0];\n        } else if (nonVarItems.length > 1) {\n            // We need to combine all the items. We do so by constructing a new item with the rest of the item's contents\n            // added on the back\n            nonVarTerm = {\n                ...nonVarItems[0],\n                content: nonVarItems[0].content.concat(\n                    nonVarItems.slice(1).flatMap((item) => {\n                        if (item.op) {\n                            return [item.op, ...item.content];\n                        }\n                        return [PLUS, ...item.content];\n                    })\n                ),\n            };\n        }\n\n        const allItems = nonVarTerm ? varItems.concat(nonVarTerm) : varItems;\n\n        const indexToItem = new Map(\n            allItems.map((item) => {\n                if (item.variable == null) {\n                    return [numVars - 1, item];\n                }\n                return [varOrder.get(item.variable), item];\n            })\n        );\n\n        let isFirstItem = true;\n        for (let i = 0; i < numVars; i++) {\n            const item = indexToItem.get(i);\n            if (item) {\n                if (\n                    isFirstItem &&\n                    (match.string(item.op, \"+\") || item.op == null)\n                ) {\n                    // If the first item starts with a plus or doesn't have a starting operation,\n                    // we don't use a starting symbol.\n                    ret.push([]);\n                    ret.push(item.content);\n                } else {\n                    // If we are not the first item, we always push an operation\n                    ret.push([item.op || PLUS]);\n                    ret.push(item.content);\n                }\n                isFirstItem = false;\n            } else {\n                // If there is no item for this position, we push a blank operation and content\n                ret.push([]);\n                ret.push([]);\n            }\n        }\n        // If we have an equals, we need to push its contents\n        if (hasEquals) {\n            const equalsPart = (\n                line.equation.equals ? [line.equation.equals] : []\n            ).concat(line.equation.right);\n            ret.push(equalsPart);\n        }\n    }\n    // If we have an annotation, we need to push it or a blank\n    if (hasAnnotation) {\n        ret.push(line.annotation ? line.annotation.content : []);\n    }\n\n    return ret;\n}\n\n/**\n * Add kerning information to the array specification. E.g. `crl` becomes `c@{\\mkern5mu}r@{\\mkern5mu}l`.\n * This is so the operations when typesetting a system of equations are properly spaced.\n */\nfunction arraySpecToSpacedArraySpec(spec: string, hasAnnotation?: boolean) {\n    const annotationSpec = hasAnnotation ? spec.charAt(spec.length - 1) : \"\";\n    const bodySpec = hasAnnotation ? spec.slice(0, spec.length - 1) : spec;\n\n    const bodyStrings: Ast.Node[][] = Array.from(bodySpec).map((x) => [\n        { type: \"string\", content: x },\n    ]);\n    const body = arrayJoin(bodyStrings, COLUMN_KERN_ADJUSTMENT);\n    return annotationSpec\n        ? body.concat({ type: \"string\", content: annotationSpec })\n        : body;\n}\n\n/**\n * Extract the variables from a systeme system of equations.\n */\nexport function extractVariables(nodes: SystemeSpec.Node[]): Ast.Node[][] {\n    return nodes.flatMap((node) => {\n        if (node.type === \"line\" && node.equation) {\n            return extractVariables(node.equation.left);\n        }\n        if (node.type === \"equation\") {\n            return node.left.flatMap((item) =>\n                item.variable ? [item.variable] : []\n            );\n        }\n        if (node.type === \"item\") {\n            return node.variable ? [node.variable] : [];\n        }\n        return [];\n    });\n}\n\n/**\n * Remove any whitespace from the variable list (including an explicit \" \" string).\n * As well, filter out any non-macro/non-string items.\n */\nfunction normalizeVariableWhitelist(\n    vars: (string | Ast.Node)[] | null | undefined\n) {\n    if (!vars) {\n        return null;\n    }\n    const normalized: Ast.Node[] = vars.map((v) =>\n        typeof v === \"string\" ? { type: \"string\", content: v } : v\n    );\n    const ret = normalized.filter(\n        (v) =>\n            (match.anyMacro(v) || match.anyString(v)) &&\n            !match.string(v, \" \") &&\n            !match.whitespace(v)\n    ) as (Ast.Macro | Ast.String)[];\n    return ret;\n}\n\n/**\n * Lays out the contents of a \\systeme{...} macro as an array. This function sorts the variables\n * in alphabetical order and lays out any annotations. An `\\begin{array}...\\end{array}` environment\n * is returned.\n *\n * If `properSpacing=true` then kerning information will be included in the array specification to space\n * the operators correctly. This kerning information will make the specification long (and may make it incompatible\n * with KaTeX).\n *\n * An optional whitelist of variables may be supplied. If supplied, only listed items will count as variables and\n * the order of variable appearance will be the same as the order of the whitelisted variables.\n */\nexport function systemeContentsToArray(\n    nodes: Ast.Node[],\n    options?: {\n        properSpacing?: boolean;\n        whitelistedVariables?: (string | Ast.String | Ast.Macro)[];\n    }\n) {\n    nodes = structuredClone(nodes);\n    deleteComments(nodes);\n    const { properSpacing = true, whitelistedVariables } = options || {};\n    const coercedWhitelistedVariables =\n        normalizeVariableWhitelist(whitelistedVariables);\n    const systemeAst = parse(nodes, { whitelistedVariables });\n    const vars = extractVariables(systemeAst);\n    const varOrder = sortVariables(vars, coercedWhitelistedVariables);\n    let numVars = coercedWhitelistedVariables\n        ? coercedWhitelistedVariables.length\n        : Math.max(...Array.from(varOrder.values())) + 1;\n    // If there are terms with no variable, we need a spot for them\n    if (\n        systemeAst.some((line) => {\n            if (line.equation) {\n                return line.equation.left.some((item) => item.variable == null);\n            }\n        })\n    ) {\n        numVars += 1;\n    }\n    const hasEquals = systemeAst.some(\n        (line) => line.equation && line.equation.equals\n    );\n    const hasAnnotation = systemeAst.some((line) => line.annotation);\n\n    let rows = systemeAst.map((line) =>\n        processLine(line, numVars, varOrder, hasEquals, hasAnnotation)\n    );\n    // If we have no leading `-` signs (e.g., only leading `+` or bank signs)\n    // We don't need space for the first operation to be stored\n    const noLeadingOperation = rows.every((row) => row[0].length === 0);\n\n    // Every item in an equation has a centered operation and a right-aligned variable part.\n    let arraySignature = Array.from({ length: numVars }, () => \"cr\").join(\"\");\n    if (noLeadingOperation) {\n        // We might not have a leading operation on the first item(s)\n        arraySignature = arraySignature.slice(1);\n        rows = rows.map((row) => row.slice(1));\n    }\n    if (hasEquals) {\n        // The part after the equals is left-aligned\n        arraySignature += \"l\";\n    }\n    if (hasAnnotation) {\n        // The annotation is left-aligned\n        arraySignature += \"l\";\n        // We also manually insert space in front of any annotation\n        rows = rows.map((row) => {\n            if (row[row.length - 1].length === 0) {\n                return row;\n            }\n            return [\n                ...row.slice(0, row.length - 1),\n                [QUAD, { type: \"whitespace\" }, ...row[row.length - 1]],\n            ];\n        });\n    }\n\n    // By default, the array signature will put lots of space between items.\n    // We can correct for that manually.\n    const arraySignatureWithSpacing: Ast.Node[] = properSpacing\n        ? arraySpecToSpacedArraySpec(arraySignature, hasAnnotation)\n        : [{ type: \"string\", content: arraySignature }];\n\n    const bodyRows = rows.map((row) => arrayJoin(row, AMP));\n    const body = arrayJoin(bodyRows, SEP);\n\n    const ret: Ast.Environment = {\n        type: \"environment\",\n        env: \"array\",\n        args: [\n            {\n                type: \"argument\",\n                openMark: \"{\",\n                closeMark: \"}\",\n                content: arraySignatureWithSpacing,\n            },\n        ],\n        content: body,\n    };\n\n    return ret;\n}\n\n/**\n * Find any systeme definitions, e.g. `\\sysdelim{.}{.}`, and attach their information\n * to the renderInfo of of the systeme macros.\n *\n */\nexport function attachSystemeSettingsAsRenderInfo(ast: Ast.Ast) {\n    const systemeMatcher = match.createMacroMatcher([\"systeme\", \"sysdelim\"]);\n\n    visit(\n        ast,\n        (nodes, info) => {\n            if (!info.context.inMathMode || !nodes.some(systemeMatcher)) {\n                return;\n            }\n            // Find the positions of the systeme and sysdelim macros\n            const systemeLocations = nodes.flatMap((node, i) =>\n                match.macro(node, \"systeme\") ? i : []\n            );\n            const sysdelimLocations = nodes.flatMap((node, i) =>\n                match.macro(node, \"sysdelim\") ? i : []\n            );\n\n            if (\n                systemeLocations.length === 0 ||\n                sysdelimLocations.length === 0\n            ) {\n                return;\n            }\n\n            for (const i of systemeLocations) {\n                // Find any sysdelim macros that occur before\n                const lastSysdelim = Math.max(\n                    ...sysdelimLocations.filter((loc) => loc < i)\n                );\n                if (lastSysdelim >= 0) {\n                    const node = nodes[i];\n                    const sysdelimMacro = nodes[lastSysdelim];\n                    if (!match.anyMacro(sysdelimMacro)) {\n                        throw new Error(\n                            `Expecting sysdelim macro but found \"${printRaw(\n                                sysdelimMacro\n                            )}\"`\n                        );\n                    }\n                    const args = getArgsContent(sysdelimMacro);\n                    updateRenderInfo(node, { sysdelims: args });\n                }\n            }\n        },\n        {\n            test: Array.isArray,\n            includeArrays: true,\n        }\n    );\n}\n", "// @ts-nocheck\n\n// globalThis polyfill from https://mathiasbynens.be/notes/globalthis\n(function () {\n    if (typeof globalThis === \"object\") return;\n    Object.defineProperty(Object.prototype, \"__magic__\", {\n        get: function () {\n            return this;\n        },\n        configurable: true, // This makes it possible to `delete` the getter later.\n    });\n    __magic__.globalThis = __magic__; // lolwat\n    delete Object.prototype.__magic__;\n})();\n\nconst clone =\n    typeof globalThis.structuredClone === \"function\"\n        ? globalThis.structuredClone\n        : (obj: any) => JSON.parse(JSON.stringify(obj));\n\n/**\n * Wrapper around the built-in structured clone. Uses `JSON.parse(JSON.stringify(...))`\n * as a fallback.\n */\nexport function structuredClone<T>(obj: T): T {\n    return clone(obj);\n}\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { attachMacroArgsInArray } from \"@unified-latex/unified-latex-util-arguments\";\nimport { tikzCommandArgumentParser } from \"./libs/tikz-command-argument-parser\";\n\nexport const macros: MacroInfoRecord = {\n    pgfkeys: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    tikzoption: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    tikzstyle: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    usetikzlibrary: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    usepgfmodule: { signature: \"m\", renderInfo: { pgfkeysArgs: true } },\n    usepgflibrary: { signature: \"m\", renderInfo: { pgfkeysArgs: true } },\n    pgfplotsset: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    pgfplotstabletypeset: {\n        signature: \"o m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    tikz: {\n        signature: \"o o m\",\n        argumentParser: tikzCommandArgumentParser,\n        renderInfo: { namedArguments: [\"animation\", \"options\", \"command\"] },\n    },\n};\n\nexport const environments: EnvInfoRecord = {\n    tikzpicture: {\n        signature: \"o\",\n        renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },\n        processContent: processTikzEnvironmentContent,\n    },\n    axis: {\n        signature: \"o\",\n        renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },\n        processContent: processTikzEnvironmentContent,\n    },\n    scope: {\n        signature: \"o\",\n        renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },\n        processContent: processTikzEnvironmentContent,\n    },\n    pgfonlayer: {\n        signature: \"m\",\n        renderInfo: { tikzEnvironment: true },\n        processContent: processTikzEnvironmentContent,\n    },\n    pgflowlevelscope: {\n        signature: \"m\",\n        renderInfo: { tikzEnvironment: true },\n        processContent: processTikzEnvironmentContent,\n    },\n    pgfviewboxscope: {\n        signature: \"m m m m m\",\n        renderInfo: { tikzEnvironment: true },\n        processContent: processTikzEnvironmentContent,\n    },\n    pgftransparencygroup: {\n        signature: \"o\",\n        renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },\n        processContent: processTikzEnvironmentContent,\n    },\n    behindforegroundpath: {\n        signature: \"m\",\n        processContent: processTikzEnvironmentContent,\n    },\n    pgfmetadecoration: {\n        signature: \"m\",\n        processContent: processTikzEnvironmentContent,\n    },\n    colormixin: { signature: \"m\", renderInfo: { pgfkeysArgs: true } },\n};\n\n/**\n * Attach macro arguments for all macros that are only available within a tikz environment.\n */\nfunction processTikzEnvironmentContent(nodes: Ast.Node[]): Ast.Node[] {\n    attachMacroArgsInArray(nodes, conditionalMacros);\n    return nodes;\n}\n\n/**\n * Macros that are only parsed inside a tikz environment.\n */\nexport const conditionalMacros: MacroInfoRecord = {\n    pgfextra: { signature: \"m\" },\n    beginpgfgraphicnamed: { signature: \"m\" },\n    pgfrealjobname: { signature: \"m\" },\n    pgfplotstreampoint: { signature: \"m\" },\n    pgfplotstreampointoutlier: { signature: \"m\" },\n    pgfplotstreamspecial: { signature: \"m\" },\n    pgfplotxyfile: { signature: \"m\" },\n    pgfplotxyzfile: { signature: \"m\" },\n    pgfplotfunction: { signature: \"mmm\" },\n    pgfplotgnuplot: { signature: \"o m\" },\n    pgfplothandlerrecord: { signature: \"m\" },\n    pgfdeclareplothandler: { signature: \"m m m\" },\n    pgfdeclarelayer: { signature: \"m\" },\n    pgfsetlayers: { signature: \"m\", renderInfo: { pgfkeysArgs: true } },\n    pgfonlayer: { signature: \"m\" },\n    startpgfonlayer: { signature: \"m\" },\n    pgfdeclarehorizontalshading: { signature: \"o m m m \" },\n    pgfdeclareradialshading: { signature: \"o m m m\" },\n    pgfdeclarefunctionalshading: { signature: \"o m m m m m\" },\n    pgfshadecolortorgb: { signature: \"m m\" },\n    pgfshadecolortocmyk: { signature: \"m m\" },\n    pgfshadecolortogray: { signature: \"m m\" },\n    pgfuseshading: { signature: \"m\" },\n    pgfshadepath: { signature: \"m m\" },\n    pgfsetadditionalshadetransform: { signature: \"m\" },\n    pgfsetstrokeopacity: { signature: \"m\" },\n    pgfsetfillopacity: { signature: \"m\" },\n    pgfsetblendmode: { signature: \"m\" },\n    pgfdeclarefading: { signature: \"m m\" },\n    pgfsetfading: { signature: \"m m\" },\n    pgfsetfadingforcurrentpath: { signature: \"m m\" },\n    pgfsetfadingforcurrentpathstroked: { signature: \"m m\" },\n    pgfanimateattribute: { signature: \"m m\" },\n    pgfsnapshot: { signature: \"m\" },\n    pgfqpoint: { signature: \"m m\" },\n    pgfqpointxy: { signature: \"m m\" },\n    pgfqpointxyz: { signature: \"m m m\" },\n    pgfqpointscale: { signature: \"m m\" },\n    pgfpathqmoveto: { signature: \"m m\" },\n    pgfpathqlineto: { signature: \"m m\" },\n    pgfpathqcurveto: { signature: \"m m m m m m\" },\n    pgfpathqcircle: { signature: \"m\" },\n    pgfqbox: { signature: \"m\" },\n    pgfqboxsynced: { signature: \"m\" },\n    pgfaliasimage: { signature: \"m m\" },\n    pgfuseimage: { signature: \"m\" },\n    pgfimage: { signature: \"o m\", renderInfo: { pgfkeysArgs: true } },\n    pgfdeclaremask: { signature: \"o m m\", renderInfo: { pgfkeysArgs: true } },\n    pgfdeclarepatternformonly: { signature: \"o m m m m m\" },\n    pgfdeclarepatterninherentlycolored: { signature: \"o m m m m m\" },\n    pgfsetfillpattern: { signature: \"m m\" },\n    // Coordinate canvas and nonlinear transformations\n    pgftransformshift: { signature: \"m\" },\n    pgftransformxshift: { signature: \"m\" },\n    pgftransformyshift: { signature: \"m\" },\n    pgftransformscale: { signature: \"m\" },\n    pgftransformxscale: { signature: \"m\" },\n    pgftransformyscale: { signature: \"m\" },\n    pgftransformxslant: { signature: \"m\" },\n    pgftransformyslant: { signature: \"m\" },\n    pgftransformrotate: { signature: \"m\" },\n    pgftransformtriangle: { signature: \"m m m\" },\n    pgftransformcm: { signature: \"m m m m m\" },\n    pgftransformarrow: { signature: \"m m\" },\n    pgftransformlineattime: { signature: \"m m m\" },\n    pgftransformcurveattime: { signature: \"m m m m m\" },\n    pgftransformarcaxesattime: { signature: \"m m m m m m\" },\n    pgfgettransform: { signature: \"m\" },\n    pgfsettransform: { signature: \"m\" },\n    pgfgettransformentries: { signature: \"m m m m m m\" },\n    pgfsettransformentries: { signature: \"m m m m m m\" },\n    pgfpointtransformed: { signature: \"m\" },\n    pgflowlevel: { signature: \"m\" },\n    pgflowlevelobj: { signature: \"m m\" },\n    pgflowlevelscope: { signature: \"m\" },\n    startpgflowlevelscope: { signature: \"m\" },\n    pgfviewboxscope: { signature: \"m m m m m\" },\n    startpgfviewboxscope: { signature: \"m m m m m\" },\n    pgftransformnonlinear: { signature: \"m\" },\n    pgfpointtransformednonlinear: { signature: \"m\" },\n    pgfsetcurvilinearbeziercurve: { signature: \"m m m m\" },\n    pgfcurvilineardistancetotime: { signature: \"m\" },\n    pgfpointcurvilinearbezierorthogonal: { signature: \"m m\" },\n    pgfpointcurvilinearbezierpolar: { signature: \"m m\" },\n    // Matrices\n    pgfmatrix: { signature: \"m m m m m m m\" },\n    pgfsetmatrixcolumnsep: { signature: \"m\" },\n    pgfmatrixnextcell: { signature: \"o\" },\n    pgfsetmatrixrowsep: { signature: \"m\" },\n    pgfmatrixendrow: { signature: \"o\" },\n    // Nodes and shapes\n    pgfnode: { signature: \"m m m m m\" },\n    pgfmultipartnode: { signature: \"m m m m\" },\n    pgfcoordinate: { signature: \"m m\" },\n    pgfnodealias: { signature: \"m m\" },\n    pgfnoderename: { signature: \"m m\" },\n    pgfpositionnodelater: { signature: \"m\" },\n    pgfpositionnodenow: { signature: \"m\" },\n    pgfnodepostsetupcode: { signature: \"m m\" },\n    pgfpointanchor: { signature: \"m m\" },\n    pgfpointshapeborder: { signature: \"m m\" },\n    pgfdeclareshape: { signature: \"m m\" },\n    saveddimen: { signature: \"m m\" },\n    savedmacro: { signature: \" m\" },\n    anchor: { signature: \"m m\" },\n    deferredanchor: { signature: \"m m\" },\n    anchorborder: { signature: \"m\" },\n    backgroundpath: { signature: \"m\" },\n    foregroundpath: { signature: \"m\" },\n    behindbackgroundpath: { signature: \"m\" },\n    beforebackgroundpath: { signature: \"m\" },\n    beforeforegroundpath: { signature: \"m\" },\n    behindforegroundpath: { signature: \"m\" },\n    // Arrows\n    pgfdeclarearrow: { signature: \"m\" },\n    pgfarrowssettipend: { signature: \"m\" },\n    pgfarrowssetbackend: { signature: \"m\" },\n    pgfarrowssetlineend: { signature: \"m\" },\n    pgfarrowssetvisualbackend: { signature: \"m\" },\n    pgfarrowssetvisualtipend: { signature: \"m\" },\n    pgfarrowshullpoint: { signature: \"m m\" },\n    pgfarrowsupperhullpoint: { signature: \"m m\" },\n    pgfarrowssave: { signature: \"m\" },\n    pgfarrowssavethe: { signature: \"m\" },\n    pgfarrowsaddtooptions: { signature: \"m\" },\n    pgfarrowsaddtolateoptions: { signature: \"m\" },\n    pgfarrowsaddtolengthscalelist: { signature: \"m\" },\n    pgfarrowsaddtowidthscalelist: { signature: \"m\" },\n    pgfarrowsthreeparameters: { signature: \"m\" },\n    pgfarrowslinewidthdependent: { signature: \"m m m\" },\n    pgfarrowslengthdependent: { signature: \"m\" },\n    // Path\n    pgfusepath: { signature: \"m\" },\n    pgfsetlinewidth: { signature: \"m\" },\n    pgfsetmiterlimit: { signature: \"m\" },\n    pgfsetdash: { signature: \"m m\" },\n    pgfsetstrokecolor: { signature: \"m\" },\n    pgfsetcolor: { signature: \"m\" },\n    pgfsetinnerlinewidth: { signature: \"m\" },\n    pgfsetinnerstrokecolor: { signature: \"m\" },\n    pgfsetarrowsstart: { signature: \"m\" },\n    pgfsetarrowsend: { signature: \"m\" },\n    pgfsetarrows: { signature: \"m\" },\n    pgfsetshortenstart: { signature: \"m\" },\n    pgfsetshortenend: { signature: \"m\" },\n    pgfsetfillcolor: { signature: \"m\" },\n    // Decorations\n    pgfdeclaredecoration: { signature: \"m m m\" },\n    state: { signature: \"m o m\" },\n    pgfdecoratepath: { signature: \"m m\" },\n    startpgfdecoration: { signature: \"m\" },\n    pgfdecoration: { signature: \"m\" },\n    pgfdecoratecurrentpath: { signature: \"m\" },\n    pgfsetdecorationsegmenttransformation: { signature: \"m\" },\n    pgfdeclaremetadecorate: { signature: \"m m m\" },\n    pgfmetadecoration: { signature: \"m\" },\n    startpgfmetadecoration: { signature: \"m\" },\n    // Constructing paths\n    pgfpathmoveto: { signature: \"m\" },\n    pgfpathlineto: { signature: \"m\" },\n    pgfpathcurveto: { signature: \"m m m\" },\n    pgfpathquadraticcurveto: { signature: \"m m\" },\n    pgfpathcurvebetweentime: { signature: \"m m m m m m\" },\n    pgfpathcurvebetweentimecontinue: { signature: \"m m m m m m\" },\n    pgfpatharc: { signature: \"m m m\" },\n    pgfpatharcaxes: { signature: \"m m m m\" },\n    pgfpatharcto: { signature: \"m m m m m m\" },\n    pgfpatharctoprecomputed: { signature: \"m m m m m m m m\" },\n    pgfpathellipse: { signature: \"m m m\" },\n    pgfpathcircle: { signature: \"m m\" },\n    pgfpathrectangle: { signature: \"m m\" },\n    pgfpathrectanglecorners: { signature: \"m m\" },\n    pgfpathgrid: { signature: \" o m m\" },\n    pgfpathparabola: { signature: \"m m\" },\n    pgfpathsine: { signature: \"m\" },\n    pgfpathcosine: { signature: \"m\" },\n    pgfsetcornersarced: { signature: \"m\" },\n    \"pgf@protocolsizes\": { signature: \"m m\" },\n    // Specifying coordinates\n    pgfpoint: { signature: \"m m\" },\n    pgfpointpolar: { signature: \"m m m\" },\n    pgfpointxy: { signature: \"m m\" },\n    pgfsetxvec: { signature: \"m\" },\n    pgfsetyvec: { signature: \"m\" },\n    pgfpointpolarxy: { signature: \"m m\" },\n    pgfpointxyz: { signature: \"m m m\" },\n    pgfsetzvec: { signature: \"m\" },\n    pgfpointcylindrical: { signature: \"m m m\" },\n    pgfpointspherical: { signature: \"m m m\" },\n    pgfpointadd: { signature: \"m m\" },\n    pgfpointscale: { signature: \"m m\" },\n    pgfpointdiff: { signature: \"m m\" },\n    pgfpointnormalised: { signature: \"m\" },\n    pgfpointlineattime: { signature: \"m m m\" },\n    pgfpointlineatdistance: { signature: \"m m m\" },\n    pgfpointarcaxesattime: { signature: \"m m m m m m\" },\n    pgfpointcurveattime: { signature: \"m m m m m\" },\n    pgfpointborderrectangle: { signature: \"m m\" },\n    pgfpointborderellipse: { signature: \"m m\" },\n    pgfpointintersectionoflines: { signature: \"m m m m\" },\n    pgfpointintersectionofcircles: { signature: \"m m m m m\" },\n    pgfintersectionofpaths: { signature: \"m m\" },\n    pgfpointintersectionsolution: { signature: \"m\" },\n    pgfextractx: { signature: \"m m\" },\n    pgfextracty: { signature: \"m m\" },\n    pgfgetlastxy: { signature: \"m m\" },\n    \"pgf@process\": { signature: \"m\" },\n    // Heirarchical structres ...\n    pgfsetbaseline: { signature: \"m\" },\n    pgfsetbaselinepointnow: { signature: \"m\" },\n    pgfsetbaselinepointlater: { signature: \"m\" },\n    pgftext: { signature: \"o m\", renderInfo: { pgfkeysArgs: true } },\n    pgfuseid: { signature: \"m\" },\n    pgfusetype: { signature: \"m\" },\n    pgfidrefnextuse: { signature: \"m m\" },\n    pgfidrefprevuse: { signature: \"m m\" },\n    pgfaliasid: { signature: \"m m\" },\n    pgfgaliasid: { signature: \"m m\" },\n    pgfifidreferenced: { signature: \"m m m\" },\n    pgfrdfabout: { signature: \"m\" },\n    pgfrdfcontent: { signature: \"m\" },\n    pgfrdfdatatype: { signature: \"m\" },\n    pgfrdfhref: { signature: \"m\" },\n    pgfrdfprefix: { signature: \"m\" },\n    pgfrdfproperty: { signature: \"m\" },\n    pgfrdfrel: { signature: \"m\" },\n    pgfrdfresource: { signature: \"m\" },\n    pgfrdfrev: { signature: \"m\" },\n    pgfrdfsrc: { signature: \"m\" },\n    pgfrdftypeof: { signature: \"m\" },\n    pgfrdfvocab: { signature: \"m\" },\n    pgferror: { signature: \"m\" },\n    pgfwarning: { signature: \"m\" },\n    path: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    draw: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    fill: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    filldraw: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    pattern: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    shade: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    clip: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    useasboundingbox: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    node: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    coordinate: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    graph: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    scoped: {\n        signature: \"o o m\",\n        argumentParser: tikzCommandArgumentParser,\n        renderInfo: {\n            namedArguments: [\"animation\", \"options\", \"command\"],\n            breakAround: true,\n        },\n    },\n};\n", "import { arg } from \"@unified-latex/unified-latex-builder\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    ArgSpecAst as ArgSpec,\n    parse as parseArgspec,\n} from \"@unified-latex/unified-latex-util-argspec\";\nimport { ArgumentParser } from \"@unified-latex/unified-latex-types\";\nimport { gobbleSingleArgument } from \"@unified-latex/unified-latex-util-arguments\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { scan } from \"@unified-latex/unified-latex-util-scan\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\nconst OPTIONAL_ARGUMENT_ARG_SPEC = parseArgspec(\"o\")[0];\n\nfunction blankArg() {\n    return arg([], { openMark: \"\", closeMark: \"\" });\n}\n\n/**\n * Find the arguments of a tikz command. Many tikz commands accept either\n * the a group as their only argument, or they scan their arguments until the first\n * `;` is found.\n *\n * This behavior cannot be achieved via a standard xparse spec.\n */\nexport const tikzCommandArgumentParser: ArgumentParser = (nodes, startPos) => {\n    const origStartPos = startPos;\n    let pos = startPos;\n    let nodesRemoved = 0;\n\n    const cursorPosAfterAnimations = eatAllAnimationSpecs(nodes, pos);\n    let animationArg = blankArg();\n    if (cursorPosAfterAnimations !== pos) {\n        const argContent = nodes.splice(pos, cursorPosAfterAnimations - pos);\n        trim(argContent);\n        animationArg = arg(argContent, {\n            openMark: \" \",\n            closeMark: \" \",\n        });\n    }\n    nodesRemoved += cursorPosAfterAnimations - pos;\n\n    const {\n        argument: _optionalArgument,\n        nodesRemoved: optionalArgumentNodesRemoved,\n    } = gobbleSingleArgument(nodes, OPTIONAL_ARGUMENT_ARG_SPEC, pos);\n    nodesRemoved += optionalArgumentNodesRemoved;\n    const optionalArg = _optionalArgument || blankArg();\n\n    // Eat whitespace\n    while (match.whitespace(nodes[pos])) {\n        pos++;\n    }\n    const firstNode = nodes[pos];\n\n    // If we're past the end of the array, give up.\n    if (!firstNode) {\n        return {\n            args: [animationArg, optionalArg, blankArg()],\n            nodesRemoved: 0,\n        };\n    }\n\n    // If we're a group, grab the contents and call it good.\n    if (match.group(firstNode)) {\n        const args = [animationArg, optionalArg, arg(firstNode.content)];\n        nodes.splice(origStartPos, pos - origStartPos + 1);\n        return { args, nodesRemoved: pos - origStartPos + 1 + nodesRemoved };\n    }\n\n    // No group, so scan for a semicolon.\n    const semicolonPosition = scan(nodes, \";\", { startIndex: pos });\n    if (semicolonPosition != null) {\n        const argNodes = nodes.splice(\n            origStartPos,\n            semicolonPosition - origStartPos + 1\n        );\n        trim(argNodes);\n        const args = [animationArg, optionalArg, arg(argNodes)];\n        return {\n            args,\n            nodesRemoved: origStartPos - semicolonPosition + 1 + nodesRemoved,\n        };\n    }\n\n    // If there was no semicolon, give up.\n    return {\n        args: [animationArg, optionalArg, blankArg()],\n        nodesRemoved: 0,\n    };\n};\n\n/**\n * Find the next index after all animation specs. If no animation specs are present,\n * return `startPos`.\n *\n * An animation spec looks like\n * ```\n * :rotate = { 0s=\"0\", 2s=\"90\", begin on=click }\n * ```\n * Any number can be listed. They start with a colon and have an equals sign followed by a group.\n */\nfunction eatAllAnimationSpecs(nodes: Ast.Node[], startPos: number): number {\n    const colonPos = scan(nodes, \":\", {\n        startIndex: startPos,\n        allowSubstringMatches: true,\n        onlySkipWhitespaceAndComments: true,\n    });\n\n    if (!colonPos) {\n        return startPos;\n    }\n\n    let lastMatchPos = startPos;\n    let i = colonPos + 1;\n    for (; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (match.string(node, \"[\")) {\n            // XXX As per the tikz manual, we stop scanning if we find an open square brace.\n            break;\n        }\n        if (match.string(node, \"=\")) {\n            i++;\n            // Look for a group next\n            while (match.whitespace(nodes[i]) || match.comment(nodes[i])) {\n                i++;\n            }\n            if (!match.group(nodes[i])) {\n                break;\n            }\n            // We have a match!\n            lastMatchPos = i + 1;\n\n            // Start the process again\n            const colonPos = scan(nodes, \":\", {\n                startIndex: lastMatchPos,\n                allowSubstringMatches: true,\n                onlySkipWhitespaceAndComments: true,\n            });\n            if (colonPos == null) {\n                break;\n            }\n            i = colonPos + 1;\n        }\n    }\n\n    return lastMatchPos;\n}\n", "import { printRaw as latexPrintRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\nimport * as TikzSpec from \"./types\";\n\n/**\n * Print an `systeme` argument specification AST to a string.\n */\nexport function printRaw(node: TikzSpec.Ast, root = false): string {\n    if (typeof node === \"string\") {\n        return node;\n    }\n\n    if (Array.isArray(node)) {\n        const sepToken = root ? \" \" : \"\";\n        const printed: string[] = [];\n        for (let i = 0; i < node.length; i++) {\n            const tok = node[i];\n            const prevTok = node[i - 1];\n            if (!prevTok) {\n                printed.push(printRaw(tok));\n                continue;\n            }\n            if (prevTok.type === \"comment\") {\n                printed.push(printRaw(tok));\n                continue;\n            }\n            if (tok.type !== \"comment\") {\n                printed.push(sepToken);\n            }\n            printed.push(printRaw(tok));\n        }\n        return printed.join(\"\");\n    }\n    const type = node.type;\n\n    switch (type) {\n        case \"path_spec\":\n            return printRaw(node.content, (root = true));\n        case \"coordinate\":\n            return `${latexPrintRaw(node.prefix)}(${latexPrintRaw(\n                node.content\n            )})`;\n        case \"operation\":\n            return latexPrintRaw(node.content);\n        case \"comment\":\n            return latexPrintRaw(node);\n        case \"line_to\":\n            return node.command;\n        case \"curve_to\": {\n            const comments = node.comments\n                .map((c) => latexPrintRaw({ ...c, leadingWhitespace: false }))\n                .join(\"\");\n            if (node.controls.length === 1) {\n                return `${comments}.. controls ${printRaw(\n                    node.controls[0]\n                )} ..`;\n            } else {\n                return `${comments}.. controls ${printRaw(\n                    node.controls[0]\n                )} and ${printRaw(node.controls[1])} ..`;\n            }\n        }\n        case \"unknown\":\n            return latexPrintRaw(node.content);\n        case \"square_brace_group\":\n            return `[${latexPrintRaw(node.content)}]`;\n        case \"foreach\": {\n            const comments = node.comments\n                .map((c) => latexPrintRaw({ ...c, leadingWhitespace: false }))\n                .join(\"\");\n            let options = \"\";\n            if (node.options) {\n                options = ` [${latexPrintRaw(node.options)}]`;\n            }\n            const start = latexPrintRaw(node.start);\n            const variables = [...node.variables];\n            trim(variables);\n            let printedVariables = latexPrintRaw(variables);\n            // It is possible that the variables are specified as `[var=\\p]`, in the optional argument, instead of as `\\p`\n            // In this case, `node.variables` will be empty and we don't want an extra space showing up.\n            if (printedVariables.length > 0) {\n                printedVariables = \" \" + printedVariables;\n            }\n\n            const command =\n                node.command.type === \"foreach\"\n                    ? printRaw(node.command)\n                    : latexPrintRaw(node.command);\n\n            return `${comments}${start}${printedVariables}${options} in ${latexPrintRaw(\n                node.list\n            )} ${command}`;\n        }\n        case \"svg_operation\": {\n            const comments = node.comments\n                .map((c) => latexPrintRaw({ ...c, leadingWhitespace: false }))\n                .join(\"\");\n            let options = \"\";\n            if (node.options) {\n                options = `[${latexPrintRaw(node.options)}]`;\n            }\n\n            return `${comments}svg${options} ${latexPrintRaw(node.content)}`;\n        }\n        case \"animation\": {\n            const comments = node.comments\n                .map((c) => latexPrintRaw({ ...c, leadingWhitespace: false }))\n                .join(\"\");\n\n            return `${comments}:${node.attribute} = {${latexPrintRaw(\n                node.content\n            )}}`;\n        }\n\n        default:\n            const unprintedType: void = type;\n            console.warn(`Unknown node type \"${unprintedType}\" for node`, node);\n            return \"\";\n    }\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as TikzSpec from \"./types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { decorateArrayForPegjs } from \"@unified-latex/unified-latex-util-pegjs\";\nimport { TikzPegParser } from \"@unified-latex/unified-latex-util-pegjs\";\n\ntype TikzParseOptions = {\n    startRule?: \"path_spec\" | \"foreach_body\";\n};\n\nfunction createMatchers() {\n    return {\n        isChar: match.string,\n        isTerminal: (node: any) => match.string(node, \";\"),\n        isOperation: (node: any) =>\n            match.anyString(node) && node.content.match(/[a-zA-Z]/),\n        isWhitespace: (node: any) =>\n            match.whitespace(node) || match.parbreak(node),\n        isComment: match.comment,\n        isGroup: match.group,\n        isMacro: match.macro,\n        isAnyMacro: match.anyMacro,\n    };\n}\n\nconst matchers = createMatchers();\n\n/**\n * Parse the contents of the `\\systeme{...}` macro\n */\nexport function parse<Options extends TikzParseOptions>(\n    ast: Ast.Node[],\n    options?: Options\n): Options extends { startRule: infer R }\n    ? R extends \"path_spec\"\n        ? TikzSpec.PathSpec\n        : TikzSpec.ForeachBody\n    : TikzSpec.PathSpec {\n    const { startRule = \"path_spec\" } = options || {};\n    if (!Array.isArray(ast)) {\n        throw new Error(\"You must pass an array of nodes\");\n    }\n    // We need to at functions to `nodes` so that it imitates\n    // a Javascript string. Because we're mutating, make a copy first\n    ast = decorateArrayForPegjs([...ast]);\n    // matchers are passed in via the second argument (the `options` argument)\n    // so they are available from within the Pegjs grammar.\n    return TikzPegParser.parse(ast, {\n        ...matchers,\n        startRule,\n    });\n}\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    substitutecolormodel: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    selectcolormodel: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    definecolor: {\n        signature: \"o m m m\",\n        renderInfo: { breakAround: true },\n    },\n    providecolor: {\n        signature: \"o m m m\",\n        renderInfo: { breakAround: true },\n    },\n    colorlet: {\n        signature: \"o m o m\",\n        renderInfo: { breakAround: true },\n    },\n    definecolorset: {\n        signature: \"o m m m\",\n        renderInfo: { breakAround: true },\n    },\n    providecolorset: {\n        signature: \"o m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    preparecolor: {\n        signature: \"o m m m\",\n        renderInfo: { breakAround: true },\n    },\n    preparecolorset: {\n        signature: \"o m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    DefineNamedColor: {\n        signature: \"m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    definecolors: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    providecolors: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    color: { signature: \"o m\", renderInfo: { breakAround: true } },\n    textcolor: { signature: \"o m m\", renderInfo: { inParMode: true } },\n    pagecolor: { signature: \"o m\" },\n    colorbox: { signature: \"o m m\" },\n    fcolorbox: { signature: \"o m o m m\" },\n    boxframe: { signature: \"o m\" },\n    testcolor: { signature: \"o m\" },\n    blendcolors: { signature: \"s m\" },\n    maskcolors: { signature: \"o m\" },\n    definecolorseries: {\n        signature: \"m m m o m o m\",\n        renderInfo: { breakAround: true },\n    },\n    resetcolorseries: {\n        signature: \"o m\",\n        renderInfo: { breakAround: true },\n    },\n    rowcolors: { signature: \"s o m m m\" },\n    extractcolorspec: { signature: \"m m\" },\n    extractcolorspecs: { signature: \"m m m\" },\n    convertcolorspec: { signature: \"m m m m\" },\n};\n\nexport const environments: EnvInfoRecord = {\n    testcolors: { signature: \"o\", renderInfo: { pgfkeysArgs: true } },\n};\n", "import Color from \"color\";\nimport { DVI_PS_NAMES, SVG_NAMES, X11_NAMES } from \"./predefined-colors\";\nimport { XColor } from \"./types\";\nimport { parse as xcolorParser } from \"./parser\";\n\nconst CORE_MODELS = new Set([\"rgb\", \"cmy\", \"cmyk\", \"hsb\", \"gray\"]);\n\nexport const XColorCoreModelToColor = {\n    rgb: ([r, g, b]: number[]) => Color([r * 255, g * 255, b * 255], \"rgb\"),\n    cmy: ([c, m, y]: number[]) =>\n        XColorCoreModelToColor.rgb([1 - c, 1 - m, 1 - y]),\n    cmyk: ([c, m, y, k]: number[]) =>\n        Color([c * 255, m * 255, y * 255, k * 100], \"cmyk\"),\n    hsb: ([h, s, b]: number[]) => Color([h * 360, s * 100, b * 100], \"hsv\"),\n    gray: ([v]: number[]) => Color([v * 255, v * 255, v * 255], \"rgb\"),\n};\nconst XColorModelToColor = {\n    wave: ([lambda]: number[]) => {\n        // Constants according to the xcolor readme\n        const gamma = 0.8;\n        let baseRgb = [0, 0, 0];\n        if (380 <= lambda && lambda < 440) {\n            baseRgb = [(440 - lambda) / (440 - 380), 0, 1];\n        }\n        if (440 <= lambda && lambda < 490) {\n            baseRgb = [0, (lambda - 440) / (490 - 440), 1];\n        }\n        if (490 <= lambda && lambda < 510) {\n            baseRgb = [0, 1, (510 - lambda) / (510 - 490)];\n        }\n        if (510 <= lambda && lambda < 580) {\n            baseRgb = [(lambda - 510) / (580 - 510), 1, 0];\n        }\n        if (580 <= lambda && lambda < 6450) {\n            baseRgb = [1, (645 - lambda) / (645 - 580), 0];\n        }\n        if (645 <= lambda && lambda <= 780) {\n            baseRgb = [1, 0, 0];\n        }\n        let f = 1.0;\n        if (380 <= lambda && 420 < lambda) {\n            f = 0.3 + (0.7 * (lambda - 380)) / (420 - 380);\n        }\n        if (700 < lambda && lambda <= 780) {\n            f = 0.3 + (0.7 * (780 - lambda)) / (780 - 700);\n        }\n\n        const rgb = [\n            Math.pow(baseRgb[0] * f, gamma),\n            Math.pow(baseRgb[1] * f, gamma),\n            Math.pow(baseRgb[2] * f, gamma),\n        ];\n\n        return Color([rgb[0] * 255, rgb[1] * 255, rgb[2] * 255], \"rgb\");\n    },\n    Hsb: ([h, s, b]: number[]) => XColorCoreModelToColor.hsb([h / 360, s, b]),\n    HSB: ([h, s, b]: number[]) =>\n        XColorCoreModelToColor.hsb([h / 240, s / 240, b / 240]),\n    HTML: ([v]: [string]) => (v.startsWith(\"#\") ? Color(v) : Color(`#${v}`)),\n    RGB: ([r, g, b]: number[]) => Color([r, g, b], \"rgb\"),\n    Gray: ([v]: number[]) => XColorCoreModelToColor.gray([v / 15]),\n    ...XColorCoreModelToColor,\n};\n\nconst ColorToXColorModel = {\n    rgb: (color: Color<any>) =>\n        color\n            .rgb()\n            .array()\n            .map((v) => v / 255),\n    cmy: (color: Color<any>) =>\n        [255 - color.red(), 255 - color.green(), 255 - color.blue()].map(\n            (v) => v / 255\n        ),\n    cmyk: (color: Color<any>) =>\n        color\n            .cmyk()\n            .array()\n            // The k component goes from 0-100\n            .map((v, i) => (i === 3 ? v / 100 : v / 255)),\n    hsb: (color: Color<any>) => [\n        color.hue() / 360,\n        color.saturationv() / 100,\n        color.value() / 100,\n    ],\n    gray: (color: Color<any>) => [color.gray() / 100],\n};\n\nexport const PREDEFINED_XCOLOR_COLORS: Record<string, Color<any>> = {\n    // Core colors\n    red: XColorCoreModelToColor.rgb([1, 0, 0]),\n    green: XColorCoreModelToColor.rgb([0, 1, 0]),\n    blue: XColorCoreModelToColor.rgb([0, 0, 1]),\n    brown: XColorCoreModelToColor.rgb([0.75, 0.5, 0.25]),\n    lime: XColorCoreModelToColor.rgb([0.75, 1, 0]),\n    orange: XColorCoreModelToColor.rgb([1, 0.5, 0]),\n    pink: XColorCoreModelToColor.rgb([1, 0.75, 0.75]),\n    purple: XColorCoreModelToColor.rgb([0.75, 0, 0.25]),\n    teal: XColorCoreModelToColor.rgb([0, 0.5, 0.5]),\n    violet: XColorCoreModelToColor.rgb([0.5, 0, 0.5]),\n    cyan: XColorCoreModelToColor.rgb([0, 1, 1]),\n    magenta: XColorCoreModelToColor.rgb([1, 0, 1]),\n    yellow: XColorCoreModelToColor.rgb([1, 1, 0]),\n    olive: XColorCoreModelToColor.rgb([0.5, 0.5, 0]),\n    black: XColorCoreModelToColor.rgb([0, 0, 0]),\n    darkgray: XColorCoreModelToColor.rgb([0.25, 0.25, 0.25]),\n    gray: XColorCoreModelToColor.rgb([0.5, 0.5, 0.5]),\n    lightgray: XColorCoreModelToColor.rgb([0.75, 0.75, 0.75]),\n    white: XColorCoreModelToColor.rgb([1, 1, 1]),\n    ...DVI_PS_NAMES,\n    ...SVG_NAMES,\n    ...X11_NAMES,\n};\n\nfunction scalarMul(scalar: number, vec: number[]) {\n    return vec.map((v) => scalar * v);\n}\nfunction addVectors(...vecs: number[][]) {\n    return vecs.reduce((prev, current) => prev.map((v, i) => v + current[i]));\n}\n\n/**\n * Mix a color in color model `model` as per the algorithm in 2.3.3 of the xcolor manual.\n */\nfunction mixInModel(\n    model: string,\n    colorsAndCoefficients: [number, Color<any>][]\n): Color<any> {\n    if (!CORE_MODELS.has(model)) {\n        throw new Error(\n            `Cannot mix colors in model \"${model}\"; only core modes ${Array.from(\n                CORE_MODELS\n            ).join(\", \")} are supported`\n        );\n    }\n    const toModel =\n        ColorToXColorModel[model as keyof typeof ColorToXColorModel];\n    const fromModel =\n        XColorCoreModelToColor[model as keyof typeof XColorCoreModelToColor];\n\n    const mixed = addVectors(\n        ...colorsAndCoefficients.map(([v, color]) => {\n            const colorInModel = toModel(color);\n            return scalarMul(v, colorInModel);\n        })\n    );\n    return fromModel(mixed);\n}\n\n/**\n * Given a parsed `XColor`, compute the color and return a `Color` object\n * (that can be used in CSS, for example).\n */\nexport function computeColor(\n    expr: XColor,\n    predefinedColors: Record<string, Color<any>> = {}\n): Color<any> {\n    if (expr.type !== \"color\") {\n        throw new Error(\n            `Can only compute the color of a \"color\" expression, not one of type ${expr.type}`\n        );\n    }\n\n    const knownColors = { ...PREDEFINED_XCOLOR_COLORS, ...predefinedColors };\n    function getColor(name: string) {\n        if (!knownColors[name]) {\n            throw new Error(`Unknown color \"${name}\"`);\n        }\n        return knownColors[name];\n    }\n\n    const color = expr.color;\n    let computedColor = Color(\"#000000\");\n    if (color.type === \"expr\") {\n        // From the algorithm in 2.3.2 of the xcolor manual\n\n        // TODO: the suffix `!![num]` is not yet implemented.\n        let base = getColor(color.name);\n        for (const mix of color.mix_expr) {\n            if (mix.type === \"complete_mix\") {\n                const mixColor = getColor(mix.name);\n                base = base.mix(mixColor, 1 - mix.mix_percent / 100);\n            } else if (mix.type === \"partial_mix\") {\n                base = base.mix(Color(\"#FFFFFF\"), 1 - mix.mix_percent / 100);\n            }\n        }\n        if (color.prefix && color.prefix.length % 2 === 1) {\n            base = base.rotate(180);\n        }\n        computedColor = base;\n    }\n    if (color.type === \"extended_expr\") {\n        const model = color.core_model;\n        const div =\n            color.div ||\n            color.expressions.reduce((a, expr) => a + expr.weight, 0);\n        if (div <= 0) {\n            throw new Error(\n                `Cannot mix color with ratios that have a denominator of ${div}`\n            );\n        }\n        const colorsToMix: [number, Color<any>][] = color.expressions.map(\n            (expr) => [\n                expr.weight / div,\n                computeColor({\n                    type: \"color\",\n                    color: expr.color,\n                    functions: [],\n                }),\n            ]\n        );\n        computedColor = mixInModel(model, colorsToMix);\n    }\n\n    // Now we apply any color functions\n    for (const func of expr.functions) {\n        if (func.name === \"wheel\") {\n            const angle = func.args[0];\n            const circ = func.args[1] || 360;\n            computedColor = computedColor.rotate((angle / circ) * 360);\n        }\n        if (func.name === \"twheel\") {\n            // This function depends on the definition of \\rangetHsb, which we\n            // don't actually know, so we just use it's default, which is to\n            // add a 60 deg. angle to everything. I think...\n            const angle = func.args[0];\n            const circ = func.args[1] || 360;\n            computedColor = computedColor.rotate((angle / circ) * 360 + 60);\n        }\n    }\n\n    return computedColor;\n}\n\n/**\n * Convert the xcolor defined color to RGB Hex representation.\n * If the color is unknown or cannot be computed, `null` is returned.\n *\n * If `model` is supplied,\n *\n * The most likely reason a color will be `null` is if the color is defined\n * using a pre-defined color that wasn't supplied as an argument.\n */\nexport function xcolorColorToHex(\n    color: string,\n    model?: string | null,\n    options: {\n        predefinedColors?: Record<string, Color<any>>;\n    } = { predefinedColors: {} }\n): string | null {\n    const { predefinedColors = {} } = options;\n    const parsed = xcolorParser(color);\n    // If a model was entered, the corresponding color was directly entered without\n    // mixing, unless the parsed type was \"color\". This would through an error in `xcolor`,\n    // but we won't error.\n    if (model && model !== \"default\" && parsed.type !== \"color\") {\n        if (!(model in XColorModelToColor)) {\n            throw new Error(\n                `Unknown color model \"${model}\"; known models are ${Object.keys(\n                    XColorModelToColor\n                ).join(\", \")}`\n            );\n        }\n        if (parsed.type !== \"hex_spec\" && parsed.type !== \"num_spec\") {\n            throw new Error(\n                `Cannot use model ${model} to compute the color \"${color}\"`\n            );\n        }\n\n        if (model === \"HTML\" && parsed.type === \"hex_spec\") {\n            return XColorModelToColor.HTML(parsed.content).hex();\n        } else if (parsed.type === \"num_spec\") {\n            type x = keyof Omit<typeof XColorModelToColor, \"HTML\">;\n            return XColorModelToColor[\n                model as keyof Omit<typeof XColorModelToColor, \"HTML\">\n            ](parsed.content).hex();\n        }\n\n        throw new Error(\n            `Don't know how to process color \"${color}\" in model \"${model}\"`\n        );\n    }\n\n    if (Array.isArray(parsed) || parsed.type !== \"color\") {\n        throw new Error(\n            `Cannot the color \"${color}\" is not a valid color string`\n        );\n    }\n    let computed: Color<any> | null = null;\n    try {\n        computed = computeColor(parsed, predefinedColors);\n    } catch (e) {}\n\n    return computed && computed.hex();\n}\n", "import Color from \"color\";\n\nconst fromRgb = ([r, g, b]: number[]) =>\n    Color([r * 255, g * 255, b * 255], \"rgb\");\n\nexport const DVI_PS_NAMES = {\n    Apricot: Color(\"#FBB982\"),\n    Aquamarine: Color(\"#00B5BE\"),\n    Bittersweet: Color(\"#C04F17\"),\n    Black: Color(\"#221E1F\"),\n    Blue: Color(\"#2D2F92\"),\n    BlueGreen: Color(\"#00B3B8\"),\n    BlueViolet: Color(\"#473992\"),\n    BrickRed: Color(\"#B6321C\"),\n    Brown: Color(\"#792500\"),\n    BurntOrange: Color(\"#F7921D\"),\n    CadetBlue: Color(\"#74729A\"),\n    CarnationPink: Color(\"#F282B4\"),\n    Cerulean: Color(\"#00A2E3\"),\n    CornflowerBlue: Color(\"#41B0E4\"),\n    Cyan: Color(\"#00AEEF\"),\n    Dandelion: Color(\"#FDBC42\"),\n    DarkOrchid: Color(\"#A4538A\"),\n    Emerald: Color(\"#00A99D\"),\n    ForestGreen: Color(\"#009B55\"),\n    Fuchsia: Color(\"#8C368C\"),\n    Goldenrod: Color(\"#FFDF42\"),\n    Gray: Color(\"#949698\"),\n    Green: Color(\"#00A64F\"),\n    GreenYellow: Color(\"#DFE674\"),\n    JungleGreen: Color(\"#00A99A\"),\n    Lavender: Color(\"#F49EC4\"),\n    LimeGreen: Color(\"#8DC73E\"),\n    Magenta: Color(\"#EC008C\"),\n    Mahogany: Color(\"#A9341F\"),\n    Maroon: Color(\"#AF3235\"),\n    Melon: Color(\"#F89E7B\"),\n    MidnightBlue: Color(\"#006795\"),\n    Mulberry: Color(\"#A93C93\"),\n    NavyBlue: Color(\"#006EB8\"),\n    OliveGreen: Color(\"#3C8031\"),\n    Orange: Color(\"#F58137\"),\n    OrangeRed: Color(\"#ED135A\"),\n    Orchid: Color(\"#AF72B0\"),\n    Peach: Color(\"#F7965A\"),\n    Periwinkle: Color(\"#7977B8\"),\n    PineGreen: Color(\"#008B72\"),\n    Plum: Color(\"#92268F\"),\n    ProcessBlue: Color(\"#00B0F0\"),\n    Purple: Color(\"#99479B\"),\n    RawSienna: Color(\"#974006\"),\n    Red: Color(\"#ED1B23\"),\n    RedOrange: Color(\"#F26035\"),\n    RedViolet: Color(\"#A1246B\"),\n    Rhodamine: Color(\"#EF559F\"),\n    RoyalBlue: Color(\"#0071BC\"),\n    RoyalPurple: Color(\"#613F99\"),\n    RubineRed: Color(\"#ED017D\"),\n    Salmon: Color(\"#F69289\"),\n    SeaGreen: Color(\"#3FBC9D\"),\n    Sepia: Color(\"#671800\"),\n    SkyBlue: Color(\"#46C5DD\"),\n    SpringGreen: Color(\"#C6DC67\"),\n    Tan: Color(\"#DA9D76\"),\n    TealBlue: Color(\"#00AEB3\"),\n    Thistle: Color(\"#D883B7\"),\n    Turquoise: Color(\"#00B4CE\"),\n    Violet: Color(\"#58429B\"),\n    VioletRed: Color(\"#EF58A0\"),\n    White: Color(\"#FFFFFF\"),\n    WildStrawberry: Color(\"#EE2967\"),\n    Yellow: Color(\"#FFF200\"),\n    YellowGreen: Color(\"#98CC70\"),\n    YellowOrange: Color(\"#FAA21A\"),\n};\n\nexport const SVG_NAMES = {\n    AliceBlue: fromRgb([0.94, 0.972, 1]),\n    AntiqueWhite: fromRgb([0.98, 0.92, 0.844]),\n    Aqua: fromRgb([0, 1, 1]),\n    Aquamarine: fromRgb([0.498, 1, 0.83]),\n    Azure: fromRgb([0.94, 1, 1]),\n    Beige: fromRgb([0.96, 0.96, 0.864]),\n    Bisque: fromRgb([1, 0.894, 0.77]),\n    Black: fromRgb([0, 0, 0]),\n    BlanchedAlmond: fromRgb([1, 0.92, 0.804]),\n    Blue: fromRgb([0, 0, 1]),\n    BlueViolet: fromRgb([0.54, 0.17, 0.888]),\n    Brown: fromRgb([0.648, 0.165, 0.165]),\n    BurlyWood: fromRgb([0.87, 0.72, 0.53]),\n    CadetBlue: fromRgb([0.372, 0.62, 0.628]),\n    Chartreuse: fromRgb([0.498, 1, 0]),\n    Chocolate: fromRgb([0.824, 0.41, 0.116]),\n    Coral: fromRgb([1, 0.498, 0.312]),\n    CornflowerBlue: fromRgb([0.392, 0.585, 0.93]),\n    Cornsilk: fromRgb([1, 0.972, 0.864]),\n    Crimson: fromRgb([0.864, 0.08, 0.235]),\n    Cyan: fromRgb([0, 1, 1]),\n    DarkBlue: fromRgb([0, 0, 0.545]),\n    DarkCyan: fromRgb([0, 0.545, 0.545]),\n    DarkGoldenrod: fromRgb([0.72, 0.525, 0.044]),\n    DarkGray: fromRgb([0.664, 0.664, 0.664]),\n    DarkGreen: fromRgb([0, 0.392, 0]),\n    DarkGrey: fromRgb([0.664, 0.664, 0.664]),\n    DarkKhaki: fromRgb([0.74, 0.716, 0.42]),\n    DarkMagenta: fromRgb([0.545, 0, 0.545]),\n    DarkOliveGreen: fromRgb([0.332, 0.42, 0.185]),\n    DarkOrange: fromRgb([1, 0.55, 0]),\n    DarkOrchid: fromRgb([0.6, 0.196, 0.8]),\n    DarkRed: fromRgb([0.545, 0, 0]),\n    DarkSalmon: fromRgb([0.912, 0.59, 0.48]),\n    DarkSeaGreen: fromRgb([0.56, 0.736, 0.56]),\n    DarkSlateBlue: fromRgb([0.284, 0.24, 0.545]),\n    DarkSlateGray: fromRgb([0.185, 0.31, 0.31]),\n    DarkSlateGrey: fromRgb([0.185, 0.31, 0.31]),\n    DarkTurquoise: fromRgb([0, 0.808, 0.82]),\n    DarkViolet: fromRgb([0.58, 0, 0.828]),\n    DeepPink: fromRgb([1, 0.08, 0.576]),\n    DeepSkyBlue: fromRgb([0, 0.75, 1]),\n    DimGray: fromRgb([0.41, 0.41, 0.41]),\n    DimGrey: fromRgb([0.41, 0.41, 0.41]),\n    DodgerBlue: fromRgb([0.116, 0.565, 1]),\n    FireBrick: fromRgb([0.698, 0.132, 0.132]),\n    FloralWhite: fromRgb([1, 0.98, 0.94]),\n    ForestGreen: fromRgb([0.132, 0.545, 0.132]),\n    Fuchsia: fromRgb([1, 0, 1]),\n    Gainsboro: fromRgb([0.864, 0.864, 0.864]),\n    GhostWhite: fromRgb([0.972, 0.972, 1]),\n    Gold: fromRgb([1, 0.844, 0]),\n    Goldenrod: fromRgb([0.855, 0.648, 0.125]),\n    Gray: fromRgb([0.5, 0.5, 0.5]),\n    Green: fromRgb([0, 0.5, 0]),\n    GreenYellow: fromRgb([0.68, 1, 0.185]),\n    Grey: fromRgb([0.5, 0.5, 0.5]),\n    Honeydew: fromRgb([0.94, 1, 0.94]),\n    HotPink: fromRgb([1, 0.41, 0.705]),\n    IndianRed: fromRgb([0.804, 0.36, 0.36]),\n    Indigo: fromRgb([0.294, 0, 0.51]),\n    Ivory: fromRgb([1, 1, 0.94]),\n    Khaki: fromRgb([0.94, 0.9, 0.55]),\n    Lavender: fromRgb([0.9, 0.9, 0.98]),\n    LavenderBlush: fromRgb([1, 0.94, 0.96]),\n    LawnGreen: fromRgb([0.488, 0.99, 0]),\n    LemonChiffon: fromRgb([1, 0.98, 0.804]),\n    LightBlue: fromRgb([0.68, 0.848, 0.9]),\n    LightCoral: fromRgb([0.94, 0.5, 0.5]),\n    LightCyan: fromRgb([0.88, 1, 1]),\n    LightGoldenrod: fromRgb([0.933, 0.867, 0.51]),\n    LightGoldenrodYellow: fromRgb([0.98, 0.98, 0.824]),\n    LightGray: fromRgb([0.828, 0.828, 0.828]),\n    LightGreen: fromRgb([0.565, 0.932, 0.565]),\n    LightGrey: fromRgb([0.828, 0.828, 0.828]),\n    LightPink: fromRgb([1, 0.712, 0.756]),\n    LightSalmon: fromRgb([1, 0.628, 0.48]),\n    LightSeaGreen: fromRgb([0.125, 0.698, 0.668]),\n    LightSkyBlue: fromRgb([0.53, 0.808, 0.98]),\n    LightSlateBlue: fromRgb([0.518, 0.44, 1]),\n    LightSlateGray: fromRgb([0.468, 0.532, 0.6]),\n    LightSlateGrey: fromRgb([0.468, 0.532, 0.6]),\n    LightSteelBlue: fromRgb([0.69, 0.77, 0.87]),\n    LightYellow: fromRgb([1, 1, 0.88]),\n    Lime: fromRgb([0, 1, 0]),\n    LimeGreen: fromRgb([0.196, 0.804, 0.196]),\n    Linen: fromRgb([0.98, 0.94, 0.9]),\n    Magenta: fromRgb([1, 0, 1]),\n    Maroon: fromRgb([0.5, 0, 0]),\n    MediumAquamarine: fromRgb([0.4, 0.804, 0.668]),\n    MediumBlue: fromRgb([0, 0, 0.804]),\n    MediumOrchid: fromRgb([0.73, 0.332, 0.828]),\n    MediumPurple: fromRgb([0.576, 0.44, 0.86]),\n    MediumSeaGreen: fromRgb([0.235, 0.7, 0.444]),\n    MediumSlateBlue: fromRgb([0.484, 0.408, 0.932]),\n    MediumSpringGreen: fromRgb([0, 0.98, 0.604]),\n    MediumTurquoise: fromRgb([0.284, 0.82, 0.8]),\n    MediumVioletRed: fromRgb([0.78, 0.084, 0.52]),\n    MidnightBlue: fromRgb([0.098, 0.098, 0.44]),\n    MintCream: fromRgb([0.96, 1, 0.98]),\n    MistyRose: fromRgb([1, 0.894, 0.884]),\n    Moccasin: fromRgb([1, 0.894, 0.71]),\n    NavajoWhite: fromRgb([1, 0.87, 0.68]),\n    Navy: fromRgb([0, 0, 0.5]),\n    NavyBlue: fromRgb([0, 0, 0.5]),\n    OldLace: fromRgb([0.992, 0.96, 0.9]),\n    Olive: fromRgb([0.5, 0.5, 0]),\n    OliveDrab: fromRgb([0.42, 0.556, 0.136]),\n    Orange: fromRgb([1, 0.648, 0]),\n    OrangeRed: fromRgb([1, 0.27, 0]),\n    Orchid: fromRgb([0.855, 0.44, 0.84]),\n    PaleGoldenrod: fromRgb([0.932, 0.91, 0.668]),\n    PaleGreen: fromRgb([0.596, 0.985, 0.596]),\n    PaleTurquoise: fromRgb([0.688, 0.932, 0.932]),\n    PaleVioletRed: fromRgb([0.86, 0.44, 0.576]),\n    PapayaWhip: fromRgb([1, 0.936, 0.835]),\n    PeachPuff: fromRgb([1, 0.855, 0.725]),\n    Peru: fromRgb([0.804, 0.52, 0.248]),\n    Pink: fromRgb([1, 0.752, 0.796]),\n    Plum: fromRgb([0.868, 0.628, 0.868]),\n    PowderBlue: fromRgb([0.69, 0.88, 0.9]),\n    Purple: fromRgb([0.5, 0, 0.5]),\n    Red: fromRgb([1, 0, 0]),\n    RosyBrown: fromRgb([0.736, 0.56, 0.56]),\n    RoyalBlue: fromRgb([0.255, 0.41, 0.884]),\n    SaddleBrown: fromRgb([0.545, 0.27, 0.075]),\n    Salmon: fromRgb([0.98, 0.5, 0.448]),\n    SandyBrown: fromRgb([0.956, 0.644, 0.376]),\n    SeaGreen: fromRgb([0.18, 0.545, 0.34]),\n    Seashell: fromRgb([1, 0.96, 0.932]),\n    Sienna: fromRgb([0.628, 0.32, 0.176]),\n    Silver: fromRgb([0.752, 0.752, 0.752]),\n    SkyBlue: fromRgb([0.53, 0.808, 0.92]),\n    SlateBlue: fromRgb([0.415, 0.352, 0.804]),\n    SlateGray: fromRgb([0.44, 0.5, 0.565]),\n    SlateGrey: fromRgb([0.44, 0.5, 0.565]),\n    Snow: fromRgb([1, 0.98, 0.98]),\n    SpringGreen: fromRgb([0, 1, 0.498]),\n    SteelBlue: fromRgb([0.275, 0.51, 0.705]),\n    Tan: fromRgb([0.824, 0.705, 0.55]),\n    Teal: fromRgb([0, 0.5, 0.5]),\n    Thistle: fromRgb([0.848, 0.75, 0.848]),\n    Tomato: fromRgb([1, 0.39, 0.28]),\n    Turquoise: fromRgb([0.25, 0.88, 0.815]),\n    Violet: fromRgb([0.932, 0.51, 0.932]),\n    VioletRed: fromRgb([0.816, 0.125, 0.565]),\n    Wheat: fromRgb([0.96, 0.87, 0.7]),\n    White: fromRgb([1, 1, 1]),\n    WhiteSmoke: fromRgb([0.96, 0.96, 0.96]),\n    Yellow: fromRgb([1, 1, 0]),\n    YellowGreen: fromRgb([0.604, 0.804, 0.196]),\n};\n\nexport const X11_NAMES = {\n    AntiqueWhite1: fromRgb([1, 0.936, 0.86]),\n    AntiqueWhite2: fromRgb([0.932, 0.875, 0.8]),\n    AntiqueWhite3: fromRgb([0.804, 0.752, 0.69]),\n    AntiqueWhite4: fromRgb([0.545, 0.512, 0.47]),\n    Aquamarine1: fromRgb([0.498, 1, 0.83]),\n    Aquamarine2: fromRgb([0.464, 0.932, 0.776]),\n    Aquamarine3: fromRgb([0.4, 0.804, 0.668]),\n    Aquamarine4: fromRgb([0.27, 0.545, 0.455]),\n    Azure1: fromRgb([0.94, 1, 1]),\n    Azure2: fromRgb([0.88, 0.932, 0.932]),\n    Azure3: fromRgb([0.756, 0.804, 0.804]),\n    Azure4: fromRgb([0.512, 0.545, 0.545]),\n    Bisque1: fromRgb([1, 0.894, 0.77]),\n    Bisque2: fromRgb([0.932, 0.835, 0.716]),\n    Bisque3: fromRgb([0.804, 0.716, 0.62]),\n    Bisque4: fromRgb([0.545, 0.49, 0.42]),\n    Blue1: fromRgb([0, 0, 1]),\n    Blue2: fromRgb([0, 0, 0.932]),\n    Blue3: fromRgb([0, 0, 0.804]),\n    Blue4: fromRgb([0, 0, 0.545]),\n    Brown1: fromRgb([1, 0.25, 0.25]),\n    Brown2: fromRgb([0.932, 0.23, 0.23]),\n    Brown3: fromRgb([0.804, 0.2, 0.2]),\n    Brown4: fromRgb([0.545, 0.136, 0.136]),\n    Burlywood1: fromRgb([1, 0.828, 0.608]),\n    Burlywood2: fromRgb([0.932, 0.772, 0.57]),\n    Burlywood3: fromRgb([0.804, 0.668, 0.49]),\n    Burlywood4: fromRgb([0.545, 0.45, 0.332]),\n    CadetBlue1: fromRgb([0.596, 0.96, 1]),\n    CadetBlue2: fromRgb([0.556, 0.898, 0.932]),\n    CadetBlue3: fromRgb([0.48, 0.772, 0.804]),\n    CadetBlue4: fromRgb([0.325, 0.525, 0.545]),\n    Chartreuse1: fromRgb([0.498, 1, 0]),\n    Chartreuse2: fromRgb([0.464, 0.932, 0]),\n    Chartreuse3: fromRgb([0.4, 0.804, 0]),\n    Chartreuse4: fromRgb([0.27, 0.545, 0]),\n    Chocolate1: fromRgb([1, 0.498, 0.14]),\n    Chocolate2: fromRgb([0.932, 0.464, 0.13]),\n    Chocolate3: fromRgb([0.804, 0.4, 0.112]),\n    Chocolate4: fromRgb([0.545, 0.27, 0.075]),\n    Coral1: fromRgb([1, 0.448, 0.336]),\n    Coral2: fromRgb([0.932, 0.415, 0.312]),\n    Coral3: fromRgb([0.804, 0.356, 0.27]),\n    Coral4: fromRgb([0.545, 0.244, 0.185]),\n    Cornsilk1: fromRgb([1, 0.972, 0.864]),\n    Cornsilk2: fromRgb([0.932, 0.91, 0.804]),\n    Cornsilk3: fromRgb([0.804, 0.785, 0.694]),\n    Cornsilk4: fromRgb([0.545, 0.532, 0.47]),\n    Cyan1: fromRgb([0, 1, 1]),\n    Cyan2: fromRgb([0, 0.932, 0.932]),\n    Cyan3: fromRgb([0, 0.804, 0.804]),\n    Cyan4: fromRgb([0, 0.545, 0.545]),\n    DarkGoldenrod1: fromRgb([1, 0.725, 0.06]),\n    DarkGoldenrod2: fromRgb([0.932, 0.68, 0.055]),\n    DarkGoldenrod3: fromRgb([0.804, 0.585, 0.048]),\n    DarkGoldenrod4: fromRgb([0.545, 0.396, 0.03]),\n    DarkOliveGreen1: fromRgb([0.792, 1, 0.44]),\n    DarkOliveGreen2: fromRgb([0.736, 0.932, 0.408]),\n    DarkOliveGreen3: fromRgb([0.635, 0.804, 0.352]),\n    DarkOliveGreen4: fromRgb([0.43, 0.545, 0.24]),\n    DarkOrange1: fromRgb([1, 0.498, 0]),\n    DarkOrange2: fromRgb([0.932, 0.464, 0]),\n    DarkOrange3: fromRgb([0.804, 0.4, 0]),\n    DarkOrange4: fromRgb([0.545, 0.27, 0]),\n    DarkOrchid1: fromRgb([0.75, 0.244, 1]),\n    DarkOrchid2: fromRgb([0.698, 0.228, 0.932]),\n    DarkOrchid3: fromRgb([0.604, 0.196, 0.804]),\n    DarkOrchid4: fromRgb([0.408, 0.132, 0.545]),\n    DarkSeaGreen1: fromRgb([0.756, 1, 0.756]),\n    DarkSeaGreen2: fromRgb([0.705, 0.932, 0.705]),\n    DarkSeaGreen3: fromRgb([0.608, 0.804, 0.608]),\n    DarkSeaGreen4: fromRgb([0.41, 0.545, 0.41]),\n    DarkSlateGray1: fromRgb([0.592, 1, 1]),\n    DarkSlateGray2: fromRgb([0.552, 0.932, 0.932]),\n    DarkSlateGray3: fromRgb([0.475, 0.804, 0.804]),\n    DarkSlateGray4: fromRgb([0.32, 0.545, 0.545]),\n    DeepPink1: fromRgb([1, 0.08, 0.576]),\n    DeepPink2: fromRgb([0.932, 0.07, 0.536]),\n    DeepPink3: fromRgb([0.804, 0.064, 0.464]),\n    DeepPink4: fromRgb([0.545, 0.04, 0.312]),\n    DeepSkyBlue1: fromRgb([0, 0.75, 1]),\n    DeepSkyBlue2: fromRgb([0, 0.698, 0.932]),\n    DeepSkyBlue3: fromRgb([0, 0.604, 0.804]),\n    DeepSkyBlue4: fromRgb([0, 0.408, 0.545]),\n    DodgerBlue1: fromRgb([0.116, 0.565, 1]),\n    DodgerBlue2: fromRgb([0.11, 0.525, 0.932]),\n    DodgerBlue3: fromRgb([0.094, 0.455, 0.804]),\n    DodgerBlue4: fromRgb([0.064, 0.305, 0.545]),\n    Firebrick1: fromRgb([1, 0.19, 0.19]),\n    Firebrick2: fromRgb([0.932, 0.172, 0.172]),\n    Firebrick3: fromRgb([0.804, 0.15, 0.15]),\n    Firebrick4: fromRgb([0.545, 0.1, 0.1]),\n    Gold1: fromRgb([1, 0.844, 0]),\n    Gold2: fromRgb([0.932, 0.79, 0]),\n    Gold3: fromRgb([0.804, 0.68, 0]),\n    Gold4: fromRgb([0.545, 0.46, 0]),\n    Goldenrod1: fromRgb([1, 0.756, 0.145]),\n    Goldenrod2: fromRgb([0.932, 0.705, 0.132]),\n    Goldenrod3: fromRgb([0.804, 0.608, 0.112]),\n    Goldenrod4: fromRgb([0.545, 0.41, 0.08]),\n    Green1: fromRgb([0, 1, 0]),\n    Green2: fromRgb([0, 0.932, 0]),\n    Green3: fromRgb([0, 0.804, 0]),\n    Green4: fromRgb([0, 0.545, 0]),\n    Honeydew1: fromRgb([0.94, 1, 0.94]),\n    Honeydew2: fromRgb([0.88, 0.932, 0.88]),\n    Honeydew3: fromRgb([0.756, 0.804, 0.756]),\n    Honeydew4: fromRgb([0.512, 0.545, 0.512]),\n    HotPink1: fromRgb([1, 0.43, 0.705]),\n    HotPink2: fromRgb([0.932, 0.415, 0.655]),\n    HotPink3: fromRgb([0.804, 0.376, 0.565]),\n    HotPink4: fromRgb([0.545, 0.228, 0.385]),\n    IndianRed1: fromRgb([1, 0.415, 0.415]),\n    IndianRed2: fromRgb([0.932, 0.39, 0.39]),\n    IndianRed3: fromRgb([0.804, 0.332, 0.332]),\n    IndianRed4: fromRgb([0.545, 0.228, 0.228]),\n    Ivory1: fromRgb([1, 1, 0.94]),\n    Ivory2: fromRgb([0.932, 0.932, 0.88]),\n    Ivory3: fromRgb([0.804, 0.804, 0.756]),\n    Ivory4: fromRgb([0.545, 0.545, 0.512]),\n    Khaki1: fromRgb([1, 0.965, 0.56]),\n    Khaki2: fromRgb([0.932, 0.9, 0.52]),\n    Khaki3: fromRgb([0.804, 0.776, 0.45]),\n    Khaki4: fromRgb([0.545, 0.525, 0.305]),\n    LavenderBlush1: fromRgb([1, 0.94, 0.96]),\n    LavenderBlush2: fromRgb([0.932, 0.88, 0.898]),\n    LavenderBlush3: fromRgb([0.804, 0.756, 0.772]),\n    LavenderBlush4: fromRgb([0.545, 0.512, 0.525]),\n    LemonChiffon1: fromRgb([1, 0.98, 0.804]),\n    LemonChiffon2: fromRgb([0.932, 0.912, 0.75]),\n    LemonChiffon3: fromRgb([0.804, 0.79, 0.648]),\n    LemonChiffon4: fromRgb([0.545, 0.536, 0.44]),\n    LightBlue1: fromRgb([0.75, 0.936, 1]),\n    LightBlue2: fromRgb([0.698, 0.875, 0.932]),\n    LightBlue3: fromRgb([0.604, 0.752, 0.804]),\n    LightBlue4: fromRgb([0.408, 0.512, 0.545]),\n    LightCyan1: fromRgb([0.88, 1, 1]),\n    LightCyan2: fromRgb([0.82, 0.932, 0.932]),\n    LightCyan3: fromRgb([0.705, 0.804, 0.804]),\n    LightCyan4: fromRgb([0.48, 0.545, 0.545]),\n    LightGoldenrod1: fromRgb([1, 0.925, 0.545]),\n    LightGoldenrod2: fromRgb([0.932, 0.864, 0.51]),\n    LightGoldenrod3: fromRgb([0.804, 0.745, 0.44]),\n    LightGoldenrod4: fromRgb([0.545, 0.505, 0.298]),\n    LightPink1: fromRgb([1, 0.684, 0.725]),\n    LightPink2: fromRgb([0.932, 0.635, 0.68]),\n    LightPink3: fromRgb([0.804, 0.55, 0.585]),\n    LightPink4: fromRgb([0.545, 0.372, 0.396]),\n    LightSalmon1: fromRgb([1, 0.628, 0.48]),\n    LightSalmon2: fromRgb([0.932, 0.585, 0.448]),\n    LightSalmon3: fromRgb([0.804, 0.505, 0.385]),\n    LightSalmon4: fromRgb([0.545, 0.34, 0.26]),\n    LightSkyBlue1: fromRgb([0.69, 0.888, 1]),\n    LightSkyBlue2: fromRgb([0.644, 0.828, 0.932]),\n    LightSkyBlue3: fromRgb([0.552, 0.712, 0.804]),\n    LightSkyBlue4: fromRgb([0.376, 0.484, 0.545]),\n    LightSteelBlue1: fromRgb([0.792, 0.884, 1]),\n    LightSteelBlue2: fromRgb([0.736, 0.824, 0.932]),\n    LightSteelBlue3: fromRgb([0.635, 0.71, 0.804]),\n    LightSteelBlue4: fromRgb([0.43, 0.484, 0.545]),\n    LightYellow1: fromRgb([1, 1, 0.88]),\n    LightYellow2: fromRgb([0.932, 0.932, 0.82]),\n    LightYellow3: fromRgb([0.804, 0.804, 0.705]),\n    LightYellow4: fromRgb([0.545, 0.545, 0.48]),\n    Magenta1: fromRgb([1, 0, 1]),\n    Magenta2: fromRgb([0.932, 0, 0.932]),\n    Magenta3: fromRgb([0.804, 0, 0.804]),\n    Magenta4: fromRgb([0.545, 0, 0.545]),\n    Maroon1: fromRgb([1, 0.204, 0.7]),\n    Maroon2: fromRgb([0.932, 0.19, 0.655]),\n    Maroon3: fromRgb([0.804, 0.16, 0.565]),\n    Maroon4: fromRgb([0.545, 0.11, 0.385]),\n    MediumOrchid1: fromRgb([0.88, 0.4, 1]),\n    MediumOrchid2: fromRgb([0.82, 0.372, 0.932]),\n    MediumOrchid3: fromRgb([0.705, 0.32, 0.804]),\n    MediumOrchid4: fromRgb([0.48, 0.215, 0.545]),\n    MediumPurple1: fromRgb([0.67, 0.51, 1]),\n    MediumPurple2: fromRgb([0.624, 0.475, 0.932]),\n    MediumPurple3: fromRgb([0.536, 0.408, 0.804]),\n    MediumPurple4: fromRgb([0.365, 0.28, 0.545]),\n    MistyRose1: fromRgb([1, 0.894, 0.884]),\n    MistyRose2: fromRgb([0.932, 0.835, 0.824]),\n    MistyRose3: fromRgb([0.804, 0.716, 0.71]),\n    MistyRose4: fromRgb([0.545, 0.49, 0.484]),\n    NavajoWhite1: fromRgb([1, 0.87, 0.68]),\n    NavajoWhite2: fromRgb([0.932, 0.81, 0.63]),\n    NavajoWhite3: fromRgb([0.804, 0.7, 0.545]),\n    NavajoWhite4: fromRgb([0.545, 0.475, 0.37]),\n    OliveDrab1: fromRgb([0.752, 1, 0.244]),\n    OliveDrab2: fromRgb([0.7, 0.932, 0.228]),\n    OliveDrab3: fromRgb([0.604, 0.804, 0.196]),\n    OliveDrab4: fromRgb([0.41, 0.545, 0.132]),\n    Orange1: fromRgb([1, 0.648, 0]),\n    Orange2: fromRgb([0.932, 0.604, 0]),\n    Orange3: fromRgb([0.804, 0.52, 0]),\n    Orange4: fromRgb([0.545, 0.352, 0]),\n    OrangeRed1: fromRgb([1, 0.27, 0]),\n    OrangeRed2: fromRgb([0.932, 0.25, 0]),\n    OrangeRed3: fromRgb([0.804, 0.215, 0]),\n    OrangeRed4: fromRgb([0.545, 0.145, 0]),\n    Orchid1: fromRgb([1, 0.512, 0.98]),\n    Orchid2: fromRgb([0.932, 0.48, 0.912]),\n    Orchid3: fromRgb([0.804, 0.41, 0.79]),\n    Orchid4: fromRgb([0.545, 0.28, 0.536]),\n    PaleGreen1: fromRgb([0.604, 1, 0.604]),\n    PaleGreen2: fromRgb([0.565, 0.932, 0.565]),\n    PaleGreen3: fromRgb([0.488, 0.804, 0.488]),\n    PaleGreen4: fromRgb([0.33, 0.545, 0.33]),\n    PaleTurquoise1: fromRgb([0.732, 1, 1]),\n    PaleTurquoise2: fromRgb([0.684, 0.932, 0.932]),\n    PaleTurquoise3: fromRgb([0.59, 0.804, 0.804]),\n    PaleTurquoise4: fromRgb([0.4, 0.545, 0.545]),\n    PaleVioletRed1: fromRgb([1, 0.51, 0.67]),\n    PaleVioletRed2: fromRgb([0.932, 0.475, 0.624]),\n    PaleVioletRed3: fromRgb([0.804, 0.408, 0.536]),\n    PaleVioletRed4: fromRgb([0.545, 0.28, 0.365]),\n    PeachPuff1: fromRgb([1, 0.855, 0.725]),\n    PeachPuff2: fromRgb([0.932, 0.796, 0.68]),\n    PeachPuff3: fromRgb([0.804, 0.688, 0.585]),\n    PeachPuff4: fromRgb([0.545, 0.468, 0.396]),\n    Pink1: fromRgb([1, 0.71, 0.772]),\n    Pink2: fromRgb([0.932, 0.664, 0.72]),\n    Pink3: fromRgb([0.804, 0.57, 0.62]),\n    Pink4: fromRgb([0.545, 0.39, 0.424]),\n    Plum1: fromRgb([1, 0.732, 1]),\n    Plum2: fromRgb([0.932, 0.684, 0.932]),\n    Plum3: fromRgb([0.804, 0.59, 0.804]),\n    Plum4: fromRgb([0.545, 0.4, 0.545]),\n    Purple1: fromRgb([0.608, 0.19, 1]),\n    Purple2: fromRgb([0.57, 0.172, 0.932]),\n    Purple3: fromRgb([0.49, 0.15, 0.804]),\n    Purple4: fromRgb([0.332, 0.1, 0.545]),\n    Red1: fromRgb([1, 0, 0]),\n    Red2: fromRgb([0.932, 0, 0]),\n    Red3: fromRgb([0.804, 0, 0]),\n    Red4: fromRgb([0.545, 0, 0]),\n    RosyBrown1: fromRgb([1, 0.756, 0.756]),\n    RosyBrown2: fromRgb([0.932, 0.705, 0.705]),\n    RosyBrown3: fromRgb([0.804, 0.608, 0.608]),\n    RosyBrown4: fromRgb([0.545, 0.41, 0.41]),\n    RoyalBlue1: fromRgb([0.284, 0.464, 1]),\n    RoyalBlue2: fromRgb([0.264, 0.43, 0.932]),\n    RoyalBlue3: fromRgb([0.228, 0.372, 0.804]),\n    RoyalBlue4: fromRgb([0.152, 0.25, 0.545]),\n    Salmon1: fromRgb([1, 0.55, 0.41]),\n    Salmon2: fromRgb([0.932, 0.51, 0.385]),\n    Salmon3: fromRgb([0.804, 0.44, 0.33]),\n    Salmon4: fromRgb([0.545, 0.298, 0.224]),\n    SeaGreen1: fromRgb([0.33, 1, 0.624]),\n    SeaGreen2: fromRgb([0.305, 0.932, 0.58]),\n    SeaGreen3: fromRgb([0.264, 0.804, 0.5]),\n    SeaGreen4: fromRgb([0.18, 0.545, 0.34]),\n    Seashell1: fromRgb([1, 0.96, 0.932]),\n    Seashell2: fromRgb([0.932, 0.898, 0.87]),\n    Seashell3: fromRgb([0.804, 0.772, 0.75]),\n    Seashell4: fromRgb([0.545, 0.525, 0.51]),\n    Sienna1: fromRgb([1, 0.51, 0.28]),\n    Sienna2: fromRgb([0.932, 0.475, 0.26]),\n    Sienna3: fromRgb([0.804, 0.408, 0.224]),\n    Sienna4: fromRgb([0.545, 0.28, 0.15]),\n    SkyBlue1: fromRgb([0.53, 0.808, 1]),\n    SkyBlue2: fromRgb([0.494, 0.752, 0.932]),\n    SkyBlue3: fromRgb([0.424, 0.65, 0.804]),\n    SkyBlue4: fromRgb([0.29, 0.44, 0.545]),\n    SlateBlue1: fromRgb([0.512, 0.435, 1]),\n    SlateBlue2: fromRgb([0.48, 0.404, 0.932]),\n    SlateBlue3: fromRgb([0.41, 0.35, 0.804]),\n    SlateBlue4: fromRgb([0.28, 0.235, 0.545]),\n    SlateGray1: fromRgb([0.776, 0.888, 1]),\n    SlateGray2: fromRgb([0.725, 0.828, 0.932]),\n    SlateGray3: fromRgb([0.624, 0.712, 0.804]),\n    SlateGray4: fromRgb([0.424, 0.484, 0.545]),\n    Snow1: fromRgb([1, 0.98, 0.98]),\n    Snow2: fromRgb([0.932, 0.912, 0.912]),\n    Snow3: fromRgb([0.804, 0.79, 0.79]),\n    Snow4: fromRgb([0.545, 0.536, 0.536]),\n    SpringGreen1: fromRgb([0, 1, 0.498]),\n    SpringGreen2: fromRgb([0, 0.932, 0.464]),\n    SpringGreen3: fromRgb([0, 0.804, 0.4]),\n    SpringGreen4: fromRgb([0, 0.545, 0.27]),\n    SteelBlue1: fromRgb([0.39, 0.72, 1]),\n    SteelBlue2: fromRgb([0.36, 0.675, 0.932]),\n    SteelBlue3: fromRgb([0.31, 0.58, 0.804]),\n    SteelBlue4: fromRgb([0.21, 0.392, 0.545]),\n    Tan1: fromRgb([1, 0.648, 0.31]),\n    Tan2: fromRgb([0.932, 0.604, 0.288]),\n    Tan3: fromRgb([0.804, 0.52, 0.248]),\n    Tan4: fromRgb([0.545, 0.352, 0.17]),\n    Thistle1: fromRgb([1, 0.884, 1]),\n    Thistle2: fromRgb([0.932, 0.824, 0.932]),\n    Thistle3: fromRgb([0.804, 0.71, 0.804]),\n    Thistle4: fromRgb([0.545, 0.484, 0.545]),\n    Tomato1: fromRgb([1, 0.39, 0.28]),\n    Tomato2: fromRgb([0.932, 0.36, 0.26]),\n    Tomato3: fromRgb([0.804, 0.31, 0.224]),\n    Tomato4: fromRgb([0.545, 0.21, 0.15]),\n    Turquoise1: fromRgb([0, 0.96, 1]),\n    Turquoise2: fromRgb([0, 0.898, 0.932]),\n    Turquoise3: fromRgb([0, 0.772, 0.804]),\n    Turquoise4: fromRgb([0, 0.525, 0.545]),\n    VioletRed1: fromRgb([1, 0.244, 0.59]),\n    VioletRed2: fromRgb([0.932, 0.228, 0.55]),\n    VioletRed3: fromRgb([0.804, 0.196, 0.47]),\n    VioletRed4: fromRgb([0.545, 0.132, 0.32]),\n    Wheat1: fromRgb([1, 0.905, 0.73]),\n    Wheat2: fromRgb([0.932, 0.848, 0.684]),\n    Wheat3: fromRgb([0.804, 0.73, 0.59]),\n    Wheat4: fromRgb([0.545, 0.494, 0.4]),\n    Yellow1: fromRgb([1, 1, 0]),\n    Yellow2: fromRgb([0.932, 0.932, 0]),\n    Yellow3: fromRgb([0.804, 0.804, 0]),\n    Yellow4: fromRgb([0.545, 0.545, 0]),\n    Gray0: fromRgb([0.745, 0.745, 0.745]),\n    Green0: fromRgb([0, 1, 0]),\n    Grey0: fromRgb([0.745, 0.745, 0.745]),\n    Maroon0: fromRgb([0.69, 0.19, 0.376]),\n    Purple0: fromRgb([0.628, 0.125, 0.94]),\n};\n", "import { XColorPegParser } from \"@unified-latex/unified-latex-util-pegjs\";\nimport * as XColorSpec from \"./types\";\n\nconst parseCache: Record<string, XColorSpec.Ast> = {};\n\n/**\n * Parse an `xparse` argument specification string to an AST.\n * This function caches results. Don't mutate the returned AST!\n *\n * @param {string} [str=\"\"] - LaTeX string input\n * @returns - AST for LaTeX string\n */\nexport function parse(str = \"\"): XColorSpec.Ast {\n    parseCache[str] =\n        parseCache[str] || (XColorPegParser.parse(str) as XColorSpec.Ast);\n    return parseCache[str];\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { getArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { xcolorColorToHex } from \"./xcolor\";\nimport { structuredClone } from \"@unified-latex/structured-clone\";\nimport { deleteComments } from \"@unified-latex/unified-latex-util-comments\";\n\n/**\n * Compute the hex representation of a color specified by an xcolor color command.\n * For example `\\color[rgb]{1 .5 .5}` or `\\textcolor{red}{foo}`. If the color cannot be parsed,\n * `null` is returned for the hex value. In all cases a css variable name (prefixed with \"--\"\")\n * is returned. This can be used to set up CSS for custom colors.\n */\nexport function xcolorMacroToHex(node: Ast.Macro): {\n    hex: string | null;\n    cssVarName: string;\n} {\n    // We do some destructive operations on the node, so clone it first.\n    node = structuredClone(node);\n    deleteComments(node);\n\n    // We assume the node has signature \"o m\" where o is the model and\n    // m is the color spec.\n\n    const args = getArgsContent(node);\n    const model = args[0] && printRaw(args[0]);\n    const colorStr = printRaw(args[1] || []);\n    let hex: string | null = null;\n    try {\n        hex = xcolorColorToHex(colorStr, model);\n    } catch (e) {}\n\n    const cssVarName = \"--\" + colorStr.replace(/[^a-zA-Z0-9-_]/g, \"-\");\n\n    return { hex, cssVarName };\n}\n", "import { arg } from \"@unified-latex/unified-latex-builder\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Create a `\\textcolor` macro. Color arguments are taken from `origMacro`.\n */\nexport function colorToTextcolorMacro(\n    content: Ast.Node | Ast.Node[],\n    origMacro: Ast.Macro\n): Ast.Macro {\n    if (!Array.isArray(content)) {\n        content = [content];\n    }\n    // Signature of \\color is \"o m\".\n    // We want to carry through the same arguments\n    const args = (\n        origMacro.args\n            ? origMacro.args\n            : [arg([], { closeMark: \"\", openMark: \"\" }), arg([])]\n    ).concat(arg(content));\n\n    return {\n        type: \"macro\",\n        content: \"textcolor\",\n        args,\n        _renderInfo: { inParMode: true },\n    };\n}", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    NewDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    RenewDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    ProvideDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    DeclareDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    NewDocumentEnvironment: {\n        signature: \"m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    RenewDocumentEnvironment: {\n        signature: \"m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    ProvideDocumentEnvironment: {\n        signature: \"m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    DeclareDocumentEnvironment: {\n        signature: \"m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    NewExpandableDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    RenewExpandableDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    ProvideExpandableDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    DeclareExpandableDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    RequirePackage: {\n        signature: \"o m\",\n        renderInfo: { pgfkeysArgs: true, breakAround: true },\n    },\n    DeclareOption: { signature: \"m m\", renderInfo: { breakAround: true } },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    mode: { signature: \"s d<> d{}\", renderInfo: { breakAround: true } },\n    insertnavigation: { signature: \"m\", renderInfo: { breakAround: true } },\n    insertsectionnavigation: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    insertsectionnavigationhorizontal: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    insertauthor: { signature: \"o\", renderInfo: { breakAround: true } },\n    insertshortauthor: { signature: \"o\", renderInfo: { breakAround: true } },\n    insertshortdate: { signature: \"o\", renderInfo: { breakAround: true } },\n    insertshortinstitute: { signature: \"o\", renderInfo: { breakAround: true } },\n    insertshortpart: { signature: \"o\", renderInfo: { breakAround: true } },\n    insertshorttitle: { signature: \"o\", renderInfo: { breakAround: true } },\n    insertsubsectionnavigation: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    insertsubsectionnavigationhorizontal: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    insertverticalnavigation: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    usebeamercolor: { signature: \"s m\", renderInfo: { breakAround: true } },\n    usebeamertemplate: { signature: \"s m\", renderInfo: { breakAround: true } },\n    setbeamercolor: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    setbeamersize: {\n        signature: \"m o o\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    setbeamertemplate: {\n        signature: \"m o o d{}\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n\n    newcommand: {\n        signature: \"s d<> +m o +o +m\",\n        renderInfo: {\n            breakAround: true,\n            namedArguments: [\n                \"starred\",\n                null,\n                \"name\",\n                \"numArgs\",\n                \"default\",\n                \"body\",\n            ],\n        },\n    },\n    renewcommand: {\n        signature: \"s d<> +m o +o +m\",\n        renderInfo: {\n            breakAround: true,\n            namedArguments: [\n                \"starred\",\n                null,\n                \"name\",\n                \"numArgs\",\n                \"default\",\n                \"body\",\n            ],\n        },\n    },\n    newenvironment: {\n        signature: \"s d<> m o o m m\",\n        renderInfo: { breakAround: true },\n    },\n    renewenvironment: {\n        signature: \"s d<> m o o m m\",\n        renderInfo: { breakAround: true },\n    },\n    resetcounteronoverlays: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    resetcountonoverlays: { signature: \"m\", renderInfo: { breakAround: true } },\n\n    logo: { signature: \"m\", renderInfo: { breakAround: true } },\n    frametitle: { signature: \"d<> o m\", renderInfo: { breakAround: true } },\n    framesubtitle: { signature: \"d<> m\", renderInfo: { breakAround: true } },\n    pause: { signature: \"o\" },\n    onslide: { signature: \"t+ t* d<> d{}\" },\n    only: { signature: \"d<> m d<>\" },\n    uncover: { signature: \"d<> m\" },\n    visible: { signature: \"d<> m\" },\n    invisible: { signature: \"d<> m\" },\n    alt: { signature: \"d<> m m d<>\" },\n    temporal: { signature: \"r<> m m m\" },\n    item: {\n        signature: \"d<> o d<>\",\n        renderInfo: {\n            hangingIndent: true,\n            namedArguments: [null, \"label\", null],\n        },\n    },\n    label: { signature: \"d<> o m\" }, // cleveref adds an optional argument to label; this gives maximum compatibility.\n    action: { signature: \"d<> m\" },\n    beamerdefaultoverlayspecification: { signature: \"m\" },\n\n    titlegraphic: { signature: \"m\", renderInfo: { breakAround: true } },\n    subject: { signature: \"m\", renderInfo: { breakAround: true } },\n    keywords: { signature: \"m\", renderInfo: { breakAround: true } },\n\n    lecture: { signature: \"o m m\", renderInfo: { breakAround: true } },\n    partpage: { renderInfo: { breakAround: true } },\n    sectionpage: { renderInfo: { breakAround: true } },\n    subsectionpage: { renderInfo: { breakAround: true } },\n    AtBeginLecture: { signature: \"m\", renderInfo: { breakAround: true } },\n    AtBeginPart: { signature: \"m\", renderInfo: { breakAround: true } },\n    tableofcontents: {\n        signature: \"o\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    againframe: { signature: \"d<> o o m\", renderInfo: { breakAround: true } },\n    framezoom: {\n        signature: \"r<> r<> o r() r()\",\n        renderInfo: { breakAround: true },\n    },\n    column: { signature: \"d<> o m\", renderInfo: { breakAround: true } },\n\n    animate: { signature: \"r<>\", renderInfo: { breakAround: true } },\n    animatevalue: { signature: \"r<> m m m\", renderInfo: { breakAround: true } },\n    sound: {\n        signature: \"o m m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    hyperlinksound: {\n        signature: \"o m m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    hyperlinkmute: { signature: \"m\", renderInfo: { breakAround: true } },\n\n    // These signatures conflict with the default signatures.\n    // Care must be taken when processing an AST.\n    section: {\n        signature: \"s d<> o m\",\n        renderInfo: {\n            breakAround: true,\n            namedArguments: [\"starred\", null, \"tocTitle\", \"title\"],\n        },\n    },\n    subsection: {\n        signature: \"s d<> o m\",\n        renderInfo: {\n            breakAround: true,\n            namedArguments: [\"starred\", null, \"tocTitle\", \"title\"],\n        },\n    },\n    subsubsection: {\n        signature: \"s d<> o m\",\n        renderInfo: {\n            breakAround: true,\n            namedArguments: [\"starred\", null, \"tocTitle\", \"title\"],\n        },\n    },\n    part: {\n        signature: \"s d<> o m\",\n        renderInfo: {\n            breakAround: true,\n            namedArguments: [\"starred\", null, \"tocTitle\", \"title\"],\n        },\n    },\n    bibitem: {\n        signature: \"s d<> o m\",\n        renderInfo: {\n            hangingIndent: true,\n            namedArguments: [\"starred\", null, \"tocTitle\", \"title\"],\n        },\n    },\n};\n\nexport const environments: EnvInfoRecord = {\n    frame: {\n        signature: \"!d<> !o !o !d{} !d{}\",\n    },\n    block: {\n        signature: \"!d<> !d{} !d<>\",\n    },\n    alertblock: {\n        signature: \"!d<> !d{} !d<>\",\n    },\n    exampleblock: {\n        signature: \"!d<> !d{} !d<>\",\n    },\n    onlyenv: {\n        signature: \"!d<>\",\n    },\n    altenv: {\n        signature: \"!d<> m m m m !d<>\",\n    },\n    overlayarea: { signature: \"m m\" },\n    overprint: { signature: \"o\" },\n    actionenv: { signature: \"!d<>\" },\n    columns: { signature: \"d<> o\" },\n    column: { signature: \"d<> o m\" },\n};\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    columnbreak: { renderInfo: { breakAround: true } },\n};\n\nexport const environments: EnvInfoRecord = {\n    multicols: {\n        signature: \"m o o\",\n    },\n    \"multicols*\": {\n        signature: \"m o o\",\n    },\n};\n", "import * as cleveref from \"./package/cleveref\";\nimport * as exam from \"./package/exam\";\nimport * as geometry from \"./package/geometry\";\nimport * as hyperref from \"./package/hyperref\";\nimport * as latex2e from \"./package/latex2e\";\nimport * as listings from \"./package/listings\";\nimport * as makeidx from \"./package/makeidx\";\nimport * as mathtools from \"./package/mathtools\";\nimport * as minted from \"./package/minted\";\nimport * as nicematrix from \"./package/nicematrix\";\nimport * as systeme from \"./package/systeme\";\nimport * as tikz from \"./package/tikz\";\nimport * as xcolor from \"./package/xcolor\";\nimport * as xparse from \"./package/xparse\";\nimport * as beamer from \"./package/beamer\";\nimport * as multicol from \"./package/multicol\";\n\n/**\n * Info about the macros for available ctan packages. `latex2e` contains\n * the standard macros for LaTeX.\n */\nexport const macroInfo = {\n    cleveref: cleveref.macros,\n    exam: exam.macros,\n    geometry: geometry.macros,\n    hyperref: hyperref.macros,\n    latex2e: latex2e.macros,\n    listings: listings.macros,\n    makeidx: makeidx.macros,\n    mathtools: mathtools.macros,\n    minted: minted.macros,\n    nicematrix: nicematrix.macros,\n    systeme: systeme.macros,\n    tikz: tikz.macros,\n    xcolor: xcolor.macros,\n    xparse: xparse.macros,\n    beamer: beamer.macros,\n    multicol: multicol.macros,\n};\n\n/**\n * Info about the environments for available ctan packages. `latex2e` contains\n * the standard environments for LaTeX.\n */\nexport const environmentInfo = {\n    cleveref: cleveref.environments,\n    exam: exam.environments,\n    geometry: geometry.environments,\n    hyperref: hyperref.environments,\n    latex2e: latex2e.environments,\n    listings: listings.environments,\n    makeidx: makeidx.environments,\n    mathtools: mathtools.environments,\n    minted: minted.environments,\n    nicematrix: nicematrix.environments,\n    systeme: systeme.environments,\n    tikz: tikz.environments,\n    xcolor: xcolor.environments,\n    xparse: xparse.environments,\n    beamer: beamer.environments,\n    multicol: multicol.environments,\n};\n\n// NOTE: The docstring comment must be the last item in the index.ts file!\n/**\n * ## What is this?\n *\n * Macro/environment definitions and utilities for specific LaTeX packages from CTAN.\n *\n * Note: basic LaTeX macro/environment definitions come from the `latex2e` package, even though\n * this is technically not a CTAN \"package\".\n *\n * ## When should I use this?\n *\n * If you want information about special functions/macros from particular CTAN packages, or\n * you need to parse special environments.\n *\n * ## Notes\n *\n * By default all macros/environments that are exported get processed. If multiple packages\n * export a macro with the same name, then the later-exported one takes precedence. If two packages\n * export a macro/environment of the same name but with conflicting argument signatures, this can\n * cause issues when another unified-latex package processes arguments positionally. For example,\n * by default `\\textbf` takes one argument, but the beamer version of `\\textbf` takes two arguments.\n * During HTML conversion, if arguments are referenced positionally, this may cause previously-working\n * code to fail with when beamer macro signatures are used. A workaround is provided: `_renderInfo.namedArguments`.\n * If `_renderInfo.namedArguments` is specified on both the original macro/environment definition\n * **and** the conflicting one, other unified-latex commands can reference arguments by name instead\n * of by position.\n */\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { EnvInfo, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\nimport { gobbleArguments } from \"@unified-latex/unified-latex-util-arguments\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\n/**\n * Performs any needed processing on the environment (as specified by `envInfo`)\n * including attaching arguments and possibly manipulating the environment's body.\n */\nexport function processEnvironment(envNode: Ast.Environment, envInfo: EnvInfo) {\n    if (envInfo.signature && envNode.args == null) {\n        const { args } = gobbleArguments(envNode.content, envInfo.signature);\n        envNode.args = args;\n    }\n\n    updateRenderInfo(envNode, envInfo.renderInfo);\n    if (typeof envInfo.processContent === \"function\") {\n        envNode.content = envInfo.processContent(envNode.content);\n    }\n}\n\n/**\n * Recursively search for and process the specified environments. Arguments are\n * consumed according to the `signature` specified. The body is processed\n * with the specified `processContent` function (if given). Any specified `renderInfo`\n * is attached to the environment node.\n */\nexport function processEnvironments(\n    tree: Ast.Ast,\n    environments: EnvInfoRecord\n) {\n    const isRelevantEnvironment = match.createEnvironmentMatcher(environments);\n\n    visit(\n        tree,\n        {\n            leave: (node) => {\n                const envName = printRaw(node.env);\n                const envInfo = environments[envName];\n                if (!envInfo) {\n                    throw new Error(\n                        `Could not find environment info for environment \"${envName}\"`\n                    );\n                }\n                processEnvironment(node, envInfo);\n            },\n        },\n        { test: isRelevantEnvironment }\n    );\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { Plugin } from \"unified\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { processEnvironment } from \"./process-environment\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\ntype PluginOptions = { environments: EnvInfoRecord } | undefined;\n\n/**\n * Unified plugin to process environment content and attach arguments.\n *\n * @param environments An object whose keys are environment names and values contains information about the environment and its argument signature.\n */\nexport const unifiedLatexProcessEnvironments: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexAttachMacroArguments(options) {\n    const { environments = {} } = options || {};\n    const isRelevantEnvironment = match.createEnvironmentMatcher(environments);\n\n    return (tree) => {\n        if (Object.keys(environments).length === 0) {\n            console.warn(\n                \"Attempting to attach macro arguments but no macros are specified.\"\n            );\n        }\n\n        visit(\n            tree,\n            {\n                leave: (node) => {\n                    const envName = printRaw(node.env);\n                    const envInfo = environments[envName];\n                    if (!envInfo) {\n                        throw new Error(\n                            `Could not find environment info for environment \"${envName}\"`\n                        );\n                    }\n                    processEnvironment(node, envInfo);\n                },\n            },\n            { test: isRelevantEnvironment }\n        );\n    };\n};\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { Region } from \"./regions\";\n\n/**\n * Find all contiguous segments in the array that are between start and end blocks.\n * The `start` and `end` are functions that determine when a region starts and ends.\n */\nexport function findRegionInArray(\n    tree: Ast.Node[],\n    start: (node: Ast.Node) => boolean,\n    end: (node: Ast.Node) => boolean\n): Region[] {\n    const ret: Region[] = [];\n    let currRegion: Region = { start: undefined as any, end: tree.length };\n    for (let i = 0; i < tree.length; i++) {\n        const node = tree[i];\n        if (start(node)) {\n            currRegion.start = i;\n        }\n        if (end(node)) {\n            currRegion.end = i + 1;\n            ret.push(currRegion);\n            currRegion = { start: undefined as any, end: tree.length };\n        }\n    }\n\n    if (currRegion.start != null) {\n        // Regions don't necessarily have to encounter an `end` to end.\n        ret.push(currRegion);\n    }\n    return ret;\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { findRegionInArray } from \"./find-region\";\nimport { refineRegions, Region, splitByRegions } from \"./regions\";\nimport { SKIP, visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { reparseMacroNames } from \"./reparse-macro-names\";\n\nconst expl3Find = {\n    start: match.createMacroMatcher([\"ExplSyntaxOn\"]),\n    end: match.createMacroMatcher([\"ExplSyntaxOff\"]),\n};\nconst atLetterFind = {\n    start: match.createMacroMatcher([\"makeatletter\"]),\n    end: match.createMacroMatcher([\"makeatother\"]),\n};\n\n/**\n * Find regions between `\\ExplSyntaxOn...\\ExplSyntaxOff` and `\\makeatletter...\\makeatother`.\n * Returns an object containing regions where one or both syntax's apply.\n */\nexport function findExpl3AndAtLetterRegionsInArray(tree: Ast.Node[]): {\n    explOnly: Region[];\n    atLetterOnly: Region[];\n    both: Region[];\n} {\n    const expl3 = findRegionInArray(tree, expl3Find.start, expl3Find.end);\n    const atLetter = findRegionInArray(\n        tree,\n        atLetterFind.start,\n        atLetterFind.end\n    );\n\n    const regionMap = new Map([\n        ...(expl3.map((x) => [x, \"expl\"]) as [Region, \"expl\"][]),\n        ...(atLetter.map((x) => [x, \"atLetter\"]) as [Region, \"atLetter\"][]),\n    ]);\n    const all = refineRegions([...expl3, ...atLetter]);\n\n    const ret = {\n        explOnly: [] as Region[],\n        atLetterOnly: [] as Region[],\n        both: [] as Region[],\n    };\n\n    for (let i = 0; i < all.regions.length; i++) {\n        const region = all.regions[i];\n        const containedIn = all.regionsContainedIn[i];\n        if (containedIn.size === 2) {\n            ret.both.push(region);\n            continue;\n        }\n        for (const v of containedIn.values()) {\n            if (regionMap.get(v) === \"expl\") {\n                ret.explOnly.push(region);\n            }\n            if (regionMap.get(v) === \"atLetter\") {\n                ret.atLetterOnly.push(region);\n            }\n        }\n    }\n\n    // Regions of size 1 only contain the starting/stopping macro, so they should be discarded\n    ret.explOnly = ret.explOnly.filter((r) => r.end - r.start > 1);\n    ret.atLetterOnly = ret.atLetterOnly.filter((r) => r.end - r.start > 1);\n    ret.both = ret.both.filter((r) => r.end - r.start > 1);\n\n    return ret;\n}\n\nconst atLetterSet = new Set([\"@\"]);\nconst explSet = new Set([\"_\", \":\"]);\nconst bothSet = new Set([\"_\", \":\", \"@\"]);\n\n/**\n * Find regions between `\\ExplSyntaxOn...\\ExplSyntaxOff` and `\\makeatletter...\\makeatother`\n * and reparse their contents so that the relevant characters (e.g., `@`, `_`, and `:`) become\n * part of the macro names.\n */\nexport function reparseExpl3AndAtLetterRegions(tree: Ast.Ast) {\n    visit(\n        tree,\n        {\n            leave: (nodes) => {\n                const regions = findExpl3AndAtLetterRegionsInArray(nodes);\n                // In all likelihood, we don't need to do any reparsing, so bail early here\n                const totalNumRegions =\n                    regions.both.length +\n                    regions.atLetterOnly.length +\n                    regions.explOnly.length;\n                if (totalNumRegions === 0) {\n                    return;\n                }\n\n                const splits = splitByRegions(nodes, regions);\n                const processed: typeof nodes = [];\n                for (const [key, slice] of splits) {\n                    switch (key) {\n                        case null:\n                            processed.push(...slice);\n                            continue;\n                        case \"atLetterOnly\":\n                            reparseMacroNames(slice, atLetterSet);\n                            processed.push(...slice);\n                            continue;\n                        case \"explOnly\":\n                            reparseMacroNames(slice, explSet);\n                            processed.push(...slice);\n                            continue;\n                        case \"both\":\n                            reparseMacroNames(slice, bothSet);\n                            processed.push(...slice);\n                            continue;\n                        default:\n                            throw new Error(\n                                `Unexpected case when splitting ${key}`\n                            );\n                    }\n                }\n\n                nodes.length = 0;\n                nodes.push(...processed);\n                return SKIP;\n            },\n        },\n        { includeArrays: true, test: Array.isArray }\n    );\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\n\nexport type Region = { start: number; end: number };\n\n/**\n * Given `regions`, a list of `Region`s (not necessarily ordered, possibly overlapping), return a list of in-order,\n * non-overlapping regions and a corresponding list containing a set of the original `Region`s that the new region\n * is a subset of.\n */\nexport function refineRegions(regions: Region[]): {\n    regions: Region[];\n    regionsContainedIn: Set<Region>[];\n} {\n    const _regions = [...regions];\n    _regions.sort((a, b) => a.start - b.start);\n    const cutPointsSet = new Set(_regions.flatMap((r) => [r.start, r.end]));\n    const cutPoints = Array.from(cutPointsSet);\n    cutPoints.sort((a, b) => a - b);\n\n    const retRegions: Region[] = [];\n    const retRegionsContainedIn: Set<Region>[] = [];\n\n    // We will be checking what regions we are completely contained in.\n    // Because `_regions` is sorted by start, `seekIndex` will be incremented\n    // by end, so that we don't do too much array testing.\n    let seekIndex = 0;\n    for (let i = 0; i < cutPoints.length - 1; i++) {\n        const start = cutPoints[i];\n        const end = cutPoints[i + 1];\n        const region = { start, end };\n        const regionContainedIn: Set<Region> = new Set();\n\n        let encounteredEndPastStart = false;\n        for (let j = seekIndex; j < _regions.length; j++) {\n            const superRegion = _regions[j];\n            if (superRegion.end >= region.start) {\n                encounteredEndPastStart = true;\n            }\n            if (!encounteredEndPastStart && superRegion.end < region.start) {\n                // In this case, the region (and all regions that came before)\n                // end before the region we are testing, so we may safely skip past it\n                // from here on out.\n                seekIndex = j + 1;\n                continue;\n            }\n\n            if (superRegion.start > end) {\n                // Because `_regions` is sorted, we can stop here\n                break;\n            }\n            if (\n                superRegion.start <= region.start &&\n                superRegion.end >= region.end\n            ) {\n                encounteredEndPastStart = true;\n                regionContainedIn.add(superRegion);\n            }\n        }\n\n        if (regionContainedIn.size > 0) {\n            // We only count if we are contained in a subregion\n            retRegions.push(region);\n            retRegionsContainedIn.push(regionContainedIn);\n        }\n    }\n\n    return { regions: retRegions, regionsContainedIn: retRegionsContainedIn };\n}\n\n/**\n * Split an array up into the disjoint regions specified by `regionRecord`.\n * Returned is a list of tuples, the first item being the key of `regionRecord` if there\n * was a corresponding region, or `null` if there was no corresponding region.\n *\n * This function assumes that the regions in `regionRecord` are disjoint and fully contained\n * within the bounds of `array`.\n */\nexport function splitByRegions<\n    T extends unknown,\n    RegionRecord extends Record<string, Region[]>\n>(array: T[], regionsRecord: RegionRecord) {\n    const ret: [keyof RegionRecord | null, T[]][] = [];\n\n    const indices = [0, array.length];\n    const reverseMap: Record<string, keyof RegionRecord> = {};\n    for (const [key, records] of Object.entries(regionsRecord)) {\n        indices.push(\n            ...records.flatMap((r) => {\n                reverseMap[\"\" + [r.start, r.end]] = key;\n                return [r.start, r.end];\n            })\n        );\n    }\n    indices.sort((a, b) => a - b);\n\n    for (let i = 0; i < indices.length - 1; i++) {\n        const start = indices[i];\n        const end = indices[i + 1];\n        if (start === end) {\n            continue;\n        }\n        const regionKey = reverseMap[\"\" + [start, end]];\n\n        ret.push([regionKey || null, array.slice(start, end)]);\n    }\n\n    return ret;\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { EXIT, visit } from \"@unified-latex/unified-latex-util-visit\";\n\n/**\n * Escape a string so that it can be used to build a regular expression.\n *\n * From: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n */\nfunction escapeRegExp(str: string) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n}\n\n/**\n * Build a regular expression that matches everything up to the first non-allowed symbol.\n */\nfunction buildWordRegex(allowedSet: Set<string>): RegExp {\n    // /\\p{L}/ matches all letters, including unicode letters. We join this with\n    // everything allowed in our set to form a regexp like\n    //   /(\\p{L}|_|:)*/u\n    // The `u` at the end allows unicode characters to be matched.\n    const regexpStr = `^(${[\"\\\\p{L}\"]\n        .concat(Array.from(allowedSet).map(escapeRegExp))\n        .join(\"|\")})*`;\n    return new RegExp(regexpStr, \"u\");\n}\n\n/**\n * Checks whether the array has a macro that could be reparsed given the `allowedTokens` but\n * do not do any reparsing. This function can be used in auto-detection schemes to determine if\n * macro names should actually be reparsed.\n */\nexport function hasReparsableMacroNamesInArray(\n    tree: Ast.Node[],\n    allowedTokens: Set<string>\n): boolean {\n    for (let i = 0; i < tree.length; i++) {\n        const macro = tree[i];\n        const string = tree[i + 1];\n        if (match.anyMacro(macro) && match.anyString(string)) {\n            // There are two options. Either the macro ends with the special character,\n            // e.g. `\\@foo` or the special character starts the next string, e.g. `\\foo@`.\n            if (\n                allowedTokens.has(\n                    macro.content.charAt(macro.content.length - 1)\n                ) ||\n                allowedTokens.has(string.content.charAt(0))\n            ) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Checks whether `tree` has a macro that could be reparsed given the `allowedTokens` but\n * do not do any reparsing. This function can be used in auto-detection schemes to determine if\n * macro names should actually be reparsed.\n */\nexport function hasReparsableMacroNames(\n    tree: Ast.Ast,\n    allowedTokens: string | Set<string>\n): boolean {\n    if (typeof allowedTokens === \"string\") {\n        allowedTokens = new Set(allowedTokens.split(\"\"));\n    }\n    // Recast so typescript doesn't complain\n    const _allowedTokens = allowedTokens;\n    for (const v of _allowedTokens) {\n        if (v.length > 1) {\n            throw new Error(\n                `Only single characters are allowed as \\`allowedTokens\\` when reparsing macro names, not \\`${v}\\`.`\n            );\n        }\n    }\n\n    let ret = false;\n    visit(\n        tree,\n        (nodes) => {\n            if (hasReparsableMacroNamesInArray(nodes, _allowedTokens)) {\n                ret = true;\n                return EXIT;\n            }\n        },\n        { includeArrays: true, test: Array.isArray }\n    );\n    return ret;\n}\n\n/**\n * Reparses all macro names in the array so that they may optionally include characters listed in `allowedTokens`.\n * This is used, for example, when parsing expl3 syntax which allows `_` to be used in a macro name (even though\n * `_` is normally stops the parsing for a macro name).\n */\nexport function reparseMacroNamesInArray(\n    tree: Ast.Node[],\n    allowedTokens: Set<string>\n) {\n    const regex = buildWordRegex(allowedTokens);\n    let i = 0;\n    while (i < tree.length) {\n        const macro = tree[i];\n        const string = tree[i + 1];\n        if (\n            match.anyMacro(macro) &&\n            // The _^ macros in math mode should not be extended no-matter what;\n            // So we check to make sure that the macro we're dealing with has the default escape token.\n            (macro.escapeToken == null || macro.escapeToken === \"\\\\\") &&\n            match.anyString(string) &&\n            // There are two options. Either the macro ends with the special character,\n            // e.g. `\\@foo` or the special character starts the next string, e.g. `\\foo@`.\n            (allowedTokens.has(\n                macro.content.charAt(macro.content.length - 1)\n            ) ||\n                allowedTokens.has(string.content.charAt(0)))\n        ) {\n            // There might be a number somewhere in the string. If so, we should\n            // break the string apart at that number\n            const match = string.content.match(regex);\n            const takeable = match ? match[0] : \"\";\n            if (takeable.length > 0) {\n                if (takeable.length === string.content.length) {\n                    // The whole string can be appended to the macro name\n                    macro.content += string.content;\n                    tree.splice(i + 1, 1);\n\n                    // Preserve the source location if available\n                    if (macro.position && string.position?.end) {\n                        macro.position.end = string.position.end;\n                    }\n                } else {\n                    // Only part of the string can be appended to the macro name\n                    macro.content += takeable;\n                    string.content = string.content.slice(takeable.length);\n\n                    // Preserve the source location if available\n                    if (macro.position?.end) {\n                        macro.position.end.offset += takeable.length;\n                        macro.position.end.column += takeable.length;\n                    }\n                    if (string.position?.start) {\n                        string.position.start.offset += takeable.length;\n                        string.position.start.column += takeable.length;\n                    }\n                }\n            } else {\n                i++;\n            }\n        } else {\n            ++i;\n        }\n    }\n}\n\n/**\n * Reparses all macro names so that they may optionally include characters listed in `allowedTokens`.\n * This is used, for example, when parsing expl3 syntax which allows `_` to be used in a macro name (even though\n * `_` is normally stops the parsing for a macro name). Thus, a macro `\\foo_bar:Nn` would be parsed as having\n * the name `foo_bar:Nn` rather than as `foo` followed by the strings `_`, `bar`, `:`, `Nn`.\n */\nexport function reparseMacroNames(\n    tree: Ast.Ast,\n    allowedTokens: string | Set<string>\n) {\n    if (typeof allowedTokens === \"string\") {\n        allowedTokens = new Set(allowedTokens.split(\"\"));\n    }\n    // Recast so typescript doesn't complain\n    const _allowedTokens = allowedTokens;\n    for (const v of _allowedTokens) {\n        if (v.length > 1) {\n            throw new Error(\n                `Only single characters are allowed as \\`allowedTokens\\` when reparsing macro names, not \\`${v}\\`.`\n            );\n        }\n    }\n\n    visit(\n        tree,\n        (nodes) => {\n            reparseMacroNamesInArray(nodes, _allowedTokens);\n        },\n        { includeArrays: true, test: Array.isArray }\n    );\n}\n", "import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Unified complier plugin that passes through a LaTeX AST without modification.\n */\nexport const unifiedLatexAstComplier: Plugin<void[], Ast.Root, Ast.Root> =\n    function unifiedLatexAstComplier() {\n        Object.assign(this, { Compiler: (x: Ast.Root) => x });\n    };\n", "import { Plugin, Parser, unified } from \"unified\";\nimport { environmentInfo, macroInfo } from \"@unified-latex/unified-latex-ctan\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    EnvInfoRecord,\n    MacroInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport {\n    unifiedLatexTrimEnvironmentContents,\n    unifiedLatexTrimRoot,\n} from \"@unified-latex/unified-latex-util-trim\";\nimport { unifiedLatexAstComplier } from \"./compiler-ast\";\nimport { unifiedLatexFromStringMinimal } from \"./plugin-from-string-minimal\";\nimport { unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse } from \"./process-macros-and-environments\";\nimport { unifiedLatexProcessAtLetterAndExplMacros } from \"./process-at-letter-and-expl-macros\";\n\nexport type PluginOptions =\n    | {\n          mode?: \"math\" | \"regular\";\n          macros?: MacroInfoRecord;\n          environments?: EnvInfoRecord;\n          flags?: {\n              /**\n               * Whether to parse macros as if `\\makeatletter` is set (i.e., parse `@` as a regular macro character)\n               */\n              atLetter?: boolean;\n              /**\n               * Whether to parse macros as if `\\ExplSyntaxOn` is set (i.e., parse `_` and `:` as a regular macro character)\n               */\n              expl3?: boolean;\n              /**\n               * Attempt to autodetect whether there are macros that look like they should contain `@`, `_`, or `:`.\n               * Defaults to `false`.\n               */\n              autodetectExpl3AndAtLetter?: boolean;\n          };\n      }\n    | undefined;\n\n/**\n * Parse a string to a LaTeX AST.\n */\nexport const unifiedLatexFromString: Plugin<PluginOptions[], string, Ast.Root> =\n    function unifiedLatexFromString(options) {\n        const {\n            mode = \"regular\",\n            macros = {},\n            environments = {},\n            flags: {\n                atLetter = false,\n                expl3 = false,\n                autodetectExpl3AndAtLetter = false,\n            } = {},\n        } = options || {};\n\n        // Build up a parsing plugin with only unified components\n        const allMacroInfo: MacroInfoRecord = Object.assign(\n            {},\n            ...Object.values(macroInfo),\n            macros\n        );\n        const allEnvInfo: EnvInfoRecord = Object.assign(\n            {},\n            ...Object.values(environmentInfo),\n            environments\n        );\n\n        // Build up a parser that will perform all the needed steps\n        const fullParser = unified()\n            .use(unifiedLatexFromStringMinimal, { mode })\n            .use(unifiedLatexProcessAtLetterAndExplMacros, {\n                atLetter,\n                expl3,\n                autodetectExpl3AndAtLetter,\n            })\n            // Math environments that aren't hardcoded into the PEG grammar need to be re-parsed,\n            // so do a minimal pass first with just those environments.\n            .use(unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse, {\n                macros: allMacroInfo,\n                environments: allEnvInfo,\n            })\n            .use(unifiedLatexTrimEnvironmentContents)\n            .use(unifiedLatexTrimRoot)\n            .use(unifiedLatexAstComplier);\n\n        const parser: Parser<Ast.Root> = (str) => {\n            const file = fullParser.processSync({ value: str });\n            return file.result;\n        };\n\n        Object.assign(this, { Parser: parser });\n    };\n", "import { LatexPegParser } from \"@unified-latex/unified-latex-util-pegjs\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Parse `str` to an AST with minimal processing. E.g., macro\n * arguments are not attached to macros, etc. when parsed with this\n * function.\n */\nexport function parseMinimal(str: string): Ast.Root {\n    return LatexPegParser.parse(str);\n}\n\n/**\n * Parse `str` to an AST with minimal processing. E.g., macro\n * arguments are not attached to macros, etc. when parsed with this\n * function.\n *\n * The parsing assumes a math-mode context, so, for example, `^` and `_` are\n * parsed as macros (even though arguments are not attached to them).\n */\nexport function parseMathMinimal(str: string): Ast.Node[] {\n    return LatexPegParser.parse(str, { startRule: \"math\" });\n}\n", "import { Plugin, Parser } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { parseMathMinimal, parseMinimal } from \"./parse-minimal\";\n\ntype PluginOptions = {\n    /**\n     * Whether the text will be parsed assuming math mode or not.\n     */\n    mode: \"math\" | \"regular\";\n} | void;\n\n/**\n * Parse a string to a LaTeX AST with no post processing. For example,\n * no macro arguments will be attached, etc.\n */\nexport const unifiedLatexFromStringMinimal: Plugin<\n    PluginOptions[],\n    string,\n    Ast.Root\n> = function unifiedLatexFromStringMinimal(options) {\n    const parser: Parser<Ast.Root> = (str) => {\n        if (options?.mode === \"math\") {\n            return {\n                type: \"root\",\n                content: parseMathMinimal(str),\n                _renderInfo: { inMathMode: true },\n            };\n        }\n        return parseMinimal(str);\n    };\n\n    Object.assign(this, { Parser: parser });\n};\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { EnvInfoRecord, MacroInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { Plugin } from \"unified\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport {\n    unifiedLatexReparseMathConstructPlugin,\n} from \"./reparse-math\";\nimport { attachMacroArgsInArray } from \"@unified-latex/unified-latex-util-arguments\";\nimport { processEnvironment } from \"@unified-latex/unified-latex-util-environments\";\n\ntype PluginOptions =\n    | { environments: EnvInfoRecord; macros: MacroInfoRecord }\n    | undefined;\n\n/**\n * Unified plugin to process macros and environments. Any environments that contain math content\n * are reparsed (if needed) in math mode.\n */\nexport const unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse(options) {\n    const { environments = {}, macros = {} } = options || {};\n\n    const mathMacros = Object.fromEntries(\n        Object.entries(macros).filter(\n            ([_, info]) => info.renderInfo?.inMathMode === true\n        )\n    );\n    const mathEnvs = Object.fromEntries(\n        Object.entries(environments).filter(\n            ([_, info]) => info.renderInfo?.inMathMode === true\n        )\n    );\n\n    const mathReparser = unifiedLatexReparseMathConstructPlugin({\n        mathEnvs: Object.keys(mathEnvs),\n        mathMacros: Object.keys(mathMacros),\n    });\n\n    const isRelevantEnvironment = match.createEnvironmentMatcher(environments);\n    const isRelevantMathEnvironment = match.createEnvironmentMatcher(mathEnvs);\n\n    return (tree) => {\n        // First we attach all arguments/process all nodes/environments that have math content\n        visit(\n            tree,\n            {\n                enter: (nodes) => {\n                    if (!Array.isArray(nodes)) {\n                        return;\n                    }\n                    attachMacroArgsInArray(nodes, mathMacros);\n                },\n                leave: (node) => {\n                    if (!isRelevantMathEnvironment(node)) {\n                        return;\n                    }\n                    const envName = printRaw(node.env);\n                    const envInfo = environments[envName];\n                    if (!envInfo) {\n                        throw new Error(\n                            `Could not find environment info for environment \"${envName}\"`\n                        );\n                    }\n                    processEnvironment(node, envInfo);\n                },\n            },\n            { includeArrays: true }\n        );\n\n        // Next we reparse macros/envs that may not have been parsed in math mode\n        mathReparser(tree);\n\n        // Now we attach all arguments/process all environment bodies\n        visit(\n            tree,\n            {\n                enter: (nodes) => {\n                    if (!Array.isArray(nodes)) {\n                        return;\n                    }\n                    attachMacroArgsInArray(nodes, macros);\n                },\n                leave: (node) => {\n                    if (!isRelevantEnvironment(node)) {\n                        return;\n                    }\n                    const envName = printRaw(node.env);\n                    const envInfo = environments[envName];\n                    if (!envInfo) {\n                        throw new Error(\n                            `Could not find environment info for environment \"${envName}\"`\n                        );\n                    }\n                    processEnvironment(node, envInfo);\n                },\n            },\n            { includeArrays: true }\n        );\n    };\n};\n", "import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { parseMathMinimal } from \"./parse-minimal\";\n\ntype PluginOptions =\n    | {\n          /**\n           * List of environments whose body should be parsed in math mode\n           */\n          mathEnvs: string[];\n          /**\n           * List of macros whose bodies should be parsed in math mode\n           */\n          mathMacros: string[];\n      }\n    | undefined;\n\n/**\n * Reparse math environments/macro contents that should have been parsed in math mode but weren't.\n */\nexport const unifiedLatexReparseMath: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexReparseMath(options) {\n    const { mathEnvs = [], mathMacros = [] } = options || {};\n\n    return unifiedLatexReparseMathConstructPlugin({ mathMacros, mathEnvs });\n};\n\n/**\n * Construct the inner function for the `unifiedLatexReparseMath` plugin. This function should not be used by libraries.\n */\nexport function unifiedLatexReparseMathConstructPlugin({\n    mathEnvs,\n    mathMacros,\n}: {\n    mathEnvs: string[];\n    mathMacros: string[];\n}) {\n    const isMathEnvironment = match.createEnvironmentMatcher(mathEnvs);\n    const isMathMacro = match.createMacroMatcher(mathMacros);\n\n    return (tree: Ast.Root) => {\n        visit(\n            tree,\n            (node) => {\n                if (match.anyMacro(node)) {\n                    for (const arg of node.args || []) {\n                        if (\n                            arg.content.length > 0 &&\n                            !wasParsedInMathMode(arg.content)\n                        ) {\n                            arg.content = parseMathMinimal(\n                                printRaw(arg.content)\n                            );\n                        }\n                    }\n                }\n                if (match.anyEnvironment(node)) {\n                    if (!wasParsedInMathMode(node.content)) {\n                        node.content = parseMathMinimal(printRaw(node.content));\n                    }\n                }\n            },\n            {\n                test: (node) => isMathEnvironment(node) || isMathMacro(node),\n            }\n        );\n    };\n}\n\n/**\n * Use a heuristic to decide whether a string was parsed in math mode. The heuristic\n * looks for strings of length greater than 1 or the failure for \"_\" and \"^\" to be parsed\n * as a macro.\n */\nfunction wasParsedInMathMode(nodes: Ast.Node[]): boolean {\n    return !nodes.some(\n        (node) =>\n            // If there are multi-char strings or ^ and _ have been parsed as strings, we know\n            // that we were not parsed in math mode.\n            (match.anyString(node) && node.content.length > 1) ||\n            match.string(node, \"^\") ||\n            match.string(node, \"_\")\n    );\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { Plugin } from \"unified\";\nimport { reparseExpl3AndAtLetterRegions } from \"@unified-latex/unified-latex-util-catcode\";\nimport {\n    hasReparsableMacroNames,\n    reparseMacroNames,\n} from \"@unified-latex/unified-latex-util-catcode\";\n\ntype PluginOptions =\n    | {\n          /**\n           * Whether to parse macros as if `\\makeatletter` is set (i.e., parse `@` as a regular macro character).\n           * If this option is true, it disables autodetect.\n           */\n          atLetter?: boolean;\n          /**\n           * Whether to parse macros as if `\\ExplSyntaxOn` is set (i.e., parse `_` and `:` as a regular macro character)\n           * If this option is true, it disables autodetect.\n           */\n          expl3?: boolean;\n          /**\n           * Attempt to autodetect whether there are macros that look like they should contain `@`, `_`, or `:`.\n           * Defaults to `true`.\n           */\n          autodetectExpl3AndAtLetter?: boolean;\n      }\n    | undefined;\n\n/**\n * Unified plugin to reprocess macros names to possibly include `@`, `_`, or `:`.\n * This plugin detects the `\\makeatletter` and `\\ExplSyntaxOn` commands and reprocesses macro names\n * inside of those blocks to include those characters.\n */\nexport const unifiedLatexProcessAtLetterAndExplMacros: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexProcessAtLetterAndExplMacros(options) {\n    let {\n        atLetter = false,\n        expl3 = false,\n        autodetectExpl3AndAtLetter = false,\n    } = options || {};\n\n    return (tree) => {\n        // First we reparse based on explicit \\makeatletter and \\ExplSyntaxOn macros\n        reparseExpl3AndAtLetterRegions(tree);\n        if (atLetter || expl3) {\n            autodetectExpl3AndAtLetter = false;\n        }\n        if (autodetectExpl3AndAtLetter) {\n            atLetter = hasReparsableMacroNames(tree, \"@\");\n            // We don't check for the `:` here because it could be prone to misidentification.\n            expl3 = hasReparsableMacroNames(tree, \"_\");\n        }\n        const charSet: Set<string> = new Set();\n        if (atLetter) {\n            charSet.add(\"@\");\n        }\n        if (expl3) {\n            charSet.add(\":\");\n            charSet.add(\"_\");\n        }\n\n        if (charSet.size > 0) {\n            reparseMacroNames(tree, charSet);\n        }\n    };\n};\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { type FrozenProcessor, unified } from \"unified\";\nimport { unifiedLatexFromString } from \"./plugin-from-string\";\nimport type { PluginOptions } from \"./plugin-from-string\";\n\nlet parser = unified().use(unifiedLatexFromString).freeze();\n\n/**\n * Parse the string into an AST.\n */\nexport function parse(str: string): Ast.Root {\n    return parser.parse(str);\n}\n\n/**\n * Returns the default `unified-latex` parser, or create a new one with the\n * provided `unifiedLatexFromString` options\n * @param options Plugin options of `unifiedLatexFromString` plugin.\n * @returns The default `unified-latex` parser if `options` is `undefined`, or a\n * newly created `unified-latex` parser with the provided `options`.\n */\nexport function getParser(\n    options?: PluginOptions\n): FrozenProcessor<Ast.Root, Ast.Root, Ast.Root, void> {\n    return options\n        ? unified().use(unifiedLatexFromString, options).freeze()\n        : parser;\n}\n", "import { unified } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { unifiedLatexAstComplier } from \"./compiler-ast\";\nimport { unifiedLatexFromString } from \"./plugin-from-string\";\n\n/**\n * Parse `str` into an AST. Parsing starts in math mode and a list of\n * nodes is returned (instead of a \"root\" node).\n */\nexport function parseMath(str: string | Ast.Ast): Ast.Node[] {\n    if (typeof str !== \"string\") {\n        str = printRaw(str);\n    }\n    const file = unified()\n        .use(unifiedLatexFromString, { mode: \"math\" })\n        .use(unifiedLatexAstComplier)\n        .processSync({ value: str });\n    return (file.result as Ast.Root).content;\n}\n", "import type { Plugin, Printer } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { parse } from \"@unified-latex/unified-latex-util-parse\";\nimport { printLatexAst } from \"./printer\";\n\nconst languages = [\n    {\n        name: \"latex\",\n        extensions: [\".tex\"],\n        parsers: [\"latex-parser\"],\n    },\n];\n\nconst parsers = {\n    \"latex-parser\": {\n        parse,\n        astFormat: \"latex-ast\",\n        locStart: (node: Ast.Node) =>\n            node.position ? node.position.start.offset : 0,\n        locEnd: (node: Ast.Node) =>\n            node.position ? node.position.end.offset : 1,\n    },\n};\n\nconst printers = {\n    \"latex-ast\": {\n        print: printLatexAst,\n    } as Printer,\n};\n\nconst prettierPluginLatex: Plugin<Ast.Node> = { languages, parsers, printers };\n\nexport { prettierPluginLatex };\n"],
  "mappings": "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",
  "names": ["module", "module", "index", "module", "module", "module", "index", "module", "pushInOrder", "module", "module", "permute", "module", "reducer", "input", "module", "isBuffer", "module", "isArray", "isPlainObject", "setProperty", "getProperty", "extend", "clone", "module", "module", "module", "swizzle", "arg", "module", "string", "match", "s", "module", "s", "string", "match", "module", "path", "module", "module", "Color", "keys", "__defProp", "__export", "index", "group2", "indent2", "lineSuffix2", "whitespace", "macros", "macro", "group", "ESCAPE", "softline", "group", "fill", "ifBreak", "line", "hardline", "lineSuffix", "lineSuffixBoundary", "breakParent", "indent", "markAsRoot", "join", "path", "ESCAPE", "arg", "indent", "fill", "group", "index", "result", "key", "trim", "unifiedLatexTrimEnvironmentContents", "match", "unifiedLatexTrimRoot", "s", "line", "expected", "found", "x", "macro", "comment", "location", "text", "options", "at", "braces", "args", "argument", "arg", "macros", "match", "macro", "macroInfo", "createMatchers", "parse", "createMatchers", "hardline", "join", "breakParent", "line", "group", "indent", "softline", "path", "trim", "parse", "printer", "group", "indent", "line", "softline", "comment", "hardline", "join", "path", "content", "trim", "hardline", "fill", "path", "fill", "path", "_print", "path", "hardline", "fill", "ESCAPE", "indent", "createMatchers", "path", "hardline", "indent", "fill", "nodes", "trim", "path", "hardline", "ESCAPE", "line", "import_is_buffer", "index", "point", "position", "index", "join", "path", "index", "path", "index", "buffer", "index", "prop", "path", "dirname", "assertPath", "basename", "extname", "parse", "index", "extend", "value", "options", "file", "isBuffer", "import_color", "macros", "trim", "environments", "match", "arg", "argSpecM", "parseArgspec", "argSpecO", "argSpecRDelim", "argumentParser", "gobbleSingleArgument", "OPTIONAL_ARGUMENT_ARG_SPEC", "tikzCommandArgumentParser", "colonPos", "createMatchers", "matchers", "Color", "s", "macro", "string", "match", "visit", "unifiedLatexAstComplier", "unifiedLatexFromStringMinimal", "parser", "arg", "unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse", "environments", "macros", "match", "visit", "printRaw", "unifiedLatexProcessAtLetterAndExplMacros", "unifiedLatexFromString", "unified", "parse", "parse"]
}
