{"version":3,"file":"index.cjs","sources":["../../../package/tabularx/provides.ts","../../../package/tabularx/libs/parser.ts","../../../package/tabularx/libs/print-raw.ts"],"sourcesContent":["import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {};\n\nexport const environments: EnvInfoRecord = {\n    tabularx: { signature: \"m o m\", renderInfo: { alignContent: true } },\n};\n","import { TabularPegParser } from \"@unified-latex/unified-latex-util-pegjs\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport {\n    decorateArrayForPegjs,\n    splitStringsIntoSingleChars,\n} from \"@unified-latex/unified-latex-util-pegjs\";\nimport * as TabularSpec from \"./types\";\n\nfunction createMatchers() {\n    return {\n        matchChar: (node: Ast.Node, char: string) => match.string(node, char),\n        isWhitespace: match.whitespace,\n        isGroup: match.group,\n    };\n}\n\n/**\n * Parse a tabular/tabularx specification, e.g. `\"|c|r|r|\"`. This parser assumes the specification has\n * already been parsed as LaTeX.\n */\nexport function parseTabularSpec(ast: Ast.Node[]): TabularSpec.TabularColumn[] {\n    if (!Array.isArray(ast)) {\n        throw new Error(\"You must pass an array of nodes\");\n    }\n    // All tabular spec commands are single letters, so we pre-split all strings\n    // for easy parsing.\n    ast = splitStringsIntoSingleChars(ast);\n    // We need to at functions to `nodes` so that it imitates\n    // a Javascript string. Because we're mutating, make a copy first\n    ast = decorateArrayForPegjs([...ast]);\n    // matchers are passed in via the second argument (the `options` argument)\n    // so they are available from within the Pegjs grammar.\n    return TabularPegParser.parse(ast, createMatchers());\n}\n","import * as TabularSpec from \"./types\";\nimport { printRaw as latexPrintRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\n/**\n * Print a tabular/tabularx argument specification AST to a string.\n */\nexport function printRaw(node: TabularSpec.Ast, root = false): string {\n    if (typeof node === \"string\") {\n        return node;\n    }\n\n    if (Array.isArray(node)) {\n        const sepToken = root ? \" \" : \"\";\n        return node.map((tok) => printRaw(tok)).join(sepToken);\n    }\n\n    switch (node.type) {\n        case \"vert_divider\":\n            return \"|\";\n        case \"at_divider\":\n            return `@{${latexPrintRaw(node.content)}}`;\n        case \"bang_divider\":\n            return `!{${latexPrintRaw(node.content)}}`;\n        case \"alignment\":\n            if (node.alignment === \"left\") {\n                return \"l\";\n            }\n            if (node.alignment === \"right\") {\n                return \"r\";\n            }\n            if (node.alignment === \"center\") {\n                return \"c\";\n            }\n            if (node.alignment === \"X\") {\n                return \"X\";\n            }\n            if (node.alignment === \"parbox\") {\n                if (node.baseline === \"top\") {\n                    return `p{${latexPrintRaw(node.size)}}`;\n                }\n                if (node.baseline === \"default\") {\n                    return `m{${latexPrintRaw(node.size)}}`;\n                }\n                if (node.baseline === \"bottom\") {\n                    return `b{${latexPrintRaw(node.size)}}`;\n                }\n                return `w{${latexPrintRaw(node.baseline)}}{${latexPrintRaw(\n                    node.size\n                )}}`;\n            }\n            break;\n        case \"decl_code\":\n            return latexPrintRaw(node.code);\n\n        case \"column\":\n            const end_code = node.before_end_code\n                ? `<{${printRaw(node.before_end_code)}}`\n                : \"\";\n            const start_code = node.before_start_code\n                ? `>{${printRaw(node.before_start_code)}}`\n                : \"\";\n            return [\n                printRaw(node.pre_dividers),\n                start_code,\n                printRaw(node.alignment),\n                end_code,\n                printRaw(node.post_dividers),\n            ].join(\"\");\n\n        default:\n            console.warn(\n                `Unknown node type \"${(node as any).type}\" for node`,\n                node\n            );\n            return \"\";\n    }\n    return \"\";\n}\n"],"names":["match","splitStringsIntoSingleChars","decorateArrayForPegjs","TabularPegParser","latexPrintRaw"],"mappings":";;;;;AAKO,MAAM,SAA0B,CAAC;AAEjC,MAAM,eAA8B;AAAA,EACvC,UAAU,EAAE,WAAW,SAAS,YAAY,EAAE,cAAc,OAAO;AACvE;ACAA,SAAS,iBAAiB;AACf,SAAA;AAAA,IACH,WAAW,CAAC,MAAgB,SAAiBA,sBAAM,MAAA,OAAO,MAAM,IAAI;AAAA,IACpE,cAAcA,sBAAM,MAAA;AAAA,IACpB,SAASA,sBAAM,MAAA;AAAA,EAAA;AAEvB;AAMO,SAAS,iBAAiB,KAA8C;AAC3E,MAAI,CAAC,MAAM,QAAQ,GAAG,GAAG;AACf,UAAA,IAAI,MAAM,iCAAiC;AAAA,EACrD;AAGA,QAAMC,sBAAAA,4BAA4B,GAAG;AAGrC,QAAMC,sBAAsB,sBAAA,CAAC,GAAG,GAAG,CAAC;AAGpC,SAAOC,sBAAiB,iBAAA,MAAM,KAAK,eAAgB,CAAA;AACvD;AC5BgB,SAAA,SAAS,MAAuB,OAAO,OAAe;AAC9D,MAAA,OAAO,SAAS,UAAU;AACnB,WAAA;AAAA,EACX;AAEI,MAAA,MAAM,QAAQ,IAAI,GAAG;AACf,UAAA,WAAW,OAAO,MAAM;AACvB,WAAA,KAAK,IAAI,CAAC,QAAQ,SAAS,GAAG,CAAC,EAAE,KAAK,QAAQ;AAAA,EACzD;AAEA,UAAQ,KAAK,MAAM;AAAA,IACf,KAAK;AACM,aAAA;AAAA,IACX,KAAK;AACD,aAAO,KAAKC,yBAAA,SAAc,KAAK,OAAO,CAAC;AAAA,IAC3C,KAAK;AACD,aAAO,KAAKA,yBAAA,SAAc,KAAK,OAAO,CAAC;AAAA,IAC3C,KAAK;AACG,UAAA,KAAK,cAAc,QAAQ;AACpB,eAAA;AAAA,MACX;AACI,UAAA,KAAK,cAAc,SAAS;AACrB,eAAA;AAAA,MACX;AACI,UAAA,KAAK,cAAc,UAAU;AACtB,eAAA;AAAA,MACX;AACI,UAAA,KAAK,cAAc,KAAK;AACjB,eAAA;AAAA,MACX;AACI,UAAA,KAAK,cAAc,UAAU;AACzB,YAAA,KAAK,aAAa,OAAO;AACzB,iBAAO,KAAKA,yBAAA,SAAc,KAAK,IAAI,CAAC;AAAA,QACxC;AACI,YAAA,KAAK,aAAa,WAAW;AAC7B,iBAAO,KAAKA,yBAAA,SAAc,KAAK,IAAI,CAAC;AAAA,QACxC;AACI,YAAA,KAAK,aAAa,UAAU;AAC5B,iBAAO,KAAKA,yBAAA,SAAc,KAAK,IAAI,CAAC;AAAA,QACxC;AACA,eAAO,KAAKA,yBAAA,SAAc,KAAK,QAAQ,CAAC,KAAKA,yBAAA;AAAA,UACzC,KAAK;AAAA,QACR,CAAA;AAAA,MACL;AACA;AAAA,IACJ,KAAK;AACM,aAAAA,yBAAA,SAAc,KAAK,IAAI;AAAA,IAElC,KAAK;AACK,YAAA,WAAW,KAAK,kBAChB,KAAK,SAAS,KAAK,eAAe,CAAC,MACnC;AACA,YAAA,aAAa,KAAK,oBAClB,KAAK,SAAS,KAAK,iBAAiB,CAAC,MACrC;AACC,aAAA;AAAA,QACH,SAAS,KAAK,YAAY;AAAA,QAC1B;AAAA,QACA,SAAS,KAAK,SAAS;AAAA,QACvB;AAAA,QACA,SAAS,KAAK,aAAa;AAAA,MAAA,EAC7B,KAAK,EAAE;AAAA,IAEb;AACY,cAAA;AAAA,QACJ,sBAAuB,KAAa,IAAI;AAAA,QACxC;AAAA,MAAA;AAEG,aAAA;AAAA,EACf;AACO,SAAA;AACX;;;;;"}