{"version":3,"file":"index.cjs","sources":["../../../package/systeme/libs/parser.ts","../../../package/systeme/libs/print-raw.ts","../../../package/systeme/libs/systeme.ts"],"sourcesContent":["import * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as SystemeSpec from \"./types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { decorateArrayForPegjs } from \"@unified-latex/unified-latex-util-pegjs\";\nimport { SystemePegParser } from \"@unified-latex/unified-latex-util-pegjs\";\n\ntype SystemeMatchers = {\n    at?: string;\n    equals?: string;\n    equationSeparator?: string;\n    mathOperations?: string[];\n    whitelistedVariables?: (string | Ast.String | Ast.Macro)[];\n};\n\nfunction createMatchers({\n    at = \"@\",\n    equals = \"=\",\n    equationSeparator = \",\",\n    mathOperations = [\"+\", \"-\"],\n    whitelistedVariables,\n}: SystemeMatchers = {}) {\n    let isVar: (node: Ast.Node) => boolean = (node: Ast.Node) =>\n        match.anyString(node) && !!node.content.match(/[a-zA-Z]/);\n    if (whitelistedVariables) {\n        // Unwrap all strings\n        whitelistedVariables = whitelistedVariables.map((v) =>\n            match.anyString(v) ? v.content : v\n        );\n        const macros = whitelistedVariables.filter((v) =>\n            match.anyMacro(v)\n        ) as Ast.Macro[];\n        const strings = whitelistedVariables.filter(\n            (v) => typeof v === \"string\"\n        ) as string[];\n        const macroHash = Object.fromEntries(macros.map((v) => [v.content, v]));\n        const stringHash = Object.fromEntries(strings.map((s) => [s, s]));\n        const macroMatcher = match.createMacroMatcher(macroHash);\n        isVar = (node: Ast.Node) =>\n            macroMatcher(node) ||\n            (match.anyString(node) && !!stringHash[node.content]);\n    }\n    return {\n        isSep: (node: Ast.Node) => match.string(node, equationSeparator),\n        isVar,\n        isOperation: (node: Ast.Node) =>\n            mathOperations.some((op) => match.string(node, op)),\n        isEquals: (node: Ast.Node) => match.string(node, equals),\n        isAt: (node: Ast.Node) => match.string(node, at),\n        isSubscript: (node: Ast.Node) =>\n            match.macro(node, \"_\") && node.escapeToken === \"\",\n        isWhitespace: match.whitespace,\n        isSameLineComment: (node: Ast.Node) =>\n            match.comment(node) && node.sameline,\n        isOwnLineComment: (node: Ast.Node) =>\n            match.comment(node) && !node.sameline,\n    };\n}\n\n/**\n * Parse the contents of the `\\systeme{...}` macro\n */\nexport function parse(\n    ast: Ast.Node[],\n    options?: SystemeMatchers\n): SystemeSpec.Line[] {\n    if (!Array.isArray(ast)) {\n        throw new Error(\"You must pass an array of nodes\");\n    }\n    // We need to at functions to `nodes` so that it imitates\n    // a Javascript string. Because we're mutating, make a copy first\n    ast = decorateArrayForPegjs([...ast]);\n    // matchers are passed in via the second argument (the `options` argument)\n    // so they are available from within the Pegjs grammar.\n    return SystemePegParser.parse(\n        ast,\n        createMatchers(options || {})\n    ) as SystemeSpec.Line[];\n}\n","import { printRaw as latexPrintRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport * as SystemeSpec from \"./types\";\n\n/**\n * Print an `systeme` argument specification AST to a string.\n */\nexport function printRaw(node: SystemeSpec.Ast, root = false): string {\n    if (typeof node === \"string\") {\n        return node;\n    }\n\n    if (Array.isArray(node)) {\n        const sepToken = root ? \" \" : \"\";\n        return node.map((tok) => printRaw(tok)).join(sepToken);\n    }\n\n    switch (node.type) {\n        case \"annotation\":\n            return `${latexPrintRaw(node.marker)}${latexPrintRaw(\n                node.content\n            )}`;\n        case \"item\":\n            return `${node.op ? latexPrintRaw(node.op) : \"\"}${latexPrintRaw(\n                node.content\n            )}`;\n        case \"equation\":\n            const left = node.left.map((n) => printRaw(n)).join(\"\");\n            const right = latexPrintRaw(node.right);\n            const equals = node.equals ? latexPrintRaw(node.equals) : \"\";\n            return `${left}${equals}${right}`;\n        case \"line\":\n            const equation = node.equation ? printRaw(node.equation) : \"\";\n            const annotation = node.annotation ? printRaw(node.annotation) : \"\";\n            const sep = node.sep ? latexPrintRaw(node.sep) : \"\";\n\n            const body = `${equation}${annotation}${sep}`;\n            if (node.trailingComment) {\n                return latexPrintRaw([body, node.trailingComment]);\n            }\n\n            return body;\n\n        default:\n            console.warn(\n                `Unknown node type \"${(node as any).type}\" for node`,\n                node\n            );\n            return \"\";\n    }\n}\n","import * as SystemeSpec from \"./types\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { arrayJoin } from \"@unified-latex/unified-latex-util-split\";\nimport { parse } from \"./parser\";\nimport { structuredClone } from \"@unified-latex/structured-clone\";\nimport { deleteComments } from \"@unified-latex/unified-latex-util-comments\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\nimport { getArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\n\nconst AMP: Ast.String = { type: \"string\", content: \"&\" };\nconst SEP: Ast.Macro = { type: \"macro\", content: \"\\\\\" };\nconst QUAD: Ast.Macro = { type: \"macro\", content: \"quad\" };\nconst PLUS: Ast.String = { type: \"string\", content: \"+\" };\nconst COLUMN_KERN_ADJUSTMENT: Ast.Node[] = [\n    { type: \"string\", content: \"@\" },\n    {\n        type: \"group\",\n        content: [\n            { type: \"macro\", content: \"mkern\" },\n            { type: \"string\", content: \"5mu\" },\n        ],\n    },\n];\n\n/**\n * Return a map giving the sorted index of each variable in `vars`. There\n * may be duplicated variables in `vars`. The map will send duplicates to the same index.\n *\n * @param {Ast.Node[][]} vars\n * @returns\n */\nfunction sortVariables(\n    vars: Ast.Node[][],\n    whitelistedVariables?: Ast.Node[] | null\n) {\n    const varMap = new Map(vars.map((v) => [v, printRaw(v)]));\n    const varNames = Array.from(new Set(varMap.values()));\n    varNames.sort();\n    const nameToPos = whitelistedVariables\n        ? new Map(whitelistedVariables.map((v, i) => [printRaw(v), i]))\n        : new Map(varNames.map((name, i) => [name, i]));\n\n    return new Map(\n        Array.from(varMap.entries()).map(([variable, name]) => {\n            return [variable, nameToPos.get(name) ?? -1];\n        })\n    );\n}\n\n/**\n * Make an array of arrays representing the operation/content of each item in an equation\n * + the annotation. The return value is suitable to be joined with `&` for the body of an array.\n */\nfunction processLine(\n    line: SystemeSpec.Line,\n    numVars: number,\n    varOrder: Map<Ast.Node[], number>,\n    hasEquals: boolean,\n    hasAnnotation: boolean\n) {\n    const ret: Ast.Node[][] = [];\n    if (line.equation) {\n        // We need to combine all non-var items into a single expression\n        const nonVarItems = line.equation.left.filter(\n            (item) => item.variable == null\n        );\n        const varItems = line.equation.left.filter(\n            (item) => item.variable != null\n        );\n        let nonVarTerm: SystemeSpec.Item | null = null;\n        if (nonVarItems.length === 1) {\n            nonVarTerm = nonVarItems[0];\n        } else if (nonVarItems.length > 1) {\n            // We need to combine all the items. We do so by constructing a new item with the rest of the item's contents\n            // added on the back\n            nonVarTerm = {\n                ...nonVarItems[0],\n                content: nonVarItems[0].content.concat(\n                    nonVarItems.slice(1).flatMap((item) => {\n                        if (item.op) {\n                            return [item.op, ...item.content];\n                        }\n                        return [PLUS, ...item.content];\n                    })\n                ),\n            };\n        }\n\n        const allItems = nonVarTerm ? varItems.concat(nonVarTerm) : varItems;\n\n        const indexToItem = new Map(\n            allItems.map((item) => {\n                if (item.variable == null) {\n                    return [numVars - 1, item];\n                }\n                return [varOrder.get(item.variable), item];\n            })\n        );\n\n        let isFirstItem = true;\n        for (let i = 0; i < numVars; i++) {\n            const item = indexToItem.get(i);\n            if (item) {\n                if (\n                    isFirstItem &&\n                    (match.string(item.op, \"+\") || item.op == null)\n                ) {\n                    // If the first item starts with a plus or doesn't have a starting operation,\n                    // we don't use a starting symbol.\n                    ret.push([]);\n                    ret.push(item.content);\n                } else {\n                    // If we are not the first item, we always push an operation\n                    ret.push([item.op || PLUS]);\n                    ret.push(item.content);\n                }\n                isFirstItem = false;\n            } else {\n                // If there is no item for this position, we push a blank operation and content\n                ret.push([]);\n                ret.push([]);\n            }\n        }\n        // If we have an equals, we need to push its contents\n        if (hasEquals) {\n            const equalsPart = (\n                line.equation.equals ? [line.equation.equals] : []\n            ).concat(line.equation.right);\n            ret.push(equalsPart);\n        }\n    }\n    // If we have an annotation, we need to push it or a blank\n    if (hasAnnotation) {\n        ret.push(line.annotation ? line.annotation.content : []);\n    }\n\n    return ret;\n}\n\n/**\n * Add kerning information to the array specification. E.g. `crl` becomes `c@{\\mkern5mu}r@{\\mkern5mu}l`.\n * This is so the operations when typesetting a system of equations are properly spaced.\n */\nfunction arraySpecToSpacedArraySpec(spec: string, hasAnnotation?: boolean) {\n    const annotationSpec = hasAnnotation ? spec.charAt(spec.length - 1) : \"\";\n    const bodySpec = hasAnnotation ? spec.slice(0, spec.length - 1) : spec;\n\n    const bodyStrings: Ast.Node[][] = Array.from(bodySpec).map((x) => [\n        { type: \"string\", content: x },\n    ]);\n    const body = arrayJoin(bodyStrings, COLUMN_KERN_ADJUSTMENT);\n    return annotationSpec\n        ? body.concat({ type: \"string\", content: annotationSpec })\n        : body;\n}\n\n/**\n * Extract the variables from a systeme system of equations.\n */\nexport function extractVariables(nodes: SystemeSpec.Node[]): Ast.Node[][] {\n    return nodes.flatMap((node) => {\n        if (node.type === \"line\" && node.equation) {\n            return extractVariables(node.equation.left);\n        }\n        if (node.type === \"equation\") {\n            return node.left.flatMap((item) =>\n                item.variable ? [item.variable] : []\n            );\n        }\n        if (node.type === \"item\") {\n            return node.variable ? [node.variable] : [];\n        }\n        return [];\n    });\n}\n\n/**\n * Remove any whitespace from the variable list (including an explicit \" \" string).\n * As well, filter out any non-macro/non-string items.\n */\nfunction normalizeVariableWhitelist(\n    vars: (string | Ast.Node)[] | null | undefined\n) {\n    if (!vars) {\n        return null;\n    }\n    const normalized: Ast.Node[] = vars.map((v) =>\n        typeof v === \"string\" ? { type: \"string\", content: v } : v\n    );\n    const ret = normalized.filter(\n        (v) =>\n            (match.anyMacro(v) || match.anyString(v)) &&\n            !match.string(v, \" \") &&\n            !match.whitespace(v)\n    ) as (Ast.Macro | Ast.String)[];\n    return ret;\n}\n\n/**\n * Lays out the contents of a \\systeme{...} macro as an array. This function sorts the variables\n * in alphabetical order and lays out any annotations. An `\\begin{array}...\\end{array}` environment\n * is returned.\n *\n * If `properSpacing=true` then kerning information will be included in the array specification to space\n * the operators correctly. This kerning information will make the specification long (and may make it incompatible\n * with KaTeX).\n *\n * An optional whitelist of variables may be supplied. If supplied, only listed items will count as variables and\n * the order of variable appearance will be the same as the order of the whitelisted variables.\n */\nexport function systemeContentsToArray(\n    nodes: Ast.Node[],\n    options?: {\n        properSpacing?: boolean;\n        whitelistedVariables?: (string | Ast.String | Ast.Macro)[];\n    }\n) {\n    nodes = structuredClone(nodes);\n    deleteComments(nodes);\n    const { properSpacing = true, whitelistedVariables } = options || {};\n    const coercedWhitelistedVariables =\n        normalizeVariableWhitelist(whitelistedVariables);\n    const systemeAst = parse(nodes, { whitelistedVariables });\n    const vars = extractVariables(systemeAst);\n    const varOrder = sortVariables(vars, coercedWhitelistedVariables);\n    let numVars = coercedWhitelistedVariables\n        ? coercedWhitelistedVariables.length\n        : Math.max(...Array.from(varOrder.values())) + 1;\n    // If there are terms with no variable, we need a spot for them\n    if (\n        systemeAst.some((line) => {\n            if (line.equation) {\n                return line.equation.left.some((item) => item.variable == null);\n            }\n        })\n    ) {\n        numVars += 1;\n    }\n    const hasEquals = systemeAst.some(\n        (line) => line.equation && line.equation.equals\n    );\n    const hasAnnotation = systemeAst.some((line) => line.annotation);\n\n    let rows = systemeAst.map((line) =>\n        processLine(line, numVars, varOrder, hasEquals, hasAnnotation)\n    );\n    // If we have no leading `-` signs (e.g., only leading `+` or bank signs)\n    // We don't need space for the first operation to be stored\n    const noLeadingOperation = rows.every((row) => row[0].length === 0);\n\n    // Every item in an equation has a centered operation and a right-aligned variable part.\n    let arraySignature = Array.from({ length: numVars }, () => \"cr\").join(\"\");\n    if (noLeadingOperation) {\n        // We might not have a leading operation on the first item(s)\n        arraySignature = arraySignature.slice(1);\n        rows = rows.map((row) => row.slice(1));\n    }\n    if (hasEquals) {\n        // The part after the equals is left-aligned\n        arraySignature += \"l\";\n    }\n    if (hasAnnotation) {\n        // The annotation is left-aligned\n        arraySignature += \"l\";\n        // We also manually insert space in front of any annotation\n        rows = rows.map((row) => {\n            if (row[row.length - 1].length === 0) {\n                return row;\n            }\n            return [\n                ...row.slice(0, row.length - 1),\n                [QUAD, { type: \"whitespace\" }, ...row[row.length - 1]],\n            ];\n        });\n    }\n\n    // By default, the array signature will put lots of space between items.\n    // We can correct for that manually.\n    const arraySignatureWithSpacing: Ast.Node[] = properSpacing\n        ? arraySpecToSpacedArraySpec(arraySignature, hasAnnotation)\n        : [{ type: \"string\", content: arraySignature }];\n\n    const bodyRows = rows.map((row) => arrayJoin(row, AMP));\n    const body = arrayJoin(bodyRows, SEP);\n\n    const ret: Ast.Environment = {\n        type: \"environment\",\n        env: \"array\",\n        args: [\n            {\n                type: \"argument\",\n                openMark: \"{\",\n                closeMark: \"}\",\n                content: arraySignatureWithSpacing,\n            },\n        ],\n        content: body,\n    };\n\n    return ret;\n}\n\n/**\n * Find any systeme definitions, e.g. `\\sysdelim{.}{.}`, and attach their information\n * to the renderInfo of of the systeme macros.\n *\n */\nexport function attachSystemeSettingsAsRenderInfo(ast: Ast.Ast) {\n    const systemeMatcher = match.createMacroMatcher([\"systeme\", \"sysdelim\"]);\n\n    visit(\n        ast,\n        (nodes, info) => {\n            if (!info.context.inMathMode || !nodes.some(systemeMatcher)) {\n                return;\n            }\n            // Find the positions of the systeme and sysdelim macros\n            const systemeLocations = nodes.flatMap((node, i) =>\n                match.macro(node, \"systeme\") ? i : []\n            );\n            const sysdelimLocations = nodes.flatMap((node, i) =>\n                match.macro(node, \"sysdelim\") ? i : []\n            );\n\n            if (\n                systemeLocations.length === 0 ||\n                sysdelimLocations.length === 0\n            ) {\n                return;\n            }\n\n            for (const i of systemeLocations) {\n                // Find any sysdelim macros that occur before\n                const lastSysdelim = Math.max(\n                    ...sysdelimLocations.filter((loc) => loc < i)\n                );\n                if (lastSysdelim >= 0) {\n                    const node = nodes[i];\n                    const sysdelimMacro = nodes[lastSysdelim];\n                    if (!match.anyMacro(sysdelimMacro)) {\n                        throw new Error(\n                            `Expecting sysdelim macro but found \"${printRaw(\n                                sysdelimMacro\n                            )}\"`\n                        );\n                    }\n                    const args = getArgsContent(sysdelimMacro);\n                    updateRenderInfo(node, { sysdelims: args });\n                }\n            }\n        },\n        {\n            test: Array.isArray,\n            includeArrays: true,\n        }\n    );\n}\n"],"names":["match","decorateArrayForPegjs","SystemePegParser","latexPrintRaw","printRaw","arrayJoin","structuredClone","deleteComments","visit","getArgsContent","updateRenderInfo"],"mappings":"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"}