{"version":3,"file":"index.cjs","sources":["../../../package/tikz/libs/print-raw.ts"],"sourcesContent":["import { printRaw as latexPrintRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\nimport * as TikzSpec from \"./types\";\n\n/**\n * Print an `systeme` argument specification AST to a string.\n */\nexport function printRaw(node: TikzSpec.Ast, root = false): string {\n    if (typeof node === \"string\") {\n        return node;\n    }\n\n    if (Array.isArray(node)) {\n        const sepToken = root ? \" \" : \"\";\n        const printed: string[] = [];\n        for (let i = 0; i < node.length; i++) {\n            const tok = node[i];\n            const prevTok = node[i - 1];\n            if (!prevTok) {\n                printed.push(printRaw(tok));\n                continue;\n            }\n            if (prevTok.type === \"comment\") {\n                printed.push(printRaw(tok));\n                continue;\n            }\n            if (tok.type !== \"comment\") {\n                printed.push(sepToken);\n            }\n            printed.push(printRaw(tok));\n        }\n        return printed.join(\"\");\n    }\n    const type = node.type;\n\n    switch (type) {\n        case \"path_spec\":\n            return printRaw(node.content, (root = true));\n        case \"coordinate\":\n            return `${latexPrintRaw(node.prefix)}(${latexPrintRaw(\n                node.content\n            )})`;\n        case \"operation\":\n            return latexPrintRaw(node.content);\n        case \"comment\":\n            return latexPrintRaw(node);\n        case \"line_to\":\n            return node.command;\n        case \"curve_to\": {\n            const comments = node.comments\n                .map((c) => latexPrintRaw({ ...c, leadingWhitespace: false }))\n                .join(\"\");\n            if (node.controls.length === 1) {\n                return `${comments}.. controls ${printRaw(\n                    node.controls[0]\n                )} ..`;\n            } else {\n                return `${comments}.. controls ${printRaw(\n                    node.controls[0]\n                )} and ${printRaw(node.controls[1])} ..`;\n            }\n        }\n        case \"unknown\":\n            return latexPrintRaw(node.content);\n        case \"square_brace_group\":\n            return `[${latexPrintRaw(node.content)}]`;\n        case \"foreach\": {\n            const comments = node.comments\n                .map((c) => latexPrintRaw({ ...c, leadingWhitespace: false }))\n                .join(\"\");\n            let options = \"\";\n            if (node.options) {\n                options = ` [${latexPrintRaw(node.options)}]`;\n            }\n            const start = latexPrintRaw(node.start);\n            const variables = [...node.variables];\n            trim(variables);\n            let printedVariables = latexPrintRaw(variables);\n            // It is possible that the variables are specified as `[var=\\p]`, in the optional argument, instead of as `\\p`\n            // In this case, `node.variables` will be empty and we don't want an extra space showing up.\n            if (printedVariables.length > 0) {\n                printedVariables = \" \" + printedVariables;\n            }\n\n            const command =\n                node.command.type === \"foreach\"\n                    ? printRaw(node.command)\n                    : latexPrintRaw(node.command);\n\n            return `${comments}${start}${printedVariables}${options} in ${latexPrintRaw(\n                node.list\n            )} ${command}`;\n        }\n        case \"svg_operation\": {\n            const comments = node.comments\n                .map((c) => latexPrintRaw({ ...c, leadingWhitespace: false }))\n                .join(\"\");\n            let options = \"\";\n            if (node.options) {\n                options = `[${latexPrintRaw(node.options)}]`;\n            }\n\n            return `${comments}svg${options} ${latexPrintRaw(node.content)}`;\n        }\n        case \"animation\": {\n            const comments = node.comments\n                .map((c) => latexPrintRaw({ ...c, leadingWhitespace: false }))\n                .join(\"\");\n\n            return `${comments}:${node.attribute} = {${latexPrintRaw(\n                node.content\n            )}}`;\n        }\n\n        default:\n            const unprintedType: void = type;\n            console.warn(`Unknown node type \"${unprintedType}\" for node`, node);\n            return \"\";\n    }\n}\n"],"names":["latexPrintRaw","trim"],"mappings":"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"}