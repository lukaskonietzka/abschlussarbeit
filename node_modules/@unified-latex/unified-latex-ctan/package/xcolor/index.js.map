{"version":3,"file":"index.js","sources":["../../../package/xcolor/libs/print-raw.ts","../../../package/xcolor/libs/xcolor-macro-to-hex.ts","../../../package/xcolor/libs/color-to-textcolor-macro.ts"],"sourcesContent":["import * as XColorSpec from \"./types\";\n\n/**\n * Print an `xcolor` argument specification AST to a string.\n */\nexport function printRaw(node: XColorSpec.Ast, root = false): string {\n    if (typeof node === \"string\") {\n        return node;\n    }\n\n    if (Array.isArray(node)) {\n        const sepToken = root ? \" \" : \"\";\n        return node.map((tok) => printRaw(tok)).join(sepToken);\n    }\n\n    if (node.type === \"invalid_spec\") {\n        return node.content;\n    }\n\n    switch (node.type) {\n        case \"postfix\":\n            if (node.plusses != null) {\n                return `!!${node.plusses}`;\n            } else {\n                return `!![${node.num}]`;\n            }\n        case \"complete_mix\":\n            return `!${node.mix_percent}!${node.name}`;\n        case \"partial_mix\":\n            return `!${node.mix_percent}`;\n        case \"expr\":\n            return `${node.prefix || \"\"}${node.name}${node.mix_expr\n                .map((mix) => printRaw(mix))\n                .join(\"\")}${node.postfix ? printRaw(node.postfix) : \"\"}`;\n        case \"weighted_expr\":\n            return `${printRaw(node.color)},${node.weight}`;\n        case \"extended_expr\":\n            let prefix = node.core_model;\n            if (node.div) {\n                prefix += `,${node.div}`;\n            }\n            return `${prefix}:${node.expressions\n                .map((expr) => printRaw(expr))\n                .join(\";\")}`;\n        case \"function\":\n            return `>${node.name},${node.args.map((a) => \"\" + a).join(\",\")}`;\n        case \"color\":\n            return (\n                printRaw(node.color) +\n                node.functions.map((f) => printRaw(f)).join(\"\")\n            );\n\n        default:\n            console.warn(\n                `Unknown node type \"${(node as any).type}\" for node`,\n                node\n            );\n            return \"\";\n    }\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { getArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { xcolorColorToHex } from \"./xcolor\";\nimport { structuredClone } from \"@unified-latex/structured-clone\";\nimport { deleteComments } from \"@unified-latex/unified-latex-util-comments\";\n\n/**\n * Compute the hex representation of a color specified by an xcolor color command.\n * For example `\\color[rgb]{1 .5 .5}` or `\\textcolor{red}{foo}`. If the color cannot be parsed,\n * `null` is returned for the hex value. In all cases a css variable name (prefixed with \"--\"\")\n * is returned. This can be used to set up CSS for custom colors.\n */\nexport function xcolorMacroToHex(node: Ast.Macro): {\n    hex: string | null;\n    cssVarName: string;\n} {\n    // We do some destructive operations on the node, so clone it first.\n    node = structuredClone(node);\n    deleteComments(node);\n\n    // We assume the node has signature \"o m\" where o is the model and\n    // m is the color spec.\n\n    const args = getArgsContent(node);\n    const model = args[0] && printRaw(args[0]);\n    const colorStr = printRaw(args[1] || []);\n    let hex: string | null = null;\n    try {\n        hex = xcolorColorToHex(colorStr, model);\n    } catch (e) {}\n\n    const cssVarName = \"--\" + colorStr.replace(/[^a-zA-Z0-9-_]/g, \"-\");\n\n    return { hex, cssVarName };\n}\n","import { arg } from \"@unified-latex/unified-latex-builder\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Create a `\\textcolor` macro. Color arguments are taken from `origMacro`.\n */\nexport function colorToTextcolorMacro(\n    content: Ast.Node | Ast.Node[],\n    origMacro: Ast.Macro\n): Ast.Macro {\n    if (!Array.isArray(content)) {\n        content = [content];\n    }\n    // Signature of \\color is \"o m\".\n    // We want to carry through the same arguments\n    const args = (\n        origMacro.args\n            ? origMacro.args\n            : [arg([], { closeMark: \"\", openMark: \"\" }), arg([])]\n    ).concat(arg(content));\n\n    return {\n        type: \"macro\",\n        content: \"textcolor\",\n        args,\n        _renderInfo: { inParMode: true },\n    };\n}\n"],"names":["a","printRaw","e"],"mappings":";;;;;;;AAKgB,SAAA,SAAS,MAAsB,OAAO,OAAe;AAC7D,MAAA,OAAO,SAAS,UAAU;AACnB,WAAA;AAAA,EACX;AAEI,MAAA,MAAM,QAAQ,IAAI,GAAG;AACf,UAAA,WAAW,OAAO,MAAM;AACvB,WAAA,KAAK,IAAI,CAAC,QAAQ,SAAS,GAAG,CAAC,EAAE,KAAK,QAAQ;AAAA,EACzD;AAEI,MAAA,KAAK,SAAS,gBAAgB;AAC9B,WAAO,KAAK;AAAA,EAChB;AAEA,UAAQ,KAAK,MAAM;AAAA,IACf,KAAK;AACG,UAAA,KAAK,WAAW,MAAM;AACf,eAAA,KAAK,KAAK,OAAO;AAAA,MAAA,OACrB;AACI,eAAA,MAAM,KAAK,GAAG;AAAA,MACzB;AAAA,IACJ,KAAK;AACD,aAAO,IAAI,KAAK,WAAW,IAAI,KAAK,IAAI;AAAA,IAC5C,KAAK;AACM,aAAA,IAAI,KAAK,WAAW;AAAA,IAC/B,KAAK;AACM,aAAA,GAAG,KAAK,UAAU,EAAE,GAAG,KAAK,IAAI,GAAG,KAAK,SAC1C,IAAI,CAAC,QAAQ,SAAS,GAAG,CAAC,EAC1B,KAAK,EAAE,CAAC,GAAG,KAAK,UAAU,SAAS,KAAK,OAAO,IAAI,EAAE;AAAA,IAC9D,KAAK;AACD,aAAO,GAAG,SAAS,KAAK,KAAK,CAAC,IAAI,KAAK,MAAM;AAAA,IACjD,KAAK;AACD,UAAI,SAAS,KAAK;AAClB,UAAI,KAAK,KAAK;AACA,kBAAA,IAAI,KAAK,GAAG;AAAA,MAC1B;AACA,aAAO,GAAG,MAAM,IAAI,KAAK,YACpB,IAAI,CAAC,SAAS,SAAS,IAAI,CAAC,EAC5B,KAAK,GAAG,CAAC;AAAA,IAClB,KAAK;AACD,aAAO,IAAI,KAAK,IAAI,IAAI,KAAK,KAAK,IAAI,CAACA,OAAM,KAAKA,EAAC,EAAE,KAAK,GAAG,CAAC;AAAA,IAClE,KAAK;AACD,aACI,SAAS,KAAK,KAAK,IACnB,KAAK,UAAU,IAAI,CAAC,MAAM,SAAS,CAAC,CAAC,EAAE,KAAK,EAAE;AAAA,IAGtD;AACY,cAAA;AAAA,QACJ,sBAAuB,KAAa,IAAI;AAAA,QACxC;AAAA,MAAA;AAEG,aAAA;AAAA,EACf;AACJ;AC9CO,SAAS,iBAAiB,MAG/B;AAEE,SAAO,gBAAgB,IAAI;AAC3B,iBAAe,IAAI;AAKb,QAAA,OAAO,eAAe,IAAI;AAChC,QAAM,QAAQ,KAAK,CAAC,KAAKC,WAAS,KAAK,CAAC,CAAC;AACzC,QAAM,WAAWA,WAAS,KAAK,CAAC,KAAK,CAAE,CAAA;AACvC,MAAI,MAAqB;AACrB,MAAA;AACM,UAAA,iBAAiB,UAAU,KAAK;AAAA,WACjCC,IAAG;AAAA,EAAC;AAEb,QAAM,aAAa,OAAO,SAAS,QAAQ,mBAAmB,GAAG;AAE1D,SAAA,EAAE,KAAK;AAClB;AC7BgB,SAAA,sBACZ,SACA,WACS;AACT,MAAI,CAAC,MAAM,QAAQ,OAAO,GAAG;AACzB,cAAU,CAAC,OAAO;AAAA,EACtB;AAGM,QAAA,QACF,UAAU,OACJ,UAAU,OACV,CAAC,IAAI,CAAI,GAAA,EAAE,WAAW,IAAI,UAAU,IAAI,GAAG,IAAI,CAAA,CAAE,CAAC,GAC1D,OAAO,IAAI,OAAO,CAAC;AAEd,SAAA;AAAA,IACH,MAAM;AAAA,IACN,SAAS;AAAA,IACT;AAAA,IACA,aAAa,EAAE,WAAW,KAAK;AAAA,EAAA;AAEvC;"}