{"version":3,"file":"index.js","sources":["../libs/compiler-ast.ts","../libs/parse-minimal.ts","../libs/plugin-from-string-minimal.ts","../libs/reparse-math.ts","../libs/process-macros-and-environments.ts","../libs/process-at-letter-and-expl-macros.ts","../libs/plugin-from-string.ts","../libs/parse.ts","../libs/parse-math.ts"],"sourcesContent":["import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Unified complier plugin that passes through a LaTeX AST without modification.\n */\nexport const unifiedLatexAstComplier: Plugin<void[], Ast.Root, Ast.Root> =\n    function unifiedLatexAstComplier() {\n        Object.assign(this, { Compiler: (x: Ast.Root) => x });\n    };\n","import { LatexPegParser } from \"@unified-latex/unified-latex-util-pegjs\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Parse `str` to an AST with minimal processing. E.g., macro\n * arguments are not attached to macros, etc. when parsed with this\n * function.\n */\nexport function parseMinimal(str: string): Ast.Root {\n    return LatexPegParser.parse(str);\n}\n\n/**\n * Parse `str` to an AST with minimal processing. E.g., macro\n * arguments are not attached to macros, etc. when parsed with this\n * function.\n *\n * The parsing assumes a math-mode context, so, for example, `^` and `_` are\n * parsed as macros (even though arguments are not attached to them).\n */\nexport function parseMathMinimal(str: string): Ast.Node[] {\n    return LatexPegParser.parse(str, { startRule: \"math\" });\n}\n","import { Plugin, Parser } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { parseMathMinimal, parseMinimal } from \"./parse-minimal\";\n\ntype PluginOptions = {\n    /**\n     * Whether the text will be parsed assuming math mode or not.\n     */\n    mode: \"math\" | \"regular\";\n} | void;\n\n/**\n * Parse a string to a LaTeX AST with no post processing. For example,\n * no macro arguments will be attached, etc.\n */\nexport const unifiedLatexFromStringMinimal: Plugin<\n    PluginOptions[],\n    string,\n    Ast.Root\n> = function unifiedLatexFromStringMinimal(options) {\n    const parser: Parser<Ast.Root> = (str) => {\n        if (options?.mode === \"math\") {\n            return {\n                type: \"root\",\n                content: parseMathMinimal(str),\n                _renderInfo: { inMathMode: true },\n            };\n        }\n        return parseMinimal(str);\n    };\n\n    Object.assign(this, { Parser: parser });\n};\n","import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { parseMathMinimal } from \"./parse-minimal\";\n\ntype PluginOptions =\n    | {\n          /**\n           * List of environments whose body should be parsed in math mode\n           */\n          mathEnvs: string[];\n          /**\n           * List of macros whose bodies should be parsed in math mode\n           */\n          mathMacros: string[];\n      }\n    | undefined;\n\n/**\n * Reparse math environments/macro contents that should have been parsed in math mode but weren't.\n */\nexport const unifiedLatexReparseMath: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexReparseMath(options) {\n    const { mathEnvs = [], mathMacros = [] } = options || {};\n\n    return unifiedLatexReparseMathConstructPlugin({ mathMacros, mathEnvs });\n};\n\n/**\n * Construct the inner function for the `unifiedLatexReparseMath` plugin. This function should not be used by libraries.\n */\nexport function unifiedLatexReparseMathConstructPlugin({\n    mathEnvs,\n    mathMacros,\n}: {\n    mathEnvs: string[];\n    mathMacros: string[];\n}) {\n    const isMathEnvironment = match.createEnvironmentMatcher(mathEnvs);\n    const isMathMacro = match.createMacroMatcher(mathMacros);\n\n    return (tree: Ast.Root) => {\n        visit(\n            tree,\n            (node) => {\n                if (match.anyMacro(node)) {\n                    for (const arg of node.args || []) {\n                        if (\n                            arg.content.length > 0 &&\n                            !wasParsedInMathMode(arg.content)\n                        ) {\n                            arg.content = parseMathMinimal(\n                                printRaw(arg.content)\n                            );\n                        }\n                    }\n                }\n                if (match.anyEnvironment(node)) {\n                    if (!wasParsedInMathMode(node.content)) {\n                        node.content = parseMathMinimal(printRaw(node.content));\n                    }\n                }\n            },\n            {\n                test: (node) => isMathEnvironment(node) || isMathMacro(node),\n            }\n        );\n    };\n}\n\n/**\n * Use a heuristic to decide whether a string was parsed in math mode. The heuristic\n * looks for strings of length greater than 1 or the failure for \"_\" and \"^\" to be parsed\n * as a macro.\n */\nfunction wasParsedInMathMode(nodes: Ast.Node[]): boolean {\n    return !nodes.some(\n        (node) =>\n            // If there are multi-char strings or ^ and _ have been parsed as strings, we know\n            // that we were not parsed in math mode.\n            (match.anyString(node) && node.content.length > 1) ||\n            match.string(node, \"^\") ||\n            match.string(node, \"_\")\n    );\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    EnvInfoRecord,\n    MacroInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport { Plugin } from \"unified\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { unifiedLatexReparseMathConstructPlugin } from \"./reparse-math\";\nimport { attachMacroArgsInArray } from \"@unified-latex/unified-latex-util-arguments\";\nimport { processEnvironment } from \"@unified-latex/unified-latex-util-environments\";\n\ntype PluginOptions =\n    | { environments: EnvInfoRecord; macros: MacroInfoRecord }\n    | undefined;\n\n/**\n * Unified plugin to process macros and environments. Any environments that contain math content\n * are reparsed (if needed) in math mode.\n */\nexport const unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse(options) {\n    const { environments = {}, macros = {} } = options || {};\n\n    const mathMacros = Object.fromEntries(\n        Object.entries(macros).filter(\n            ([_, info]) => info.renderInfo?.inMathMode === true\n        )\n    );\n    const mathEnvs = Object.fromEntries(\n        Object.entries(environments).filter(\n            ([_, info]) => info.renderInfo?.inMathMode === true\n        )\n    );\n\n    const mathReparser = unifiedLatexReparseMathConstructPlugin({\n        mathEnvs: Object.keys(mathEnvs),\n        mathMacros: Object.keys(mathMacros),\n    });\n\n    const isRelevantEnvironment = match.createEnvironmentMatcher(environments);\n    const isRelevantMathEnvironment = match.createEnvironmentMatcher(mathEnvs);\n\n    return (tree) => {\n        // First we attach all arguments/process all nodes/environments that have math content\n        visit(\n            tree,\n            {\n                enter: (nodes) => {\n                    if (!Array.isArray(nodes)) {\n                        return;\n                    }\n                    attachMacroArgsInArray(nodes, mathMacros);\n                },\n                leave: (node) => {\n                    if (!isRelevantMathEnvironment(node)) {\n                        return;\n                    }\n                    const envName = printRaw(node.env);\n                    const envInfo = environments[envName];\n                    if (!envInfo) {\n                        throw new Error(\n                            `Could not find environment info for environment \"${envName}\"`\n                        );\n                    }\n                    processEnvironment(node, envInfo);\n                },\n            },\n            { includeArrays: true }\n        );\n\n        // Next we reparse macros/envs that may not have been parsed in math mode\n        mathReparser(tree);\n\n        // Now we attach all arguments/process all environment bodies\n        visit(\n            tree,\n            {\n                enter: (nodes) => {\n                    if (!Array.isArray(nodes)) {\n                        return;\n                    }\n                    attachMacroArgsInArray(nodes, macros);\n                },\n                leave: (node) => {\n                    if (!isRelevantEnvironment(node)) {\n                        return;\n                    }\n                    const envName = printRaw(node.env);\n                    const envInfo = environments[envName];\n                    if (!envInfo) {\n                        throw new Error(\n                            `Could not find environment info for environment \"${envName}\"`\n                        );\n                    }\n                    processEnvironment(node, envInfo);\n                },\n            },\n            { includeArrays: true }\n        );\n    };\n};\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { Plugin } from \"unified\";\nimport { reparseExpl3AndAtLetterRegions } from \"@unified-latex/unified-latex-util-catcode\";\nimport {\n    hasReparsableMacroNames,\n    reparseMacroNames,\n} from \"@unified-latex/unified-latex-util-catcode\";\n\ntype PluginOptions =\n    | {\n          /**\n           * Whether to parse macros as if `\\makeatletter` is set (i.e., parse `@` as a regular macro character).\n           * If this option is true, it disables autodetect.\n           */\n          atLetter?: boolean;\n          /**\n           * Whether to parse macros as if `\\ExplSyntaxOn` is set (i.e., parse `_` and `:` as a regular macro character)\n           * If this option is true, it disables autodetect.\n           */\n          expl3?: boolean;\n          /**\n           * Attempt to autodetect whether there are macros that look like they should contain `@`, `_`, or `:`.\n           * Defaults to `true`.\n           */\n          autodetectExpl3AndAtLetter?: boolean;\n      }\n    | undefined;\n\n/**\n * Unified plugin to reprocess macros names to possibly include `@`, `_`, or `:`.\n * This plugin detects the `\\makeatletter` and `\\ExplSyntaxOn` commands and reprocesses macro names\n * inside of those blocks to include those characters.\n */\nexport const unifiedLatexProcessAtLetterAndExplMacros: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexProcessAtLetterAndExplMacros(options) {\n    let {\n        atLetter = false,\n        expl3 = false,\n        autodetectExpl3AndAtLetter = false,\n    } = options || {};\n\n    return (tree) => {\n        // First we reparse based on explicit \\makeatletter and \\ExplSyntaxOn macros\n        reparseExpl3AndAtLetterRegions(tree);\n        if (atLetter || expl3) {\n            autodetectExpl3AndAtLetter = false;\n        }\n        if (autodetectExpl3AndAtLetter) {\n            atLetter = hasReparsableMacroNames(tree, \"@\");\n            // We don't check for the `:` here because it could be prone to misidentification.\n            expl3 = hasReparsableMacroNames(tree, \"_\");\n        }\n        const charSet: Set<string> = new Set();\n        if (atLetter) {\n            charSet.add(\"@\");\n        }\n        if (expl3) {\n            charSet.add(\":\");\n            charSet.add(\"_\");\n        }\n\n        if (charSet.size > 0) {\n            reparseMacroNames(tree, charSet);\n        }\n    };\n};\n","import { Plugin, Parser, unified } from \"unified\";\nimport { environmentInfo, macroInfo } from \"@unified-latex/unified-latex-ctan\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    EnvInfoRecord,\n    MacroInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport {\n    unifiedLatexTrimEnvironmentContents,\n    unifiedLatexTrimRoot,\n} from \"@unified-latex/unified-latex-util-trim\";\nimport { unifiedLatexAstComplier } from \"./compiler-ast\";\nimport { unifiedLatexFromStringMinimal } from \"./plugin-from-string-minimal\";\nimport { unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse } from \"./process-macros-and-environments\";\nimport { unifiedLatexProcessAtLetterAndExplMacros } from \"./process-at-letter-and-expl-macros\";\n\nexport type PluginOptions =\n    | {\n          mode?: \"math\" | \"regular\";\n          macros?: MacroInfoRecord;\n          environments?: EnvInfoRecord;\n          flags?: {\n              /**\n               * Whether to parse macros as if `\\makeatletter` is set (i.e., parse `@` as a regular macro character)\n               */\n              atLetter?: boolean;\n              /**\n               * Whether to parse macros as if `\\ExplSyntaxOn` is set (i.e., parse `_` and `:` as a regular macro character)\n               */\n              expl3?: boolean;\n              /**\n               * Attempt to autodetect whether there are macros that look like they should contain `@`, `_`, or `:`.\n               * Defaults to `false`.\n               */\n              autodetectExpl3AndAtLetter?: boolean;\n          };\n      }\n    | undefined;\n\n/**\n * Parse a string to a LaTeX AST.\n */\nexport const unifiedLatexFromString: Plugin<PluginOptions[], string, Ast.Root> =\n    function unifiedLatexFromString(options) {\n        const {\n            mode = \"regular\",\n            macros = {},\n            environments = {},\n            flags: {\n                atLetter = false,\n                expl3 = false,\n                autodetectExpl3AndAtLetter = false,\n            } = {},\n        } = options || {};\n\n        // Build up a parsing plugin with only unified components\n        const allMacroInfo: MacroInfoRecord = Object.assign(\n            {},\n            ...Object.values(macroInfo),\n            macros\n        );\n        const allEnvInfo: EnvInfoRecord = Object.assign(\n            {},\n            ...Object.values(environmentInfo),\n            environments\n        );\n\n        // Build up a parser that will perform all the needed steps\n        const fullParser = unified()\n            .use(unifiedLatexFromStringMinimal, { mode })\n            .use(unifiedLatexProcessAtLetterAndExplMacros, {\n                atLetter,\n                expl3,\n                autodetectExpl3AndAtLetter,\n            })\n            // Math environments that aren't hardcoded into the PEG grammar need to be re-parsed,\n            // so do a minimal pass first with just those environments.\n            .use(unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse, {\n                macros: allMacroInfo,\n                environments: allEnvInfo,\n            })\n            .use(unifiedLatexTrimEnvironmentContents)\n            .use(unifiedLatexTrimRoot)\n            .use(unifiedLatexAstComplier);\n\n        const parser: Parser<Ast.Root> = (str) => {\n            const file = fullParser.processSync({ value: str });\n            return file.result;\n        };\n\n        Object.assign(this, { Parser: parser });\n    };\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { type FrozenProcessor, unified } from \"unified\";\nimport { unifiedLatexFromString } from \"./plugin-from-string\";\nimport type { PluginOptions } from \"./plugin-from-string\";\n\nlet parser = unified().use(unifiedLatexFromString).freeze();\n\n/**\n * Parse the string into an AST.\n */\nexport function parse(str: string): Ast.Root {\n    return parser.parse(str);\n}\n\n/**\n * Returns the default `unified-latex` parser, or create a new one with the\n * provided `unifiedLatexFromString` options\n * @param options Plugin options of `unifiedLatexFromString` plugin.\n * @returns The default `unified-latex` parser if `options` is `undefined`, or a\n * newly created `unified-latex` parser with the provided `options`.\n */\nexport function getParser(\n    options?: PluginOptions\n): FrozenProcessor<Ast.Root, Ast.Root, Ast.Root, void> {\n    return options\n        ? unified().use(unifiedLatexFromString, options).freeze()\n        : parser;\n}\n","import { unified } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { unifiedLatexAstComplier } from \"./compiler-ast\";\nimport { unifiedLatexFromString } from \"./plugin-from-string\";\n\n/**\n * Parse `str` into an AST. Parsing starts in math mode and a list of\n * nodes is returned (instead of a \"root\" node).\n */\nexport function parseMath(str: string | Ast.Ast): Ast.Node[] {\n    if (typeof str !== \"string\") {\n        str = printRaw(str);\n    }\n    const file = unified()\n        .use(unifiedLatexFromString, { mode: \"math\" })\n        .use(unifiedLatexAstComplier)\n        .processSync({ value: str });\n    return (file.result as Ast.Root).content;\n}\n"],"names":["unifiedLatexAstComplier","unifiedLatexFromStringMinimal","parser","unifiedLatexReparseMath","unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse","unifiedLatexProcessAtLetterAndExplMacros","unifiedLatexFromString"],"mappings":"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"}