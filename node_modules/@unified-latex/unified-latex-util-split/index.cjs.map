{"version":3,"file":"index.cjs","sources":["../libs/split-on-condition.ts","../libs/split-on-macro.ts","../libs/unsplit-on-macro.ts","../libs/array-join.ts"],"sourcesContent":["import * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Split a list of nodes based on whether `splitFunc` returns `true`.\n * If `onlySplitOnFirstOccurrence` is set to true in the `options` object, then\n * there will be at most two segments returned.\n */\nexport function splitOnCondition(\n    nodes: Ast.Node[],\n    splitFunc: (node: Ast.Node) => boolean = () => false,\n    options?: { onlySplitOnFirstOccurrence?: boolean }\n): { segments: Ast.Node[][]; separators: Ast.Node[] } {\n    if (!Array.isArray(nodes)) {\n        throw new Error(`Can only split an Array, not ${nodes}`);\n    }\n\n    const { onlySplitOnFirstOccurrence = false } = options || {};\n\n    const splitIndices: number[] = [];\n    for (let i = 0; i < nodes.length; i++) {\n        if (splitFunc(nodes[i])) {\n            splitIndices.push(i);\n            if (onlySplitOnFirstOccurrence) {\n                break;\n            }\n        }\n    }\n\n    // Short circuit if there is no splitting to be done\n    if (splitIndices.length === 0) {\n        return { segments: [nodes], separators: [] };\n    }\n\n    let separators = splitIndices.map((i) => nodes[i]);\n    let segments = splitIndices.map((splitEnd, i) => {\n        const splitStart = i === 0 ? 0 : splitIndices[i - 1] + 1;\n        return nodes.slice(splitStart, splitEnd);\n    });\n    segments.push(\n        nodes.slice(splitIndices[splitIndices.length - 1] + 1, nodes.length)\n    );\n\n    return { segments, separators };\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { splitOnCondition } from \"./split-on-condition\";\n\n/**\n * Split an array of AST nodes based on a macro. An object `{segments: [], macros: []}`\n * is returned. The original array is reconstructed as\n * `segments[0] + macros[0] + segments[1] + ...`.\n *\n * @param {[object]} ast\n * @param {(string|[string])} macroName\n * @returns {{segments: [object], macros: [object]}}\n */\nexport function splitOnMacro(\n    ast: Ast.Node[],\n    macroName: string | string[]\n): { segments: Ast.Node[][]; macros: Ast.Macro[] } {\n    if (typeof macroName === \"string\") {\n        macroName = [macroName];\n    }\n    if (!Array.isArray(macroName)) {\n        throw new Error(\"Type coercion failed\");\n    }\n    const isSeparator = match.createMacroMatcher(macroName);\n    const { segments, separators } = splitOnCondition(ast, isSeparator);\n    return { segments, macros: separators as Ast.Macro[] };\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Does the reverse of `splitOnMacro`\n */\nexport function unsplitOnMacro({\n    segments,\n    macros,\n}: {\n    segments: Ast.Node[][];\n    macros: Ast.Node[] | Ast.Node[][];\n}) {\n    if (segments.length === 0) {\n        console.warn(\"Trying to join zero segments\");\n        return [];\n    }\n    if (segments.length !== macros.length + 1) {\n        console.warn(\n            \"Mismatch between lengths of macros and segments when trying to unsplit\"\n        );\n    }\n\n    let ret = segments[0];\n    for (let i = 0; i < macros.length; i++) {\n        // Even though the type of macros[i] is node and not array,\n        // Array.concat still works\n        ret = ret.concat(macros[i]).concat(segments[i + 1]);\n    }\n\n    return ret;\n}\n","/**\n * Joins an array of arrays with the item `sep`\n */\nexport function arrayJoin<T>(array: T[][], sep: T | T[]): T[] {\n    return array.flatMap((item, i) => {\n        if (i === 0) {\n            return item;\n        }\n        if (Array.isArray(sep)) {\n            return [...sep, ...item];\n        } else {\n            return [sep, ...item];\n        }\n    });\n}\n"],"names":["match"],"mappings":";;;AAOO,SAAS,iBACZ,OACA,YAAyC,MAAM,OAC/C,SACkD;AAClD,MAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACvB,UAAM,IAAI,MAAM,gCAAgC,KAAK,EAAE;AAAA,EAC3D;AAEA,QAAM,EAAE,6BAA6B,UAAU,WAAW,CAAA;AAE1D,QAAM,eAAyB,CAAA;AAC/B,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,QAAI,UAAU,MAAM,CAAC,CAAC,GAAG;AACrB,mBAAa,KAAK,CAAC;AACnB,UAAI,4BAA4B;AAC5B;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAGI,MAAA,aAAa,WAAW,GAAG;AAC3B,WAAO,EAAE,UAAU,CAAC,KAAK,GAAG,YAAY,CAAG,EAAA;AAAA,EAC/C;AAEA,MAAI,aAAa,aAAa,IAAI,CAAC,MAAM,MAAM,CAAC,CAAC;AACjD,MAAI,WAAW,aAAa,IAAI,CAAC,UAAU,MAAM;AAC7C,UAAM,aAAa,MAAM,IAAI,IAAI,aAAa,IAAI,CAAC,IAAI;AAChD,WAAA,MAAM,MAAM,YAAY,QAAQ;AAAA,EAAA,CAC1C;AACQ,WAAA;AAAA,IACL,MAAM,MAAM,aAAa,aAAa,SAAS,CAAC,IAAI,GAAG,MAAM,MAAM;AAAA,EAAA;AAGhE,SAAA,EAAE,UAAU;AACvB;AC9BgB,SAAA,aACZ,KACA,WAC+C;AAC3C,MAAA,OAAO,cAAc,UAAU;AAC/B,gBAAY,CAAC,SAAS;AAAA,EAC1B;AACA,MAAI,CAAC,MAAM,QAAQ,SAAS,GAAG;AACrB,UAAA,IAAI,MAAM,sBAAsB;AAAA,EAC1C;AACM,QAAA,cAAcA,sBAAAA,MAAM,mBAAmB,SAAS;AACtD,QAAM,EAAE,UAAU,WAAA,IAAe,iBAAiB,KAAK,WAAW;AAC3D,SAAA,EAAE,UAAU,QAAQ;AAC/B;ACrBO,SAAS,eAAe;AAAA,EAC3B;AAAA,EACA;AACJ,GAGG;AACK,MAAA,SAAS,WAAW,GAAG;AACvB,YAAQ,KAAK,8BAA8B;AAC3C,WAAO;EACX;AACA,MAAI,SAAS,WAAW,OAAO,SAAS,GAAG;AAC/B,YAAA;AAAA,MACJ;AAAA,IAAA;AAAA,EAER;AAEI,MAAA,MAAM,SAAS,CAAC;AACpB,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AAG9B,UAAA,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,OAAO,SAAS,IAAI,CAAC,CAAC;AAAA,EACtD;AAEO,SAAA;AACX;AC3BgB,SAAA,UAAa,OAAc,KAAmB;AAC1D,SAAO,MAAM,QAAQ,CAAC,MAAM,MAAM;AAC9B,QAAI,MAAM,GAAG;AACF,aAAA;AAAA,IACX;AACI,QAAA,MAAM,QAAQ,GAAG,GAAG;AACpB,aAAO,CAAC,GAAG,KAAK,GAAG,IAAI;AAAA,IAAA,OACpB;AACI,aAAA,CAAC,KAAK,GAAG,IAAI;AAAA,IACxB;AAAA,EAAA,CACH;AACL;;;;;"}