{"version":3,"file":"index.cjs","sources":["../libs/process-environment.ts","../libs/unified-latex-process-environment.ts"],"sourcesContent":["import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { EnvInfo, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\nimport { gobbleArguments } from \"@unified-latex/unified-latex-util-arguments\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\n/**\n * Performs any needed processing on the environment (as specified by `envInfo`)\n * including attaching arguments and possibly manipulating the environment's body.\n */\nexport function processEnvironment(envNode: Ast.Environment, envInfo: EnvInfo) {\n    if (envInfo.signature && envNode.args == null) {\n        const { args } = gobbleArguments(envNode.content, envInfo.signature);\n        envNode.args = args;\n    }\n\n    updateRenderInfo(envNode, envInfo.renderInfo);\n    if (typeof envInfo.processContent === \"function\") {\n        envNode.content = envInfo.processContent(envNode.content);\n    }\n}\n\n/**\n * Recursively search for and process the specified environments. Arguments are\n * consumed according to the `signature` specified. The body is processed\n * with the specified `processContent` function (if given). Any specified `renderInfo`\n * is attached to the environment node.\n */\nexport function processEnvironments(\n    tree: Ast.Ast,\n    environments: EnvInfoRecord\n) {\n    const isRelevantEnvironment = match.createEnvironmentMatcher(environments);\n\n    visit(\n        tree,\n        {\n            leave: (node) => {\n                const envName = printRaw(node.env);\n                const envInfo = environments[envName];\n                if (!envInfo) {\n                    throw new Error(\n                        `Could not find environment info for environment \"${envName}\"`\n                    );\n                }\n                processEnvironment(node, envInfo);\n            },\n        },\n        { test: isRelevantEnvironment }\n    );\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { Plugin } from \"unified\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { processEnvironment } from \"./process-environment\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\ntype PluginOptions = { environments: EnvInfoRecord } | undefined;\n\n/**\n * Unified plugin to process environment content and attach arguments.\n *\n * @param environments An object whose keys are environment names and values contains information about the environment and its argument signature.\n */\nexport const unifiedLatexProcessEnvironments: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexAttachMacroArguments(options) {\n    const { environments = {} } = options || {};\n    const isRelevantEnvironment = match.createEnvironmentMatcher(environments);\n\n    return (tree) => {\n        if (Object.keys(environments).length === 0) {\n            console.warn(\n                \"Attempting to attach macro arguments but no macros are specified.\"\n            );\n        }\n\n        visit(\n            tree,\n            {\n                leave: (node) => {\n                    const envName = printRaw(node.env);\n                    const envInfo = environments[envName];\n                    if (!envInfo) {\n                        throw new Error(\n                            `Could not find environment info for environment \"${envName}\"`\n                        );\n                    }\n                    processEnvironment(node, envInfo);\n                },\n            },\n            { test: isRelevantEnvironment }\n        );\n    };\n};\n"],"names":["gobbleArguments","updateRenderInfo","match","visit","printRaw"],"mappings":";;;;;;;AAYgB,SAAA,mBAAmB,SAA0B,SAAkB;AAC3E,MAAI,QAAQ,aAAa,QAAQ,QAAQ,MAAM;AAC3C,UAAM,EAAE,KAAK,IAAIA,0CAAgB,QAAQ,SAAS,QAAQ,SAAS;AACnE,YAAQ,OAAO;AAAA,EACnB;AAEiBC,6BAAAA,iBAAA,SAAS,QAAQ,UAAU;AACxC,MAAA,OAAO,QAAQ,mBAAmB,YAAY;AAC9C,YAAQ,UAAU,QAAQ,eAAe,QAAQ,OAAO;AAAA,EAC5D;AACJ;AAQgB,SAAA,oBACZ,MACA,cACF;AACQ,QAAA,wBAAwBC,sBAAAA,MAAM,yBAAyB,YAAY;AAEzEC,wBAAA;AAAA,IACI;AAAA,IACA;AAAA,MACI,OAAO,CAAC,SAAS;AACP,cAAA,UAAUC,yBAAAA,SAAS,KAAK,GAAG;AAC3B,cAAA,UAAU,aAAa,OAAO;AACpC,YAAI,CAAC,SAAS;AACV,gBAAM,IAAI;AAAA,YACN,oDAAoD,OAAO;AAAA,UAAA;AAAA,QAEnE;AACA,2BAAmB,MAAM,OAAO;AAAA,MACpC;AAAA,IACJ;AAAA,IACA,EAAE,MAAM,sBAAsB;AAAA,EAAA;AAEtC;ACrCa,MAAA,kCAIT,SAAS,iCAAiC,SAAS;AACnD,QAAM,EAAE,eAAe,CAAA,MAAO,WAAW,CAAA;AACnC,QAAA,wBAAwBF,sBAAAA,MAAM,yBAAyB,YAAY;AAEzE,SAAO,CAAC,SAAS;AACb,QAAI,OAAO,KAAK,YAAY,EAAE,WAAW,GAAG;AAChC,cAAA;AAAA,QACJ;AAAA,MAAA;AAAA,IAER;AAEAC,0BAAA;AAAA,MACI;AAAA,MACA;AAAA,QACI,OAAO,CAAC,SAAS;AACP,gBAAA,UAAUC,yBAAAA,SAAS,KAAK,GAAG;AAC3B,gBAAA,UAAU,aAAa,OAAO;AACpC,cAAI,CAAC,SAAS;AACV,kBAAM,IAAI;AAAA,cACN,oDAAoD,OAAO;AAAA,YAAA;AAAA,UAEnE;AACA,6BAAmB,MAAM,OAAO;AAAA,QACpC;AAAA,MACJ;AAAA,MACA,EAAE,MAAM,sBAAsB;AAAA,IAAA;AAAA,EAClC;AAER;;;;"}