{"version":3,"file":"index.cjs","sources":["../libs/match.ts"],"sourcesContent":["import * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    EnvInfo,\n    MacroInfo,\n    MacroInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\n/**\n * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros\n * and generates a hash for quick lookup.\n */\nfunction createMacroMatcher<S extends string>(\n    macros: Ast.Macro[] | S[] | Record<S, unknown>\n) {\n    // We first make sure we have a record type with keys being the macro's contents\n    const macrosHash: Record<string, unknown> = Array.isArray(macros)\n        ? macros.length > 0\n            ? typeof macros[0] === \"string\"\n                ? Object.fromEntries(\n                      macros.map((macro) => {\n                          if (typeof macro !== \"string\") {\n                              throw new Error(\"Wrong branch of map function\");\n                          }\n                          return [macro, {}] as [string, MacroInfo];\n                      })\n                  )\n                : Object.fromEntries(\n                      macros.map((macro) => {\n                          if (typeof macro === \"string\") {\n                              throw new Error(\"Wrong branch of map function\");\n                          }\n                          if (macro.escapeToken != null) {\n                              return [\n                                  macro.content,\n                                  { escapeToken: macro.escapeToken },\n                              ] as [string, MacroInfo];\n                          }\n                          return [macro.content, {}] as [string, MacroInfo];\n                      })\n                  )\n            : {}\n        : macros;\n\n    return function matchAgainstMacros(node: any | Ast.Macro) {\n        if (node == null || node.type !== \"macro\") {\n            return false;\n        }\n        // At this point we have a macro type\n        const spec = macrosHash[node.content];\n        if (!spec) {\n            return false;\n        }\n\n        if (typeof spec === \"object\" && \"escapeToken\" in spec) {\n            return (\n                (spec as MacroInfoRecord).escapeToken == null ||\n                (spec as MacroInfoRecord).escapeToken === node.escapeToken\n            );\n        }\n        return true;\n    } as Ast.TypeGuard<Ast.Macro & { content: S }>;\n}\n\n/**\n * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros\n * and generates a hash for quick lookup.\n */\nfunction createEnvironmentMatcher(macros: string[] | Record<string, unknown>) {\n    // We first make sure we have a record type with keys being the macro's contents\n    const environmentsHash = Array.isArray(macros)\n        ? Object.fromEntries(\n              macros.map((str) => {\n                  return [str, {}] as [string, EnvInfo];\n              })\n          )\n        : macros;\n\n    return function matchAgainstEnvironments(node: any | Ast.Environment) {\n        if (!match.anyEnvironment(node)) {\n            return false;\n        }\n        // At this point we have an environment type\n        const envName = printRaw(node.env);\n        const spec = environmentsHash[envName];\n        if (!spec) {\n            return false;\n        }\n\n        return true;\n    } as Ast.TypeGuard<Ast.Environment>;\n}\n\n/**\n * Functions to match different types of nodes.\n */\nexport const match = {\n    macro(node: any, macroName?: string): node is Ast.Macro {\n        if (node == null) {\n            return false;\n        }\n        return (\n            node.type === \"macro\" &&\n            (macroName == null || node.content === macroName)\n        );\n    },\n    anyMacro(node: any): node is Ast.Macro {\n        return match.macro(node);\n    },\n    environment(node: any, envName?: string): node is Ast.Environment {\n        if (node == null) {\n            return false;\n        }\n        return (\n            (node.type === \"environment\" || node.type === \"mathenv\") &&\n            (envName == null || printRaw(node.env) === envName)\n        );\n    },\n    anyEnvironment(node: any): node is Ast.Environment {\n        return match.environment(node);\n    },\n    comment(node: any): node is Ast.Comment {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"comment\";\n    },\n    parbreak(node: any): node is Ast.Parbreak {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"parbreak\";\n    },\n    whitespace(node: any): node is Ast.Whitespace {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"whitespace\";\n    },\n    /**\n     * Matches whitespace or a comment with leading whitespace.\n     */\n    whitespaceLike(\n        node: any\n    ): node is Ast.Whitespace | (Ast.Comment & { leadingWhitespace: true }) {\n        if (node == null) {\n            return false;\n        }\n        return (\n            node.type === \"whitespace\" ||\n            (node.type === \"whitespace\" && node.leadingWhitespace === true)\n        );\n    },\n    string(node: any, value?: string): node is Ast.String {\n        if (node == null) {\n            return false;\n        }\n        return (\n            node.type === \"string\" && (value == null || node.content === value)\n        );\n    },\n    anyString(node: any): node is Ast.String {\n        return match.string(node);\n    },\n    group(node: any): node is Ast.Group {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"group\";\n    },\n    argument(node: any): node is Ast.Argument {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"argument\";\n    },\n    blankArgument(node: any): boolean {\n        if (!match.argument(node)) {\n            return false;\n        }\n        return (\n            node.openMark === \"\" &&\n            node.closeMark === \"\" &&\n            node.content.length === 0\n        );\n    },\n    math(node: any): node is Ast.DisplayMath | Ast.InlineMath {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"displaymath\" || node.type === \"inlinemath\";\n    },\n    createMacroMatcher,\n    createEnvironmentMatcher,\n};\n\nexport const {\n    anyEnvironment,\n    anyMacro,\n    anyString,\n    argument,\n    blankArgument,\n    comment,\n    environment,\n    group,\n    macro,\n    math,\n    parbreak,\n    string,\n    whitespace,\n} = match;\n"],"names":["macro","printRaw"],"mappings":"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"}