{"version":3,"file":"index.js","sources":["../libs/pgfkeys-parser.ts","../libs/pgfkeys-to-object.ts"],"sourcesContent":["import { PgfkeysPegParser } from \"@unified-latex/unified-latex-util-pegjs\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { decorateArrayForPegjs } from \"@unified-latex/unified-latex-util-pegjs\";\n\n// The types returned by the grammar\n\nexport type Item = {\n    itemParts?: Ast.Node[][];\n    trailingComment: Ast.Comment | null;\n    trailingComma?: boolean;\n    leadingParbreak?: boolean;\n};\n\nexport function createMatchers() {\n    return {\n        isChar: (node: Ast.Node, char: string) => match.string(node, char),\n        isComma: (node: Ast.Node) => match.string(node, \",\"),\n        isEquals: (node: Ast.Node) => match.string(node, \"=\"),\n        isWhitespace: (node: Ast.Node) => match.whitespace(node),\n        isParbreak: (node: Ast.Node) => match.parbreak(node),\n        isSameLineComment: (node: Ast.Node) =>\n            match.comment(node) && node.sameline,\n        isOwnLineComment: (node: Ast.Node) =>\n            match.comment(node) && !node.sameline,\n    };\n}\n\n/**\n * Parse the arguments of a Pgfkeys macro. The `ast`\n * is expected to be a comma separated list of `Item`s.\n * Each item can have 0 or more item parts, which are separated\n * by \"=\". If `itemPart` is undefined,\n *\n * If `options.allowParenGroups === true`, then commas that occur inside groups of parenthesis\n * will not be parsed as separators. This is useful for parsing tikz `\\foreach` loops.\n */\nexport function parsePgfkeys(\n    ast: Ast.Node[],\n    options?: { allowParenGroups: boolean }\n): Item[] {\n    if (!Array.isArray(ast)) {\n        throw new Error(\"You must pass an array of nodes\");\n    }\n    const { allowParenGroups = false } = options || {};\n    // We need to at functions to `nodes` so that it imitates\n    // a Javascript string. Because we're mutating, make a copy first\n    ast = decorateArrayForPegjs([...ast]);\n    // matchers are passed in via the second argument (the `options` argument)\n    // so they are available from within the Pegjs grammar.\n    return PgfkeysPegParser.parse(ast, {\n        ...createMatchers(),\n        allowParenGroups,\n    }) as Item[];\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { parsePgfkeys } from \"./pgfkeys-parser\";\n\n/**\n * Parse `arg` as pgfkeys and return a JavaScript object with the results.\n * The keys will be normalized to strings and the values will be arrays of nodes.\n */\nexport function pgfkeysArgToObject(\n    arg: Ast.Argument | Ast.Node[]\n): Record<string, Ast.Node[]> {\n    function parseFront(nodes: Ast.Node[]): string {\n        return printRaw(nodes);\n    }\n    function parseBack(nodes: Ast.Node[] | undefined): Ast.Node[] {\n        if (!nodes) {\n            return [];\n        }\n        // If the only element is a group, we unwrap it\n        if (nodes.length === 1 && match.group(nodes[0])) {\n            return nodes[0].content;\n        }\n        return nodes;\n    }\n\n    let nodeList: Ast.Node[];\n    if (match.argument(arg)) {\n        nodeList = arg.content;\n    } else {\n        nodeList = arg;\n    }\n    const parsedArgs = parsePgfkeys(nodeList);\n    return Object.fromEntries(\n        parsedArgs\n            .filter((part) => part.itemParts)\n            .map((part) => [\n                parseFront(part.itemParts![0]),\n                parseBack(part.itemParts![1]),\n            ])\n    );\n}\n"],"names":[],"mappings":";;;AAcO,SAAS,iBAAiB;AACtB,SAAA;AAAA,IACH,QAAQ,CAAC,MAAgB,SAAiB,MAAM,OAAO,MAAM,IAAI;AAAA,IACjE,SAAS,CAAC,SAAmB,MAAM,OAAO,MAAM,GAAG;AAAA,IACnD,UAAU,CAAC,SAAmB,MAAM,OAAO,MAAM,GAAG;AAAA,IACpD,cAAc,CAAC,SAAmB,MAAM,WAAW,IAAI;AAAA,IACvD,YAAY,CAAC,SAAmB,MAAM,SAAS,IAAI;AAAA,IACnD,mBAAmB,CAAC,SAChB,MAAM,QAAQ,IAAI,KAAK,KAAK;AAAA,IAChC,kBAAkB,CAAC,SACf,MAAM,QAAQ,IAAI,KAAK,CAAC,KAAK;AAAA,EAAA;AAEzC;AAWgB,SAAA,aACZ,KACA,SACM;AACN,MAAI,CAAC,MAAM,QAAQ,GAAG,GAAG;AACf,UAAA,IAAI,MAAM,iCAAiC;AAAA,EACrD;AACA,QAAM,EAAE,mBAAmB,UAAU,WAAW,CAAA;AAGhD,QAAM,sBAAsB,CAAC,GAAG,GAAG,CAAC;AAG7B,SAAA,iBAAiB,MAAM,KAAK;AAAA,IAC/B,GAAG,eAAe;AAAA,IAClB;AAAA,EAAA,CACH;AACL;AC7CO,SAAS,mBACZ,KAC0B;AAC1B,WAAS,WAAW,OAA2B;AAC3C,WAAO,SAAS,KAAK;AAAA,EACzB;AACA,WAAS,UAAU,OAA2C;AAC1D,QAAI,CAAC,OAAO;AACR,aAAO;IACX;AAEI,QAAA,MAAM,WAAW,KAAK,MAAM,MAAM,MAAM,CAAC,CAAC,GAAG;AACtC,aAAA,MAAM,CAAC,EAAE;AAAA,IACpB;AACO,WAAA;AAAA,EACX;AAEI,MAAA;AACA,MAAA,MAAM,SAAS,GAAG,GAAG;AACrB,eAAW,IAAI;AAAA,EAAA,OACZ;AACQ,eAAA;AAAA,EACf;AACM,QAAA,aAAa,aAAa,QAAQ;AACxC,SAAO,OAAO;AAAA,IACV,WACK,OAAO,CAAC,SAAS,KAAK,SAAS,EAC/B,IAAI,CAAC,SAAS;AAAA,MACX,WAAW,KAAK,UAAW,CAAC,CAAC;AAAA,MAC7B,UAAU,KAAK,UAAW,CAAC,CAAC;AAAA,IAAA,CAC/B;AAAA,EAAA;AAEb;"}