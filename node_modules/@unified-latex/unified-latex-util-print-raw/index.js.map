{"version":3,"file":"index.js","sources":["../libs/print-raw.ts"],"sourcesContent":["import * as Ast from \"@unified-latex/unified-latex-types\";\n\ntype Printable = Ast.Node | Ast.Argument | string;\ntype PrintToken = string | typeof linebreak;\n\nexport const linebreak = Symbol(\"linebreak\");\nconst ESCAPE = \"\\\\\";\n\n/**\n * Renders the AST to an array inserting `linebreak` where needed;\n * This array may be nested.\n *\n * @param {*} node\n */\nfunction _printRaw(node: Printable | Printable[]): PrintToken[] {\n    if (typeof node === \"string\") {\n        return [node];\n    }\n    if (Array.isArray(node)) {\n        return ([] as PrintToken[]).concat(\n            ...node.map((n: Printable) => _printRaw(n))\n        );\n    }\n    // tmp variables\n    let argsString, escape;\n    switch (node.type) {\n        case \"root\":\n            return _printRaw(node.content);\n        case \"argument\":\n            return [node.openMark, ..._printRaw(node.content), node.closeMark];\n        case \"comment\":\n            let suffix = node.suffixParbreak ? \"\" : linebreak;\n            // A comment is responsible for printing its own leading whitespace\n            let leadingWhitespace = \"\";\n            if (node.sameline && node.leadingWhitespace) {\n                leadingWhitespace = \" \";\n            }\n            if (node.sameline) {\n                return [\n                    leadingWhitespace,\n                    \"%\",\n                    ..._printRaw(node.content),\n                    suffix,\n                ];\n            }\n            return [linebreak, \"%\", ..._printRaw(node.content), suffix];\n        case \"environment\":\n        case \"mathenv\":\n        case \"verbatim\":\n            let env = _printRaw(node.env);\n            let envStart: PrintToken[] = [ESCAPE + \"begin{\", ...env, \"}\"];\n            let envEnd: PrintToken[] = [ESCAPE + \"end{\", ...env, \"}\"];\n            argsString =\n                (node as any).args == null ? [] : _printRaw((node as any).args);\n            return [\n                ...envStart,\n                ...argsString,\n                ..._printRaw(node.content),\n                ...envEnd,\n            ];\n        case \"displaymath\":\n            return [ESCAPE + \"[\", ..._printRaw(node.content), ESCAPE + \"]\"];\n        case \"group\":\n            return [\"{\", ..._printRaw(node.content), \"}\"];\n        case \"inlinemath\":\n            return [\"$\", ..._printRaw(node.content), \"$\"];\n        case \"macro\":\n            argsString = node.args == null ? [] : _printRaw(node.args);\n            escape = node.escapeToken == null ? ESCAPE : node.escapeToken;\n            return [escape, ..._printRaw(node.content), ...argsString];\n        case \"parbreak\":\n            return [linebreak, linebreak];\n        case \"string\":\n            return [node.content];\n        case \"verb\":\n            return [\n                ESCAPE,\n                node.env,\n                node.escape,\n                ..._printRaw(node.content),\n                node.escape,\n            ];\n        case \"whitespace\":\n            return [\" \"];\n\n        default:\n            console.warn(\n                \"Cannot find render for node \",\n                node,\n                `(of type ${typeof node})`\n            );\n            return [\"\" + node];\n    }\n}\n\n/**\n * Renders the AST to a string without any pretty printing.\n *\n * @param {*} node\n * @param {*} options - Setting `asArray` to `true` will return an array of strings and the symbol `linebreak`, so that printing can be customized.\n */\nexport function printRaw(\n    node: Printable | Printable[],\n    options?: { asArray: false }\n): string;\nexport function printRaw(\n    node: Printable | Printable[],\n    options: { asArray: true }\n): PrintToken[];\nexport function printRaw(node: Printable | Printable[], options?: object): any {\n    const asArray = options != null ? (options as any).asArray : false;\n    const printedTokens = _printRaw(node);\n    if (asArray) {\n        return printedTokens;\n    }\n    return printedTokens.map((x) => (x === linebreak ? \"\\n\" : x)).join(\"\");\n}\n"],"names":[],"mappings":"AAKa,MAAA,YAAY,OAAO,WAAW;AAC3C,MAAM,SAAS;AAQf,SAAS,UAAU,MAA6C;AACxD,MAAA,OAAO,SAAS,UAAU;AAC1B,WAAO,CAAC,IAAI;AAAA,EAChB;AACI,MAAA,MAAM,QAAQ,IAAI,GAAG;AACrB,WAAQ,CAAoB,EAAA;AAAA,MACxB,GAAG,KAAK,IAAI,CAAC,MAAiB,UAAU,CAAC,CAAC;AAAA,IAAA;AAAA,EAElD;AAEA,MAAI,YAAY;AAChB,UAAQ,KAAK,MAAM;AAAA,IACf,KAAK;AACM,aAAA,UAAU,KAAK,OAAO;AAAA,IACjC,KAAK;AACM,aAAA,CAAC,KAAK,UAAU,GAAG,UAAU,KAAK,OAAO,GAAG,KAAK,SAAS;AAAA,IACrE,KAAK;AACG,UAAA,SAAS,KAAK,iBAAiB,KAAK;AAExC,UAAI,oBAAoB;AACpB,UAAA,KAAK,YAAY,KAAK,mBAAmB;AACrB,4BAAA;AAAA,MACxB;AACA,UAAI,KAAK,UAAU;AACR,eAAA;AAAA,UACH;AAAA,UACA;AAAA,UACA,GAAG,UAAU,KAAK,OAAO;AAAA,UACzB;AAAA,QAAA;AAAA,MAER;AACO,aAAA,CAAC,WAAW,KAAK,GAAG,UAAU,KAAK,OAAO,GAAG,MAAM;AAAA,IAC9D,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACG,UAAA,MAAM,UAAU,KAAK,GAAG;AAC5B,UAAI,WAAyB,CAAC,SAAS,UAAU,GAAG,KAAK,GAAG;AAC5D,UAAI,SAAuB,CAAC,SAAS,QAAQ,GAAG,KAAK,GAAG;AACxD,mBACK,KAAa,QAAQ,OAAO,CAAK,IAAA,UAAW,KAAa,IAAI;AAC3D,aAAA;AAAA,QACH,GAAG;AAAA,QACH,GAAG;AAAA,QACH,GAAG,UAAU,KAAK,OAAO;AAAA,QACzB,GAAG;AAAA,MAAA;AAAA,IAEX,KAAK;AACM,aAAA,CAAC,SAAS,KAAK,GAAG,UAAU,KAAK,OAAO,GAAG,SAAS,GAAG;AAAA,IAClE,KAAK;AACD,aAAO,CAAC,KAAK,GAAG,UAAU,KAAK,OAAO,GAAG,GAAG;AAAA,IAChD,KAAK;AACD,aAAO,CAAC,KAAK,GAAG,UAAU,KAAK,OAAO,GAAG,GAAG;AAAA,IAChD,KAAK;AACD,mBAAa,KAAK,QAAQ,OAAO,CAAK,IAAA,UAAU,KAAK,IAAI;AACzD,eAAS,KAAK,eAAe,OAAO,SAAS,KAAK;AAC3C,aAAA,CAAC,QAAQ,GAAG,UAAU,KAAK,OAAO,GAAG,GAAG,UAAU;AAAA,IAC7D,KAAK;AACM,aAAA,CAAC,WAAW,SAAS;AAAA,IAChC,KAAK;AACM,aAAA,CAAC,KAAK,OAAO;AAAA,IACxB,KAAK;AACM,aAAA;AAAA,QACH;AAAA,QACA,KAAK;AAAA,QACL,KAAK;AAAA,QACL,GAAG,UAAU,KAAK,OAAO;AAAA,QACzB,KAAK;AAAA,MAAA;AAAA,IAEb,KAAK;AACD,aAAO,CAAC,GAAG;AAAA,IAEf;AACY,cAAA;AAAA,QACJ;AAAA,QACA;AAAA,QACA,YAAY,OAAO,IAAI;AAAA,MAAA;AAEpB,aAAA,CAAC,KAAK,IAAI;AAAA,EACzB;AACJ;AAgBgB,SAAA,SAAS,MAA+B,SAAuB;AAC3E,QAAM,UAAU,WAAW,OAAQ,QAAgB,UAAU;AACvD,QAAA,gBAAgB,UAAU,IAAI;AACpC,MAAI,SAAS;AACF,WAAA;AAAA,EACX;AACO,SAAA,cAAc,IAAI,CAAC,MAAO,MAAM,YAAY,OAAO,CAAE,EAAE,KAAK,EAAE;AACzE;"}