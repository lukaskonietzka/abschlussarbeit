{"version":3,"file":"index.js","sources":["../libs/argspec-parser.ts"],"sourcesContent":["import { ArgSpecPegParser as PegParser } from \"@unified-latex/unified-latex-util-pegjs\";\nimport * as ArgSpec from \"./argspec-types\";\n\n/**\n * Produce a string containing any decorators for the argspec node.\n * For example, `!` in front of a node means \"don't accept leading whitespace\"\n */\nfunction getDecorators(node: ArgSpec.Node): string {\n    let ret = \"\";\n    if ((node as ArgSpec.LeadingWhitespace).noLeadingWhitespace) {\n        ret += \"!\";\n    }\n    return ret;\n}\n\n/**\n * Print an `xparse` argument specification AST\n * to a string.\n */\nexport function printRaw(\n    node: ArgSpec.Node | string | (ArgSpec.Node | string)[],\n    root = false\n): string {\n    if (typeof node === \"string\") {\n        return node;\n    }\n\n    if (Array.isArray(node)) {\n        const sepToken = root ? \" \" : \"\";\n        return node.map((tok) => printRaw(tok)).join(sepToken);\n    }\n\n    const decorators = getDecorators(node);\n    const defaultArg = printDefaultArg(\n        \"defaultArg\" in node ? node.defaultArg : undefined,\n        // `embellishment`s are the only spec that can have multiple default args\n        node.type === \"embellishment\"\n    );\n    let spec = decorators;\n\n    const type = node.type;\n    switch (type) {\n        case \"body\":\n            return decorators + \"b\";\n        case \"optionalStar\":\n            return decorators + \"s\";\n        case \"optionalToken\":\n            return spec + \"t\" + node.token;\n        case \"optional\":\n            // [...] is the default enclosure for optional arguments\n            if (node.openBrace === \"[\" && node.closeBrace === \"]\") {\n                spec += node.defaultArg ? \"O\" : \"o\";\n            } else {\n                spec += node.defaultArg ? \"D\" : \"d\";\n                spec += node.openBrace + node.closeBrace;\n            }\n            return spec + defaultArg;\n        case \"mandatory\":\n            // {...} is the default enclosure for mandatory arguments\n            if (node.openBrace === \"{\" && node.closeBrace === \"}\") {\n                spec += \"m\";\n            } else {\n                spec += node.defaultArg ? \"R\" : \"r\";\n                spec += node.openBrace + node.closeBrace;\n            }\n            return spec + defaultArg;\n        case \"embellishment\":\n            spec += node.defaultArg ? \"E\" : \"e\";\n            return (\n                spec +\n                \"{\" +\n                printRaw(node.embellishmentTokens) +\n                \"}\" +\n                defaultArg\n            );\n        case \"verbatim\":\n            return spec + \"v\" + node.openBrace;\n        case \"group\":\n            return spec + \"{\" + printRaw(node.content) + \"}\";\n        case \"until\": {\n            const stopTokens = printRaw(node.stopTokens);\n            return stopTokens.length > 1 || stopTokens[0] === \" \"\n                ? `u{${stopTokens}}`\n                : `u${stopTokens}`;\n        }\n        default:\n            const neverType: never = type;\n            console.warn(`Unknown node type \"${neverType}\" for node`, node);\n            return \"\";\n    }\n}\n\nconst parseCache: { [argStr: string]: ArgSpec.Node[] } = {};\n\n/**\n * Parse an `xparse` argument specification string to an AST.\n * This function caches results. Don't mutate the returned AST!\n *\n * @param {string} [str=\"\"] - LaTeX string input\n * @returns - AST for LaTeX string\n */\nexport function parse(str = \"\"): ArgSpec.Node[] {\n    parseCache[str] = parseCache[str] || PegParser.parse(str);\n    return parseCache[str];\n}\n\nfunction printDefaultArg(\n    args: string | string[] | undefined,\n    multipleArgs: boolean\n): string {\n    if (!args) {\n        return \"\";\n    }\n    if (typeof args === \"string\") {\n        args = [args];\n    }\n    if (!multipleArgs) {\n        return `{${args.join(\"\")}}`;\n    }\n    return `{${args.map((a) => `{${a}}`).join(\"\")}}`;\n}\n"],"names":["PegParser"],"mappings":";AAOA,SAAS,cAAc,MAA4B;AAC/C,MAAI,MAAM;AACV,MAAK,KAAmC,qBAAqB;AAClD,WAAA;AAAA,EACX;AACO,SAAA;AACX;AAMgB,SAAA,SACZ,MACA,OAAO,OACD;AACF,MAAA,OAAO,SAAS,UAAU;AACnB,WAAA;AAAA,EACX;AAEI,MAAA,MAAM,QAAQ,IAAI,GAAG;AACf,UAAA,WAAW,OAAO,MAAM;AACvB,WAAA,KAAK,IAAI,CAAC,QAAQ,SAAS,GAAG,CAAC,EAAE,KAAK,QAAQ;AAAA,EACzD;AAEM,QAAA,aAAa,cAAc,IAAI;AACrC,QAAM,aAAa;AAAA,IACf,gBAAgB,OAAO,KAAK,aAAa;AAAA;AAAA,IAEzC,KAAK,SAAS;AAAA,EAAA;AAElB,MAAI,OAAO;AAEX,QAAM,OAAO,KAAK;AAClB,UAAQ,MAAM;AAAA,IACV,KAAK;AACD,aAAO,aAAa;AAAA,IACxB,KAAK;AACD,aAAO,aAAa;AAAA,IACxB,KAAK;AACM,aAAA,OAAO,MAAM,KAAK;AAAA,IAC7B,KAAK;AAED,UAAI,KAAK,cAAc,OAAO,KAAK,eAAe,KAAK;AAC3C,gBAAA,KAAK,aAAa,MAAM;AAAA,MAAA,OAC7B;AACK,gBAAA,KAAK,aAAa,MAAM;AACxB,gBAAA,KAAK,YAAY,KAAK;AAAA,MAClC;AACA,aAAO,OAAO;AAAA,IAClB,KAAK;AAED,UAAI,KAAK,cAAc,OAAO,KAAK,eAAe,KAAK;AAC3C,gBAAA;AAAA,MAAA,OACL;AACK,gBAAA,KAAK,aAAa,MAAM;AACxB,gBAAA,KAAK,YAAY,KAAK;AAAA,MAClC;AACA,aAAO,OAAO;AAAA,IAClB,KAAK;AACO,cAAA,KAAK,aAAa,MAAM;AAChC,aACI,OACA,MACA,SAAS,KAAK,mBAAmB,IACjC,MACA;AAAA,IAER,KAAK;AACM,aAAA,OAAO,MAAM,KAAK;AAAA,IAC7B,KAAK;AACD,aAAO,OAAO,MAAM,SAAS,KAAK,OAAO,IAAI;AAAA,IACjD,KAAK,SAAS;AACJ,YAAA,aAAa,SAAS,KAAK,UAAU;AACpC,aAAA,WAAW,SAAS,KAAK,WAAW,CAAC,MAAM,MAC5C,KAAK,UAAU,MACf,IAAI,UAAU;AAAA,IACxB;AAAA,IACA;AACI,YAAM,YAAmB;AACzB,cAAQ,KAAK,sBAAsB,SAAS,cAAc,IAAI;AACvD,aAAA;AAAA,EACf;AACJ;AAEA,MAAM,aAAmD,CAAA;AASzC,SAAA,MAAM,MAAM,IAAoB;AAC5C,aAAW,GAAG,IAAI,WAAW,GAAG,KAAKA,iBAAU,MAAM,GAAG;AACxD,SAAO,WAAW,GAAG;AACzB;AAEA,SAAS,gBACL,MACA,cACM;AACN,MAAI,CAAC,MAAM;AACA,WAAA;AAAA,EACX;AACI,MAAA,OAAO,SAAS,UAAU;AAC1B,WAAO,CAAC,IAAI;AAAA,EAChB;AACA,MAAI,CAAC,cAAc;AACf,WAAO,IAAI,KAAK,KAAK,EAAE,CAAC;AAAA,EAC5B;AACO,SAAA,IAAI,KAAK,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EAAE,KAAK,EAAE,CAAC;AACjD;;;;"}